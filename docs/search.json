[
  {
    "objectID": "codigo_colab.html",
    "href": "codigo_colab.html",
    "title": "¡Código colaborativo!",
    "section": "",
    "text": "Enviá tu código para probarlo en la clase en vivo.\nUtilizá el siguiente formulario para enviarnos tu bloque de código de los ejercicios que realicemos durante la clase. Lo ejecutaremos en vivo frente a todos, revisando juntos cómo funciona y resolviendo dudas en tiempo real!\n\n\n\n\n\n  \n\n    \n    \n    \n    \n    \n\n    \n      \n        Nombre\n        \n      \n      \n        Bloque de código\n        \n      \n    \n    Enviar\n  \n\n\n\n\n\n Volver arriba",
    "crumbs": [
      "Inicio",
      "Código colaborativo!"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html",
    "href": "dia1/3.2_Vectores.html",
    "title": "Vectores",
    "section": "",
    "text": "En R, un vector es una colección ordenada de objetos de un mismo tipo o clase. Aprender sobre la creación y manipulación de vectores es un paso fundamental para comprender la manipulación de objetos más complejos, por ejemplo, las tablas y las matrices. Esto se debe a que estos objetos son justamente una colección de vectores.\nLa forma más simple de crear un vector es mediante la función genérica c(), que simplemente combina los elementos indicados entre comas:\n\nvec &lt;- c(1, 2, 3)\nvec\n\n[1] 1 2 3\n\n\nEs posible asignarles un nombre a cada elemento, lo cual puede ser útil en algunos contextos:\n\nvec &lt;- c(a = 1, b = 2, c = 3)\nvec\n\na b c \n1 2 3 \n\n\nSi quisiéramos averiguar qué clase de elementos contiene el vector, utilizamos la función class():\n\nclass(vec)\n\n[1] \"numeric\"\n\n\nEn general, podemos utilizar la función str() para conocer la estructura (structure) de cualquier objeto de R, incluyendo vectores:\n\nstr(vec)\n\n Named num [1:3] 1 2 3\n - attr(*, \"names\")= chr [1:3] \"a\" \"b\" \"c\"\n\n\nUn vector puede componerse de cinco clases principales de elementos:\n\n\n\n\n\n\n\nnumeric\nContienen números reales (decimales). Por ejemplo: c(1.2, 1.5, 1.7).\n\n\ninteger\nContienen números enteros. Debemos indicarse con la letra L luego del número. Por ejemplo: c(1L, -5L, 16L, 17L).\n\n\nlogical\nContienen valores booleanos o lógicos. Por ejemplo: c(TRUE, FALSE, NA) o c(T, F, T).\n\n\ncharacter\nContienen texto, el cual debe explicitarse con comillas simples o dobles. Por ejemplo: c(\"Algarrobo\", \"Quebracho\", \"Espinillo\").\n\n\nNULL\nRepresenta un vector vacío. Se genera al crear el vector: vec &lt;- NULL.\n\n\n\nRecordemos que al crear un vector, este puede componerse de un solo tipo de elementos. Por ello, debemos tener cuidado a la hora de generar nuestros vectores, y asegurarnos de que estamos generando un vector con elementos de la clase deseada. El uso de vectores con elementos de una clase incorrecta es un error muy común en distintos contextos del flujo de trabajo. Por ejemplo:\n\nvec &lt;- c(1985, \"Algarrobo\", \"Quebracho\")\nclass(vec)\n\n[1] \"character\"\n\n\nObservamos que el vector generado es de clase character. A la hora de forzar una clase para los elementos de un vector, R asigna prioridad a ciertas clases sobre otras. Si bien es posible correr líneas de código como la anterior, en general no sería una buena práctica hacerlo. Mejor ser explícito!\n\n\nOtra clase importante para los elementos de un vector es factor. Sirve para definir un factor categórico, compuesto por niveles (los elementos distintos y únicos del vector), los cuales siguen un orden específico:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies &lt;- factor(especies)\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Algarrobo Espinillo Quebracho\n\n\nEs posible cambiar el orden de los niveles, definiendo al factor con el argumento levels:\n\nespecies &lt;- factor(especies, levels = c(\"Quebracho\", \"Espinillo\", \"Algarrobo\"))\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Quebracho Espinillo Algarrobo\n\n\n\n\n\nDurante nuestro trabajo, puede ser útil la creación de vectores que sigan una lógica determinada. Si queremos generar una secuencia de números enteros con incremento de a una unidad, el operador de secuencia : es el indicado, siguiendo la lógica “desde:hasta”:\n\nsuc &lt;- 5:30\nsuc\n\n [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29\n[26] 30\n\n\nPara generar vectores con una lógica más compleja, las funciones seq() y rep() son adecuadas. La función seq() genera un sucesión de números (i.e. un vector de clase numeric o integer):\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nLos argumentos from y to determinan respectivamente los valores mínimos y máximos de la secuencia, mientras que el argumento by determina el incremento de la secuencia. Otra forma de generar el mismo vector del ejemplo sería:\n\nseq(from = 1, by = 2, length.out = 5)\n\n[1] 1 3 5 7 9\n\n\nEl argumento length.out determina el número máximo de elementos que contendrá el vector.\nAl correr la función con un único número, obtenemos una sucesión de números enteros, comenzando desde el 1:\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLa función rep() genera un nuevo vector a partir de la repetición de los elementos de un vector dado:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nvec_sp &lt;- rep(x = especies, times = 2)\nvec_sp\n\n[1] \"Algarrobo\" \"Quebracho\" \"Espinillo\" \"Algarrobo\" \"Quebracho\" \"Espinillo\"\n\n\nEl argumento x recibe un vector dado, mientras que el argumento times indica la cantidad de veces que debe repetirse el vector dado. Otro argumento relevante de la función rep() es el argumento each:\n\nvec_sp &lt;- rep(x = especies, each = 3)\nvec_sp\n\n[1] \"Algarrobo\" \"Algarrobo\" \"Algarrobo\" \"Quebracho\" \"Quebracho\" \"Quebracho\"\n[7] \"Espinillo\" \"Espinillo\" \"Espinillo\"\n\n\nAquí, each = 3 indica que cada elemento del vector en x debe repetirse 3 veces.\n\n\n\nAdemás de las expuestas, existen numerosas funciones nativas de R para generar vectores. Entre ellas, podemos mencionar a sample(), la cual genera un vector con un subconjunto aleatorio de elementos a partir un vector dado; runif() y rnorm(), los cuales generan vectores de elementos provenientes de una distribución uniforme o normal, respectivamente. Por otro lado, las funciones letters() y LETTERS() generan vectores de letras en minúscula o mayúscula.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#creación-de-vectores",
    "href": "dia1/3.2_Vectores.html#creación-de-vectores",
    "title": "Vectores",
    "section": "",
    "text": "En R, un vector es una colección ordenada de objetos de un mismo tipo o clase. Aprender sobre la creación y manipulación de vectores es un paso fundamental para comprender la manipulación de objetos más complejos, por ejemplo, las tablas y las matrices. Esto se debe a que estos objetos son justamente una colección de vectores.\nLa forma más simple de crear un vector es mediante la función genérica c(), que simplemente combina los elementos indicados entre comas:\n\nvec &lt;- c(1, 2, 3)\nvec\n\n[1] 1 2 3\n\n\nEs posible asignarles un nombre a cada elemento, lo cual puede ser útil en algunos contextos:\n\nvec &lt;- c(a = 1, b = 2, c = 3)\nvec\n\na b c \n1 2 3 \n\n\nSi quisiéramos averiguar qué clase de elementos contiene el vector, utilizamos la función class():\n\nclass(vec)\n\n[1] \"numeric\"\n\n\nEn general, podemos utilizar la función str() para conocer la estructura (structure) de cualquier objeto de R, incluyendo vectores:\n\nstr(vec)\n\n Named num [1:3] 1 2 3\n - attr(*, \"names\")= chr [1:3] \"a\" \"b\" \"c\"\n\n\nUn vector puede componerse de cinco clases principales de elementos:\n\n\n\n\n\n\n\nnumeric\nContienen números reales (decimales). Por ejemplo: c(1.2, 1.5, 1.7).\n\n\ninteger\nContienen números enteros. Debemos indicarse con la letra L luego del número. Por ejemplo: c(1L, -5L, 16L, 17L).\n\n\nlogical\nContienen valores booleanos o lógicos. Por ejemplo: c(TRUE, FALSE, NA) o c(T, F, T).\n\n\ncharacter\nContienen texto, el cual debe explicitarse con comillas simples o dobles. Por ejemplo: c(\"Algarrobo\", \"Quebracho\", \"Espinillo\").\n\n\nNULL\nRepresenta un vector vacío. Se genera al crear el vector: vec &lt;- NULL.\n\n\n\nRecordemos que al crear un vector, este puede componerse de un solo tipo de elementos. Por ello, debemos tener cuidado a la hora de generar nuestros vectores, y asegurarnos de que estamos generando un vector con elementos de la clase deseada. El uso de vectores con elementos de una clase incorrecta es un error muy común en distintos contextos del flujo de trabajo. Por ejemplo:\n\nvec &lt;- c(1985, \"Algarrobo\", \"Quebracho\")\nclass(vec)\n\n[1] \"character\"\n\n\nObservamos que el vector generado es de clase character. A la hora de forzar una clase para los elementos de un vector, R asigna prioridad a ciertas clases sobre otras. Si bien es posible correr líneas de código como la anterior, en general no sería una buena práctica hacerlo. Mejor ser explícito!\n\n\nOtra clase importante para los elementos de un vector es factor. Sirve para definir un factor categórico, compuesto por niveles (los elementos distintos y únicos del vector), los cuales siguen un orden específico:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies &lt;- factor(especies)\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Algarrobo Espinillo Quebracho\n\n\nEs posible cambiar el orden de los niveles, definiendo al factor con el argumento levels:\n\nespecies &lt;- factor(especies, levels = c(\"Quebracho\", \"Espinillo\", \"Algarrobo\"))\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Quebracho Espinillo Algarrobo\n\n\n\n\n\nDurante nuestro trabajo, puede ser útil la creación de vectores que sigan una lógica determinada. Si queremos generar una secuencia de números enteros con incremento de a una unidad, el operador de secuencia : es el indicado, siguiendo la lógica “desde:hasta”:\n\nsuc &lt;- 5:30\nsuc\n\n [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29\n[26] 30\n\n\nPara generar vectores con una lógica más compleja, las funciones seq() y rep() son adecuadas. La función seq() genera un sucesión de números (i.e. un vector de clase numeric o integer):\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nLos argumentos from y to determinan respectivamente los valores mínimos y máximos de la secuencia, mientras que el argumento by determina el incremento de la secuencia. Otra forma de generar el mismo vector del ejemplo sería:\n\nseq(from = 1, by = 2, length.out = 5)\n\n[1] 1 3 5 7 9\n\n\nEl argumento length.out determina el número máximo de elementos que contendrá el vector.\nAl correr la función con un único número, obtenemos una sucesión de números enteros, comenzando desde el 1:\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLa función rep() genera un nuevo vector a partir de la repetición de los elementos de un vector dado:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nvec_sp &lt;- rep(x = especies, times = 2)\nvec_sp\n\n[1] \"Algarrobo\" \"Quebracho\" \"Espinillo\" \"Algarrobo\" \"Quebracho\" \"Espinillo\"\n\n\nEl argumento x recibe un vector dado, mientras que el argumento times indica la cantidad de veces que debe repetirse el vector dado. Otro argumento relevante de la función rep() es el argumento each:\n\nvec_sp &lt;- rep(x = especies, each = 3)\nvec_sp\n\n[1] \"Algarrobo\" \"Algarrobo\" \"Algarrobo\" \"Quebracho\" \"Quebracho\" \"Quebracho\"\n[7] \"Espinillo\" \"Espinillo\" \"Espinillo\"\n\n\nAquí, each = 3 indica que cada elemento del vector en x debe repetirse 3 veces.\n\n\n\nAdemás de las expuestas, existen numerosas funciones nativas de R para generar vectores. Entre ellas, podemos mencionar a sample(), la cual genera un vector con un subconjunto aleatorio de elementos a partir un vector dado; runif() y rnorm(), los cuales generan vectores de elementos provenientes de una distribución uniforme o normal, respectivamente. Por otro lado, las funciones letters() y LETTERS() generan vectores de letras en minúscula o mayúscula.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#ejercicio-1",
    "href": "dia1/3.2_Vectores.html#ejercicio-1",
    "title": "Vectores",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nDado el vector rep(x = 3:1, each = 5), explore qué hacen las siguientes funciones: length(), sort(), rev() y unique().",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#vectores-y-expresiones-lógicas",
    "href": "dia1/3.2_Vectores.html#vectores-y-expresiones-lógicas",
    "title": "Vectores",
    "section": "Vectores y expresiones lógicas",
    "text": "Vectores y expresiones lógicas\nAhora que aprendimos cómo generar un vector, veremos cómo se evalúan las expresiones lógicas en este contexto. Por ejemplo:\n\n3 == 1:10\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nAquí, evaluamos si cada elemento del vector 1:10 es igual al número 3, indicando TRUE en dicho caso. En cambio, utilizando != obtenemos como resultado lo opuesto:\n\n3 != 1:10\n\n [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nObviamente, los operadores relaciones también son válidos:\n\n3 &gt;= 1:10\n\n [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nEn el contexto de vectores, es muy útil el operador lógico %in%. Este operador devuelve TRUE para cada elemento a la izquierda, sólo si dicho elemento es encontrado en el vector indicado a la derecha del operador. Caso contrario, devuelve FALSE. Por ejemplo:\n\n3 %in% 1:10\n\n[1] TRUE\n\n\nTambién es posible indicar más de un elemento a la izquierda del operador:\n\nc(1, 2, 3) %in% 1:10\n\n[1] TRUE TRUE TRUE\n\n\nPor otro lado, las funciones all() y any() son muy utilizadas a la hora de evaluar vectores lógicos. Anteriormente, vimos que estas funciones sirven para evaluar varias condiciones al mismo tiempo, separadas por una coma. No obstante, también es posible indicarle directamente un vector lógico. En el contexto de vectores, la función all() devuelve TRUE si todos los elementos del vector lógico son TRUE, caso contrario devuelve FALSE. Por ejemplo\n\ncond &lt;- 11 &gt; 1:10\nall(cond)\n\n[1] TRUE\n\n\nEn cambio, con solo haber un sólo elemento igual a FALSE, la función all() devuelve FALSE:\n\ncond &lt;- 10 &gt; 1:10\nall(cond)\n\n[1] FALSE\n\n\nLa función any(), devuelve TRUE si al menos un elemento del vector lógico es TRUE:\n\ncond &lt;- 10 &lt;= 1:10\nany(cond)\n\n[1] TRUE\n\n\nCaso contrario, si todos los elementos son iguales a FALSE, any() devuelve FALSE:\n\ncond &lt;- 15 &lt; 1:10\nany(cond)\n\n[1] FALSE\n\n\nFinalmente, es útil aclarar que en el contexto de operaciones aritméticas, TRUE equivale a 1 y FALSE equivale a 0. Por ejemplo, sea la siguiente condición:\n\ncond &lt;- 5 &gt;= 1:10\ncond\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nSi sumamos los elementos del vector lógico, obtenemos lo siguiente:\n\nsum(cond)\n\n[1] 5\n\n\n¿De qué sirve conocer esto? Quizás no le veamos utilidad ahora mismo, pero puede llegar a ser útil en el contexto de un trabajo más avanzado (por ejemplo, en el contexto de manipulación de tablas).",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#manipulación-de-vectores",
    "href": "dia1/3.2_Vectores.html#manipulación-de-vectores",
    "title": "Vectores",
    "section": "Manipulación de vectores",
    "text": "Manipulación de vectores\nUn apartado fundamental para aprender a programar en R es la manipulación de vectores. En pocas palabras, nos referimos a generar un nuevo vector a partir de uno creado previamente, de manera tal que sirva para realizar una tarea específica. Este tipo de tareas será de gran utilidad a la hora de trabajar con tablas.\nDado un vector, interesa averiguar su contenido, lo cual lo podemos hacer simplemente imprimiendo el vector en la consola, o rescatando uno o más elementos a través de sus índices:\n\nvec &lt;- seq(from = -5, to = 5, by = 0.25)\nvec[15]\n\n[1] -1.5\n\nvec[c(1, 5, 10)]\n\n[1] -5.00 -4.00 -2.75\n\nvec[13:18]\n\n[1] -2.00 -1.75 -1.50 -1.25 -1.00 -0.75\n\n\nLos corchetes [] indican que se seleccionará un subconjunto de elementos del vector. En la segunda línea del ejemplo, seleccionamos el elemento de índice 15. En la tercera línea de código, seleccionamos los elementos de índice 1, 5 y 10. En la cuarta línea de código, en cambio, seleccionamos los elementos 13 al 18 (i.e. índices).\nEs posible excluir elementos con el símbolo -:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies_sub &lt;- especies[-2]\nespecies_sub\n\n[1] \"Algarrobo\" \"Espinillo\"\n\n\nAdemás de la posibilidad de indicar índices, es posible utilizar un vector lógico. Dicho vector puede generarse definiendo condiciones que los elementos deben cumplir.\n\ncond1 &lt;- vec &gt; -2 & vec &lt; 2\ncond1\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[25]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE\n\nvec_sub &lt;- vec[cond1]\n\nAquí, el objeto “cond1” es un vector lógico, indicando TRUE o FALSE para cada elemento del vector “vec”, según la condición expuesta: que el número sea mayor a -2 (vec &gt; -2) y (&) menor a 2 (vec &lt; 2). Notar que hay que ser explícito a la hora de definir la condición. Es útil indicar la condición directamente, sin necesidad de crear un objeto nuevo:\n\nvec_sub &lt;- vec[vec &gt; -2 & vec &lt; 2]\nvec_sub\n\n [1] -1.75 -1.50 -1.25 -1.00 -0.75 -0.50 -0.25  0.00  0.25  0.50  0.75  1.00\n[13]  1.25  1.50  1.75\n\n\nLa función subset() permite hacer la misma operación de filtrado, indicando el vector a filtrar, y la condición:\n\nvec_sub &lt;- subset(vec, vec &gt; -2 & vec &lt; 2)\nvec_sub\n\n [1] -1.75 -1.50 -1.25 -1.00 -0.75 -0.50 -0.25  0.00  0.25  0.50  0.75  1.00\n[13]  1.25  1.50  1.75\n\n\nLa función which() devuelve los índices de los elementos de un vector que cumplen con una condición dada:\n\nwhich(vec &gt; -2 & vec &lt; 2)\n\n [1] 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28\n\n\nPara pensar: Sin correr la expresión, ¿qué pasa si la condición que definimos es !(vec &gt; -2 & vec &lt; 2)?\nUna vez seleccionado el subconjunto de elementos de un vector, es posible asignarle un valor diferente:\n\nvec[vec &lt;= 0] &lt;- 0\n\nAquí, seleccionamos los valores menores o iguales a 0, y les asignamos el valor 0. Notar que en este caso, al ser un único valor de reemplazo, no es necesario repetir el 0 tantas veces como valores a reemplazar.\nA veces, resulta útil reemplazar los valores NA (no dato) por algún otro valor útil, para lo cual podemos utilizar la función is.na().\n\nvec &lt;- c(5, 8, 16, NA, 3)\nvec[is.na(vec)] &lt;- 0\nvec\n\n[1]  5  8 16  0  3\n\n\nEn el contexto de valores NA, es útil la función na.omit(), que remuevo todos los elementos que sean NA:\n\nvec &lt;- c(5, 8, 16, NA, 3, 8, NA)\nvec2 &lt;- na.omit(vec)\nvec2\n\n[1]  5  8 16  3  8\nattr(,\"na.action\")\n[1] 4 7\nattr(,\"class\")\n[1] \"omit\"\n\n\nA la hora de efectuar subconjuntos de vectores, es importante diferenciar el uso del operador == del %in%, que ya introdujimos anteriormente. Al utilizar el operador == nos preguntamos si cada elemento del vector indicado a la izquierda del operador es igual al elemento (o a los elementos) indicado a la derecha; y utilizamos la expresión lógica resultante para hacer el subset del vector:\n\nespecies &lt;- rep(c(\"Algarrobo\", \"Molle\", \"Quebracho\", \"Piquillin\"), each = 5)\nespecies[especies == \"Quebracho\"]\n\n[1] \"Quebracho\" \"Quebracho\" \"Quebracho\" \"Quebracho\" \"Quebracho\"\n\n\n¿Cómo procedemos si, por ejemplo, quisiéramos seleccionar más de una especie? El operador == ya no es útil por sí solo. Una opción es la siguiente:\n\nespecies[especies == \"Molle\" | especies == \"Piquillin\"]\n\n [1] \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Piquillin\"\n [7] \"Piquillin\" \"Piquillin\" \"Piquillin\" \"Piquillin\"\n\n\nOtra forma de hacerlo es utilizar el operador %in%. Recordemos que este operador indica TRUE o FALSE si cada elemento del vector a la izquierda está contenido en el vector indicado a la derecha:\n\nespecies[especies %in% c(\"Molle\", \"Piquillin\")]\n\n [1] \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Piquillin\"\n [7] \"Piquillin\" \"Piquillin\" \"Piquillin\" \"Piquillin\"\n\n\nComo veremos más adelante, el operador %in% es muy útil en el contexto de manipulación de tablas.\nEs posible añadir elementos a un vector con la función c():\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies &lt;- c(especies, \"Yuchan\", \"Tusca\")\nespecies\n\n[1] \"Algarrobo\" \"Quebracho\" \"Espinillo\" \"Yuchan\"    \"Tusca\"    \n\n\nPara explorar: La función append() es una forma de general de hacer esto. Explore ?append.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#funciones-básicas-para-vectores-numéricos",
    "href": "dia1/3.2_Vectores.html#funciones-básicas-para-vectores-numéricos",
    "title": "Vectores",
    "section": "Funciones básicas para vectores numéricos",
    "text": "Funciones básicas para vectores numéricos\nAnteriormente, hemos visto cómo trabajan las funciones round(), ceiling(), floor() and trunc() con números sueltos. Sin embargo, estas funciones, al igual que muchas otras funciones nativas de R, son funciones vectorizadas. Esto significa que pueden trabajar sobre un vector, y arrojar un resultado para cada uno de los elementos del vector.\nPor ejemplo:\n\nvec &lt;- c(1.233, 1.924, 0.46)\nround(vec, digits = 1)\n\n[1] 1.2 1.9 0.5\n\n\nR también provee de numerosas funciones nativas para obtener medidas de resumen. Podemos mencionar a mean() para calcular el promedio, median() para calcular la mediana y sd() para calcular el desvío estándar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#ejercicio-final",
    "href": "dia1/3.2_Vectores.html#ejercicio-final",
    "title": "Vectores",
    "section": "Ejercicio final",
    "text": "Ejercicio final\n\nUtilice las funciones rep() y seq() para generar los siguientes vectores:\n\n\nUna sucesión de números pares de 15 elementos.\nUna sucesión de números decimales, con un incremento de 0.15.\nUn vector tipo character, que indique 4 categorías discretas, repetidas de a 3 cada una.\nUn vector que repita 5 veces el siguiente vector: c(F, T, F, T).\n\n\nDado el vector seq(from = 0, to = 1, by = 0.01), y utilizando los aprendido sobre manipulación de vectores y expresiones lógicas, genere nuevos vectores de acuerdo a los siguientes criterios:\n\n\nQue contenga los elementos de índices 10 a 20.\nQue excluya los elementos 30 a 50. Ayuda: utilice paréntesis.\nQue los elementos sean mayores a 0.5.\nQue los elementos sean menores o iguales a 0.3 o mayores a 0.7.\nQue los elementos cumplan con la condición opuesta a la inmediatamente anterior.\n\n\nGenere un vector de 500 números provenientes de una distribución normal, de media 15 y desvío estándar 4. Para ello, utilice la función rnorm() (explore la ayuda mediante ?rnorm). Seguidamente, verifique los valores de media, mediana y desvío estándar de la muestra. Calcule los cuantiles tradicionales mediante quantile(). Calculo el percentil 5% y el 95%.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html",
    "href": "dia1/2.1_FlujoTrabajo.html",
    "title": "Flujo de Trabajo en R",
    "section": "",
    "text": "Cuando trabajamos con R (pero esto es válido también para cualquier otro proyecto de código o análisis de datos) debemos intentar ser sumamente organizados. Disponer de un sistema que permita identificar rápidamente cuales son las entradas (datos) y las salidas (resultados de análisis, gráficos, etc.), así como los pasos intermedios, si existieran, nos facilitará mucho nuestro trabajo. Ya hemos visto que en RStudio podemos crear Proyectos que nos ayudarán a mantener todo más organizado. A continuación veremos algunas otras formas de comentar e indexar el código en sí mismo para poder lograr una mayor organización y claridad.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ante-todo-orden-y-organización",
    "href": "dia1/2.1_FlujoTrabajo.html#ante-todo-orden-y-organización",
    "title": "Flujo de Trabajo en R",
    "section": "",
    "text": "Cuando trabajamos con R (pero esto es válido también para cualquier otro proyecto de código o análisis de datos) debemos intentar ser sumamente organizados. Disponer de un sistema que permita identificar rápidamente cuales son las entradas (datos) y las salidas (resultados de análisis, gráficos, etc.), así como los pasos intermedios, si existieran, nos facilitará mucho nuestro trabajo. Ya hemos visto que en RStudio podemos crear Proyectos que nos ayudarán a mantener todo más organizado. A continuación veremos algunas otras formas de comentar e indexar el código en sí mismo para poder lograr una mayor organización y claridad.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#comentarios-e-índices",
    "href": "dia1/2.1_FlujoTrabajo.html#comentarios-e-índices",
    "title": "Flujo de Trabajo en R",
    "section": "Comentarios e índices",
    "text": "Comentarios e índices\nComo hemos visto previamente, cuando estemos trabajando dentro de RStudio la mayor parte del tiempo estaremos editando un archivo de texto con nuestro código. A este archivo que contiene todas las instrucciones, desde la carga de paquetes necesarios, la carga de datos, la manipulación de los mismos, la ejecución de análisis, las instrucciones para realizar gráficos y la exportación de los mismos, etcétera, lo llamamos script o rutina.\nAdemas del código propiamente dicho, ningún script está completo si no está correctamente anotado, es decir, si no contiene texto humanamente legible que permita seguir qué es lo que se está haciendo en el mismo. La forma de introducir un comentario en el código es anteponer # a la linea en cuestión. De esta forma, el interprete de código evitará su ejecución.\n\n\n\n\n\n\n\n# Esto es un comentario y no se ejecutará\nprint(\"Esto es código que sí será ejecutado\")\n\n[1] \"Esto es código que sí será ejecutado\"\n\n\nOtra función interesante relacionada a los comentarios, es que dentro de RStudio se puede generar índices de contenido para saltar de una parte a otra del código fácilmente. Para generarlos, es necesario encerrar la entrada del índice con caracteres #. El número de caracteres # del inicio irán indicando el nivel de la entrada (de 1º a 6º), mientras que al final siempre debe haber 4 caracteres # para que la línea sea reconocida como una entrada del índice. Esto irá produciendo un índice al que podremos acceder desde el menú desplegable  Contenidos, ubicado abajo a la izquierda en el editor de scripts, o desplegando el índice de contenidos del archivo con el botón  Outline ubicado en la parte superior derecha del editor.\n\n Click en la imagen para agrandar.\n\nDe igual forma, cada entrada del índice nos permitirá plegar o colapsar, las líneas de código que contenga. Esto puede ser útil para ocultar algunas secciones extremadamente largas o para secciones que, al momento de editar el script, no sean de interés. Esta funcionalidad de colapsar líneas, también estará disponible para bloques de código de control de flujo y para bloques que definan funciones. En el día 3 veremos específicamente como usar estas estructuras de control de flujo y como crear funciones, por el momento, prestemos atención en la captura siguiente a los números de línea del editor y a las lineas dónde vemos el botón , indicando que es un bloque de código colapsado.\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-1",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-1",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nCree una rutina dentro de dia1 y cree un índice que contenga títulos de 1º, 3º, 5º y 6º nivel.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#carga-de-funciones-externas",
    "href": "dia1/2.1_FlujoTrabajo.html#carga-de-funciones-externas",
    "title": "Flujo de Trabajo en R",
    "section": "Carga de funciones externas",
    "text": "Carga de funciones externas\nMás adelante veremos en profundidad como se construye una función, por el momento solo digamos que una función es una forma de personalizar la ejecución de código para una función específica que nosotros diseñamos. Para evitar repetir en todos nuestros scripts estas funciones personalizadas, podemos generar una biblioteca propia de funciones desde donde las cargaremos. Así mismo, puede que algún/a colega haya diseñado una función y nos la envíe, en cuyo caso también podemos cargarla sin necesidad de copiar y pegar la misma en nuestro script.\nPara cargar una función externa, por supuesto, primero debemos disponer de una. Para esta demostración utilizaremos una función muy sencilla que calcula una función cuadrática con un solo término, es decir, es una función de tipo y(x) = x²:\n\n# Función cuadrática\nfun_cuad &lt;- function(x) { x^2 }\n\n# Probar la función\nfun_cuad(c(1,2,3,4))\n\n[1]  1  4  9 16\n\n\nSi disponemos de una o múltiples funciones escritas en un archivo, podemos cargarlas directamente con la función source().\n\n# Cargar la función guardada en el archivo \"mifuncion.R\"\nsource(\"mifuncion.R\")\n\n# Probar la función\nfun_cuad(c(1,2,3,4))\n\n[1]  1  4  9 16\n\n\nDe igual forma, también podríamos vincular directamente a un archivo online, pasándole a source() la URL al código fuente. En este caso sería:\n\nURL &lt;- \"https://raw.githubusercontent.com/pastornicolas/fundamentos_R/7abf94fd87129b5433c5ac70af1194e822b2afb6/dia1/mifuncion.R\"\nsource(URL)",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-2",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-2",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nDescargue el archivo con la función al directorio de trabajo correspondiente a dia1 y cárguela utilizando source(). Pruebe su correcto funcionamiento para los valores:\n\n1, 2, 3, 4\n1, 10, 100",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#trabajando-sin-interfaz-gráfica",
    "href": "dia1/2.1_FlujoTrabajo.html#trabajando-sin-interfaz-gráfica",
    "title": "Flujo de Trabajo en R",
    "section": "Trabajando sin interfaz gráfica",
    "text": "Trabajando sin interfaz gráfica\nEn algunas ocasiones deberemos usar R de una forma no interactiva, esto es, daremos la instrucción para que se ejecute un script dado pero ya no viéndolo dentro de RStudio y corriendo línea por línea, sino desde alguna herramienta propia del Sistema Operativo. Una situación típica de esto es si alguna vez trabajamos con R dentro de un cluster de cómputo de alto rendimiento, como por ejemplo en el CCAD (Centro de Cómputo de Alto Desempeño) de la UNC. Otras situaciones puede ser incorporar algún procesamiento con R dentro un pipeline de análisis que utilice otros lenguajes en combinación a R (e.g. BASH, python, etc.)\nExisten múltiples formas, dependiendo del Sistema Operativo que estemos utilizando, para ejecutar un script de R desde el propio sistema, pero la forma más sencilla es invocar al archivo ejecutable de R llamado Rscript. En sistemas Windows, típicamente se encuentra en “C:\\Program Files\\R\\R-version\\bin\\x64\\” y debemos ejecutarlo desde el “Simbolo del sistema”. En sistemas GNU/Linux basta con abrir la terminal de nuestra preferencia y ejecutar:\n\nRscript mi_script.R\n\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-3",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-3",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nDescargue el archivo con el script para graficar la función cuadrática al directorio de trabajo correspondiente a dia1. Ejecute el script en su sistema por fuera de RStudio y chequee el correcto funcionamiento (i.e. se debería ver en la consola los mensajes de salida y se debería crear un archivo PDF con el gráfico en el directorio donde se ejecutó).",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-4",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-4",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nAbra el script que recién ejecutó en el editor de RStudio. Intente interpretar que hace cada línea, recuerde usar las función help() o ? para acceder a las ayudas internas de las funciones. No se preocupe si por el momento no lo entiende completamente, para cuando este curso termine no habrá ni una sola de esas líneas que no sea capaz de interpretar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#algunas-máximas-para-recordar-a-la-hora-de-programar-en-r",
    "href": "dia1/2.1_FlujoTrabajo.html#algunas-máximas-para-recordar-a-la-hora-de-programar-en-r",
    "title": "Flujo de Trabajo en R",
    "section": "Algunas máximas para recordar a la hora de programar en R",
    "text": "Algunas máximas para recordar a la hora de programar en R\n\nExplícito es mejor que implícito. Ante la duda, declaremos explícitamente todo lo que hacemos. Esto puede ser un poco engorroso, pero nos ayudara sobre todo en la etapa de aprendizaje inicial.\nOrden, orden, orden… Intentar hacer el trabajo de forma sistemática desde el comienzo siempre es más fácil que luego intentar ordenar algo caótico cuando nos toque publicar y compartir nuestro código.\nUn breve descanso a tiempo puede significar un ahorro de horas de frustración. En ocasiones algo no anda y no podemos encontrar el error fácilmente. En esos momentos, cuando ya leímos de arriba a abajo varias veces nuestro código y seguimos sin poder encontrar el error, mejor es ir a prepararse un mate, dar una vuelta a la manzana, o lo que fuera. La gran mayoría de estos errores difíciles se encuentran y resuelven luego de descansar un poco.\nNo estamos solos/as. Si lo anterior no funciona, recordemos que siempre podemos acudir a un foro web, a una IA, o a un/a colega que pueda revisar nuestro código. Generalmente el problema que hace días no podemos solucionar, un par de ojos frescos y sin frustración acumulada lo encuentran en cuestión de minutos, o incluso en un simple golpe de vista.\nRutas, rutas, rutas… Dicho lo anterior, en general la mayoría de los problemas surgen por no escribir correctamente las rutas a archivos de entrada o salida.\nParéntesis, corchetes y llaves… Dicho lo anterior, la segunda mayoría de problemas surgen porque no respetamos algún requisito de la sintaxis, muy probablemente abrimos más paréntesis (o corchetes o llaves) de los que cerramos, o insertamos un comentario sin querer en algún lado interrumpiendo un proceso, etc.\nNada mejor que aprender haciendo. Intentar aprender a programar sin tener un objetivo claro es mucho más difícil. Si ahora mismo no tenemos algo concreto, desempolvemos esos análisis que hicimos en otro software hace un tiempo e intentemos replicarlos en R, o busquemos el tutorial de algún paquete específico que nos interese y lo estudiemos. Pero no paremos de usar el lenguaje, al menos, hasta que sintamos que tenemos cierta holgura en su uso.\nEn R, y en programación en general, existen múltiples formas de hacer lo mismo. Es imposible conocer todas las formas, y obviamente, cada quién irá encontrando aquellas que le resulten mejores (e incluso a lo largo del tiempo verán que irán cambiando). Si el código hace lo que supone que tiene que hacer, entonces está bien. Siempre habrá tiempo para perfeccionar la eficiencia y la estética.\nEn ocasiones puede ser muy frustrante que algo no nos salga, evitemos la tentación de volver a esa planilla de cálculo, o a ese software donde antes nos salía todo. Todo el tiempo que invirtamos va a dar muchísimos frutos en el futuro.\nR, o el lenguaje que aprendamos a continuación, es una herramienta fantástica pero no reemplaza de ninguna manera la formación que tenemos. Por más sofisticados que sean nuestros análisis, al fin y al cabo, será nuestro criterio profesional el que decida si el resultado es o no interesante. Nunca nos olvidemos que lo más importante en nuestro trabajo son las preguntas que intentamos responder, no los medios que usamos para hacerlo.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html",
    "href": "dia4/6.1_graficos_base.html",
    "title": "Gráficos con R base",
    "section": "",
    "text": "La representación gráfica de datos y resultados es una parte importante de nuestro quehacer habitual en ámbitos académicos y científicos. Una de las razones de la gran popularidad de R yace en su excelente apartado gráfico, con el cual se pueden producir gráficos de buena calidad listos para publicar. De forma general, existen dos métodos principales para realizar gráficos en R: el basado en el sistema básico de R base y el basado en el paquete ggplot2. Ambas opciones poseen sus propias ventajas y desventajas y generalmente son usados a la par. Es decir, en algunas ocasiones convendrá o será más cómodo, utilizar uno y, en otras ocasiones, será mejor opción el otro.\n\n\n\n\n\n\nEn esta clase veremos como construir gráficos con R base. Para empezar, definiremos un concepto relativo al nivel de la función utilizada. Cuando grafiquemos podremos utilizaremos funciones de alto nivel, que son aquellas funciones que crean nuevos gráficos, generalmente junto a los principales ejes, etiquetas ó títulos (e.g. plot(), hist(), etc.); y funciones de bajo nivel, que son aquellas con las que podremos añadir elementos extras a un gráfico ya creado, como puntos, líneas, flechas u otras etiquetas (e.g. points(), text(), etc.). La combinación de funciones de alto y bajo nivel nos permite realizar una enorme personalización del gráfico, aunque en algunas ocasiones esto puede llevar a que tengamos que definir cada aspecto del mismo. Este compromiso entre el nivel de personalización deseado y la cantidad de líneas de código necesarias puede parecer un poco abrumador al comienzo; pero, luego de un tiempo, en general optaremos siempre por una completa personalización. Sumado a esto, con el tiempo acumularemos plantillas propias para ciertos tipos de gráficos que realicemos frecuentemente, y solo nos bastará con cambiar los datos y algunos parámetros menores para obtener un nuevo gráfico listo para su publicación (o al menos su revisión 😬).\nEn cuanto a los tipos de gráficos, las posibilidades que ofrece R son realmente ilimitadas y podrían constituir en sí mismo un curso de representación gráfica. Por ello, para aprender los fundamentos del funcionamiento del apartado gráfico, veremos a continuación dos tipos de gráficos:\n\nHistogramas: nos permiten ver la distribución de frecuencia en nuestros datos.\nGráficos de dispersión (scatterplots): nos permiten evaluar la relación entre variables cuantitativas.\nGráficos de caja (boxplot): posibilitan comparar, entre categorías, la distribución cuantitativa de los datos basada en sus cuartiles y mostrando, además, intervalos de confianza y valores atípicos (outliers).\n\nEn cuanto a la personalización de los gráficos, intentaremos a continuación abordarlo desde una perspectiva progresiva, partiendo de los gráficos simples elaborados con funciones de alto nivel, para luego ir sumando parámetros y funciones de bajo nivel, haciendo más complejo nuestro código para definir los principales elementos que componen un gráfico.\n\n\n\nEn el primer día de clases, ya realizamos nuestro primer gráfico sencillo. Podemos, con todo lo que sabemos ahora, entender perfectamente como funciona el siguiente código:\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n\n\n\n\n\n\n\n\nEmpezando por los datos, ya sabemos que la expresión 1:3 genera un vector compuesto por 1,2,3, así mismo rep(1,3) está generando una repetición de 1, tres veces, es decir: 1,1,1. La función plot() espera 2 argumentos posicionales correspondientes a las coordenadas x e y, respectivamente. Por ende, lo que estamos haciendo es indicar que las posiciones para el eje x=(1,2,3) y las posiciones para el eje y=(1,1,1). De allí que los 3 puntos graficados se ubiquen en las coordenadas (x,y)=(1,1),(1,2),(1,3).\n\n\nCon estos tres parámetros básicos de la función plot() podemos indicar que tipo de marcador se graficará (pch), que colores queremos que estos marcadores tengan y que tamaño relativo queremos que tengan (cex). Debajo podemos ver un ejemplo, pero nunca esta de más tener a mano una carta de referencia descargada en nuestra PC o un sitio que podamos consultar online. Notar que a los colores podemos indicarlos con un número del 1 al 8 (luego comienzan a ciclarse) como se muestra aquí abajo, o con sus nombres (e.g. ‘black’, ‘red’, etc.) como en el ejemplo previo; así como también podemos usar notación hexadecimal o RGB.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#el-apartado-gráfico-de-r",
    "href": "dia4/6.1_graficos_base.html#el-apartado-gráfico-de-r",
    "title": "Gráficos con R base",
    "section": "",
    "text": "La representación gráfica de datos y resultados es una parte importante de nuestro quehacer habitual en ámbitos académicos y científicos. Una de las razones de la gran popularidad de R yace en su excelente apartado gráfico, con el cual se pueden producir gráficos de buena calidad listos para publicar. De forma general, existen dos métodos principales para realizar gráficos en R: el basado en el sistema básico de R base y el basado en el paquete ggplot2. Ambas opciones poseen sus propias ventajas y desventajas y generalmente son usados a la par. Es decir, en algunas ocasiones convendrá o será más cómodo, utilizar uno y, en otras ocasiones, será mejor opción el otro.\n\n\n\n\n\n\nEn esta clase veremos como construir gráficos con R base. Para empezar, definiremos un concepto relativo al nivel de la función utilizada. Cuando grafiquemos podremos utilizaremos funciones de alto nivel, que son aquellas funciones que crean nuevos gráficos, generalmente junto a los principales ejes, etiquetas ó títulos (e.g. plot(), hist(), etc.); y funciones de bajo nivel, que son aquellas con las que podremos añadir elementos extras a un gráfico ya creado, como puntos, líneas, flechas u otras etiquetas (e.g. points(), text(), etc.). La combinación de funciones de alto y bajo nivel nos permite realizar una enorme personalización del gráfico, aunque en algunas ocasiones esto puede llevar a que tengamos que definir cada aspecto del mismo. Este compromiso entre el nivel de personalización deseado y la cantidad de líneas de código necesarias puede parecer un poco abrumador al comienzo; pero, luego de un tiempo, en general optaremos siempre por una completa personalización. Sumado a esto, con el tiempo acumularemos plantillas propias para ciertos tipos de gráficos que realicemos frecuentemente, y solo nos bastará con cambiar los datos y algunos parámetros menores para obtener un nuevo gráfico listo para su publicación (o al menos su revisión 😬).\nEn cuanto a los tipos de gráficos, las posibilidades que ofrece R son realmente ilimitadas y podrían constituir en sí mismo un curso de representación gráfica. Por ello, para aprender los fundamentos del funcionamiento del apartado gráfico, veremos a continuación dos tipos de gráficos:\n\nHistogramas: nos permiten ver la distribución de frecuencia en nuestros datos.\nGráficos de dispersión (scatterplots): nos permiten evaluar la relación entre variables cuantitativas.\nGráficos de caja (boxplot): posibilitan comparar, entre categorías, la distribución cuantitativa de los datos basada en sus cuartiles y mostrando, además, intervalos de confianza y valores atípicos (outliers).\n\nEn cuanto a la personalización de los gráficos, intentaremos a continuación abordarlo desde una perspectiva progresiva, partiendo de los gráficos simples elaborados con funciones de alto nivel, para luego ir sumando parámetros y funciones de bajo nivel, haciendo más complejo nuestro código para definir los principales elementos que componen un gráfico.\n\n\n\nEn el primer día de clases, ya realizamos nuestro primer gráfico sencillo. Podemos, con todo lo que sabemos ahora, entender perfectamente como funciona el siguiente código:\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n\n\n\n\n\n\n\n\nEmpezando por los datos, ya sabemos que la expresión 1:3 genera un vector compuesto por 1,2,3, así mismo rep(1,3) está generando una repetición de 1, tres veces, es decir: 1,1,1. La función plot() espera 2 argumentos posicionales correspondientes a las coordenadas x e y, respectivamente. Por ende, lo que estamos haciendo es indicar que las posiciones para el eje x=(1,2,3) y las posiciones para el eje y=(1,1,1). De allí que los 3 puntos graficados se ubiquen en las coordenadas (x,y)=(1,1),(1,2),(1,3).\n\n\nCon estos tres parámetros básicos de la función plot() podemos indicar que tipo de marcador se graficará (pch), que colores queremos que estos marcadores tengan y que tamaño relativo queremos que tengan (cex). Debajo podemos ver un ejemplo, pero nunca esta de más tener a mano una carta de referencia descargada en nuestra PC o un sitio que podamos consultar online. Notar que a los colores podemos indicarlos con un número del 1 al 8 (luego comienzan a ciclarse) como se muestra aquí abajo, o con sus nombres (e.g. ‘black’, ‘red’, etc.) como en el ejemplo previo; así como también podemos usar notación hexadecimal o RGB.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-1",
    "href": "dia4/6.1_graficos_base.html#ejercicio-1",
    "title": "Gráficos con R base",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nUtilizando como molde el código del gráfico previo, intente realizar uno que posea 3 puntos en las coordenadas (x,y)=(1,3),(2,1),(3,2), que estos puntos sean rombos de color azul, amarillo y rojo, respectivamente, todos con borde negro, y que su tamaño relativo sea distinto y creciente, como se muestra a continuación:\n\n\n\n\n\n\n\n\n\nAyuda: los valores de cex recomendados son 1,2,3. Para las formas con borde y relleno, col solo especifica el color del borde. Busque por sus medios qué parámetro permite indicar el color de relleno.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#histogramas",
    "href": "dia4/6.1_graficos_base.html#histogramas",
    "title": "Gráficos con R base",
    "section": "Histogramas",
    "text": "Histogramas\nLos histogramas son gráficos que nos permiten visualizar la distribución de frecuencia de los datos. Son muy utilizados en el análisis exploratorio de los datos. Graficar histogramas en R es sumamente sencillo gracias a la función hist(), una función de alto nivel que permite realizarlos. Para el siguiente ejemplo, visualizaremos una distribución normal de 1.000 observaciones con media = 0 y desviación estandar = 0 .\n\nhist(rnorm(1000))\n\n\n\n\n\n\n\n\n\nEditando títulos y etiquetas de ejes\nComo podemos ver, el gráfico muestra una serie de barras con la frecuencia acumulada de los valores por intervalos igualmente espaciados. Así mismo, como se trata de una función de alto nivel, ya posee configurado algunas cuestiones, como las etiquetas de los ejes y el título. Para modificar esto último podríamos incluir los parámetros xlab e ylab, para las etiquetas de los ejes x e y, respectivamente y main para el título:\n\nhist(rnorm(1000),\n     main = \"Histograma de Distribución Normal\",\n     xlab = \"Valores observados\",\n     ylab = \"Frecuencias\"\n)",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-2",
    "href": "dia4/6.1_graficos_base.html#ejercicio-2",
    "title": "Gráficos con R base",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nAyudándose con la documentación de las funciones hist() y rnorm():\n\nGrafique un histograma correspondiente a un ensayo de medición de la altura de una población para los cuales se midieron 350 personas y se obtuvo un valor promedio de 175 cm, con una desviación estándar de 5 cm.\nImagine que este ensayo se repitió en diferentes localidades, y ahora se encuentra con 30.000 observaciones, con media 173,47 cm y desviación estándar de 4,03 cm. Le han pedido que realice un nuevo histograma y le han informado que la editorial donde va a ser publicado el informe ha solicitado que el mismo posea título, etiquetas, colores de relleno y borde de las barras del histograma, muy específicos. Para tal fin, le han adjuntado el ejemplo que se muestra debajo. Realice el nuevo gráfico y guárdelo en la carpeta correspondiente a dia4.\n\n\n\n\n\n\n\n\n\n\n\nPuede que su gráfico se vea muy parecido, más no igual al ejemplo. De hecho, cada vez que llama a la función gráfica observará que el gráfico cambia, ¿por qué sucede esto?",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#gráfico-de-dispersión",
    "href": "dia4/6.1_graficos_base.html#gráfico-de-dispersión",
    "title": "Gráficos con R base",
    "section": "Gráfico de dispersión",
    "text": "Gráfico de dispersión\nMuchas veces necesitamos evaluar si existe una relación entre 2 variables cuantitativas. Una de las mejores formas de representar gráficamente estas relaciones es mediante gráficos de dispersión. A continuación un ejemplo utilizando el conjunto de datos iris, con el que ya debería estar muy familiarizado.\n\nwith(iris, plot(Petal.Length, Sepal.Length, \n                pch = 21, col = \"black\", bg = \"forestgreen\", cex = 1,\n                xlim = c(0, 8),\n                ylim = c(0, 8)\n                )\n     )\n\n\n\n\n\n\n\n\n\n\nPara pensar: En el código precedente apareció with(), una función que previamente no habíamos utilizado. Analice el código y trate de descifrar que ventajas tiene su uso. Por supuesto, siempre puede consultar la ayuda con ?with().\n\nLímites gráficos\nEn el código del gráfico previo, aparecieron algunas novedades: los parámetros xlim e ylim. Como puede imaginarse, se trata de los parámetros para fijar los límites de los ejes. Ambos parámetros esperan un vector de largo 2 con los rangos de las coordenadas de x e y, y son muy útiles a la hora de crear una base gráfica sin ningún contenido, para luego rellenar con nuestros datos. Esta forma de trabajo es muy extendida al trabajar con gráficos básicos en R, y para ello cuando llamamos a la función plot() debemos indicarle que el gráfico sea vacío, con el parámetro typ = \"n\".\nAntes de probar su funcionamiento, prestemos atención al origen de coordenadas del gráfico (i.e. (x,y)=(0,0)). Si nos fijamos bien, veremos que esa coordenada no coincide exactamente con el ángulo inferior izquierdo del gráfico. Esto es debido a que, por defecto, R utiliza una función interna para extender levemente los ejes (ahora que lo notamos, podemos ver que sucede también en los extremos de los ejes). Si no deseamos este comportamiento, podemos utilizar los parámetros xaxs e yaxs. Estos parámetros tienen dos configuraciones posibles: \"r\" o \"i\" (de “regular” e “interno”), veamos como funcionan:\n\nplot(0,0, xlim = c(0, 100), ylim = c(0, 50), typ = \"n\", xaxs = \"r\", yaxs = \"i\")\n\n\n\n\n\n\n\n\n\n\n\n\nAñadiendo otros elementos a nuestro gráfico\nEn el gráfico de dispersión, muchas veces es interesante mostrar el resultado de la correlación entre las variables de forma gráfica, es decir, la línea (o curva) resultante del ajuste de un modelo de regresión entre las variables. Teniendo en cuenta el mismo conjunto de datos con el que venimos trabajando, recordemos primero como podemos obtener la regresión lineal usando la función lm().\n\nlm(Sepal.Length ~ Petal.Length, data = iris)\n\n\nCall:\nlm(formula = Sepal.Length ~ Petal.Length, data = iris)\n\nCoefficients:\n (Intercept)  Petal.Length  \n      4.3066        0.4089  \n\n\nComo podemos ver, la función lm() ya nos devuelve el intercepto y la pendiente de la recta que queremos graficar. Con el uso de la función abline(), podemos añadirla al gráfico:\n\n# plot() -&gt; función de alto nivel, crea la base del gráfico\nwith(iris, plot(Petal.Length, Sepal.Length,\n                pch= 21, col=\"black\", bg=\"forestgreen\", cex=1,\n                xlim=c(0, 8),\n                ylim=c(0,8)))\n# abline() -&gt; función de bajo nivel, añade la recta al gráfico ya creado\nwith(iris, abline(lm(Sepal.Length ~ Petal.Length)))\n\n\n\n\n\n\n\n\n\n\nAsí como añadimos la recta resultante de la regresión, con abline() podemos añadir tantas líneas verticales y horizontales como necesitemos, esto es muy útil para separar sectores del gráfico, hacer lineas de divisiones menores de los ejes, etc. Además, podemos llamar a otra función de bajo nivel como es text(), para agregar sobre el gráfico los valores que componen la ecuación de la recta:\n\n# Primero guardemos los resultados de la regresión en un nuevo objeto\nreg_l &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)\n\n# Gráfico base\nwith(iris, plot(Petal.Length, Sepal.Length,\n                pch= 21, col=\"black\", bg=\"forestgreen\", cex=1,\n                xlim=c(0, 8),\n                ylim=c(0,8)))\n# Añadimos líneas\nabline(v = c(2, 4, 6), h = c(2, 4, 6), col = \"grey\", lwd = 0.5)\nabline(reg_l)\n# Añadiomos texto\ntext(3.5, 0, paste0(\"La ecuación es: y = \",\n                    round(reg_l$coefficients[2],2),\n                    \"x\", \" + \",\n                    round(reg_l$coefficients[1],2)),\n     cex=0.9, adj=0)\n\n\n\n\n\n\n\n\n\n\n\n\nPersonalizando parámetros según los datos\nEn muchas ocasiones, necesitamos que en nuestro gráfico los colores o los marcadores se correspondan con alguna variable, ya sea esta cuantitativa o cualitativa. Existen diferentes formas de abordar esta situación que dependerán en gran medida de la complejidad y el tamaño del conjunto de datos, así como de la diversidad de parámetros que debamos modificar.\nUna aproximación sencilla es generar en nuestro conjunto de datos una nueva variable que contenga los valores (numéricos o de texto) del parámetro gráfico que necesitemos modificar. Otra forma puede ser utilizar un vector con nombres, que relacione las variables de los datos con los valores de los parámetros gráficos.\n\n# Creando un nuevo data.frame para graficar incluyendo una columna con colores por especie\ntoplot &lt;- iris[,c(1,3,5)]\ntoplot$Spe.Color &lt;- ifelse(toplot$Species == \"setosa\", \"forestgreen\",\n                           ifelse(toplot$Species == \"versicolor\", \"dodgerblue\",\n                                  \"red\")\n                           )\ntoplot[sample(nrow(toplot), 10),]\n\n    Sepal.Length Petal.Length    Species   Spe.Color\n50           5.0          1.4     setosa forestgreen\n22           5.1          1.5     setosa forestgreen\n81           5.5          3.8 versicolor  dodgerblue\n63           6.0          4.0 versicolor  dodgerblue\n31           4.8          1.6     setosa forestgreen\n84           6.0          5.1 versicolor  dodgerblue\n36           5.0          1.2     setosa forestgreen\n26           5.0          1.6     setosa forestgreen\n104          6.3          5.6  virginica         red\n134          6.3          5.1  virginica         red\n\n\n\n# Creando una referencia para los marcadores, según la especie\npch_ref &lt;- c(\"setosa\" = 21,\n             \"versicolor\" = 22,\n             \"virginica\" = 23)\n# Creando una referencia para los colores, según la especie\ncol_ref &lt;- c(\"setosa\" = \"forestgreen\",\n             \"versicolor\" = \"dodgerblue\",\n             \"virginica\" = \"red\")\n# Llamando al gráfico\nwith(toplot, plot(Sepal.Length, Petal.Length,\n                  pch = pch_ref[as.character(Species)],\n                  col = \"black\", bg = Spe.Color, cex = 1.5,\n                  xlim = c(0, 8),\n                  ylim = c(0,8)\n                  )\n)\n# Usando un for para añadir lineas de ajuste por especie\nwith(toplot,\n     for (spe in unique(Species)) {\n       abline(lm(Petal.Length ~ Sepal.Length,\n                 data = subset(toplot, Species == spe)),\n              col = col_ref[as.character(spe)], lwd = 3, lty = 3)\n     }\n)\n\n\n\n\n\n\n\n\n\n\n\n\nEditando los ejes del gráfico\nEn algunas ocasiones, quisiéramos que el gráfico no presentará el recuadro que lo rodea. Esto podemos lograrlo removiendo los ejes con el parámetro axes = FALSE.\n\n# Llamando al gráfico\nwith(toplot, plot(Sepal.Length, Petal.Length,\n                pch = pch_ref[as.character(Species)],\n                col = \"black\", bg = Spe.Color, cex=1.5,\n                xlim = c(0, 8),\n                ylim = c(0,8),\n                axes=FALSE\n                )\n     )\n\n\n\n\n\n\n\n\n\n\nPor supuesto, ahora debemos añadir manualmente los ejes del gráfico. Para ello, usaremos otra función de bajo nivel llamada axis() (recuerde revisar la documentación para ver todas sus opciones) y, si así queremos, box() para dibujar una sección específica del recuadro que enmarca el gráfico.\n\n# Llamando al gráfico\nwith(toplot, plot(Sepal.Length, Petal.Length,\n                pch = pch_ref[as.character(Species)],\n                col = \"black\", bg = Spe.Color, cex=1.5,\n                xlim = c(0, 8),\n                ylim = c(0,8),\n                xaxs = \"i\", yaxs = \"i\",\n                axes = FALSE\n                )\n     )\naxis(side = 1, at = c(0,4:8))\naxis(side = 2, at = c(seq(0,8,2)), las = 1, labels = c(\"cero\", \"dos\", 4, \"seis\", 8))\nbox(bty = \"l\")",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#gráficos-de-caja",
    "href": "dia4/6.1_graficos_base.html#gráficos-de-caja",
    "title": "Gráficos con R base",
    "section": "Gráficos de caja",
    "text": "Gráficos de caja\n\nLeyendas y anotaciones\nA continuación, cambiaremos el conjunto de datos por ToohGrowth, proveniente de un experimento de crecimiento dental en cobayos, según la dosis de dos suplementos dietarios. Este tipo de experimentos es perfecto para poner en práctica la función boxplot(), para crear gráficos de caja. Como en este punto ya conocemos la lógica de construcción de gráficos, pasemos directamente al código:\n\n# Llamado del primer conjunto de cajas (tratamiento = \"VC\")\nwith(subset(ToothGrowth, supp == \"VC\"),\n     boxplot(len ~ dose, axes = FALSE, ylim = c(0, 35),\n             boxwex = 0.15, at = 1:3 - 0.1, \n             col = \"yellow\", main = \"Crecimiento dental\",\n             xlab = \"Dosis de Vitamina C (mg/día)\", ylab = \"Largo del odontoblasto (µm)\",\n             )\n     )\n# Llamado del segundo conjunto de cajas (tratamiento = \"OJ\")\n# Notar el uso de \"add = TRUE\" y \"ann = FALSE\"\nwith(subset(ToothGrowth, supp == \"OJ\"),\n     boxplot(len ~ dose,  axes = FALSE, add = TRUE, ann = FALSE,\n             boxwex = 0.15, at = 1:3 + 0.1,\n             col = \"orange\"\n             )\n     )\n# Creando los ejes y recuadro\naxis(side = 1, at = c(1:3), labels = c(\"0.5\", \"1\", \"2\"))\naxis(side = 2, at = seq(0,35,5))\nbox(bty = \"l\", lwd = 2)\n# Graficando la flecha para señalar el outlier\nwith(subset(ToothGrowth, supp == \"VC\" & dose == 1),\n     arrows(x0 = 1.5, x1 = 1.8,\n            y0 = max(len), y1 = max(len),\n            lwd = 2, col = \"red\"\n  )\n)\n# Anadiendo la leyenda\nlegend(\"bottom\", horiz = TRUE, bty = \"n\",\n       legend = c(\"Ácido ascórbico\", \"Jugo de naranja\"),\n       fill = c(\"yellow\", \"orange\"))",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-3",
    "href": "dia4/6.1_graficos_base.html#ejercicio-3",
    "title": "Gráficos con R base",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\n\nAnalice el código precedente sin ejecutarlo, intentando describir que hace cada línea. Luego, copie el mismo a un script dentro de dia4 y ejecútelo por partes para entender el funcionamiento. Recuerde buscar en las ayudas interna de R y juegue con las opciones disponibles.\nRepita el gráfico pero con una flecha azul que indique el valor de la mediana para la 0,5 mm/día del suplemento jugo de naranja. Además, ubique la leyenda en la posición (x,y) = (2.5,5).",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#panel-de-múltiples-gráficos",
    "href": "dia4/6.1_graficos_base.html#panel-de-múltiples-gráficos",
    "title": "Gráficos con R base",
    "section": "Panel de múltiples gráficos",
    "text": "Panel de múltiples gráficos\nEn muchas ocasiones, necesitamos mostrar en un solo panel varios gráficos diferentes. Para ello, debemos utilizar la función par(), que permite configurar todos los parámetros básicos del dispositivo gráfico que usa R. Esta función tiene un nivel jerárquico superior a todas las que vimos previamente, ya que con la misma podemos cambiar el comportamiento por defecto de todos los parámetros gráficos de forma semi-permanente (i.e. en el contexto de RStudio, durante toda la sesión en curso; y para dispositivos gráficos externos, hasta que se reinicie el mismo). Por esto, si realizamos un cambio con par() para mostrar dos gráficos en paralelo y, posteriormente, queremos realizar un nuevo gráfico solitario, debemos volver a configurar el dispositivo gráfico para mostrar un solo gráfico.\nA pesar de la gran cantidad de usos que posee la función par(), dentro de los mas comunes están la configuración de márgenes interiores (mar/mai) y exteriores (oma y omi), así como la configuración del emplazamiento de múltiples gráficos (mfrow).\nPara ver esto último en acción, pensemos que queremos realizar una regresión lineal y evaluar si los supuestos de la misma se cumplen. Para ellos, hagamos primero un modelo de regresión lineal entre las variables Petal.Length y Sepal.Length, para la especie I. virginica del conjunto de datos iris:\n\n# Creando y viendo el resultado del modelo de regresión lineal\nregL &lt;- lm(Petal.Length ~ Sepal.Length, data = subset(iris[iris$Species == \"virginica\",]))\nsummary(regL)\n\n\nCall:\nlm(formula = Petal.Length ~ Sepal.Length, data = subset(iris[iris$Species == \n    \"virginica\", ]))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.68603 -0.21104  0.06399  0.18901  0.66402 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   0.61047    0.41711   1.464     0.15    \nSepal.Length  0.75008    0.06303  11.901  6.3e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2805 on 48 degrees of freedom\nMultiple R-squared:  0.7469,    Adjusted R-squared:  0.7416 \nF-statistic: 141.6 on 1 and 48 DF,  p-value: 6.298e-16\n\n\nHabiendo generado el objeto que contiene el resultado de lm(), podemos pedirle a R que lo grafique con plot(). Este es un ejemplo más de la característica de polimorfismo que vimos en la clase introductoria, ya que plot() puede usarse sobre diferentes tipos de objetos, resultantes de diferentes funciones, y realizará diferentes gráficos según cada uno.\nComo en nuestro ejemplo la función plot()realizará 4 gráficos separados, configuraremos con par() la posibilidad de tener un panel de 4 gráficos, con 2 filas y 2 columnas, esto es: mfrow = c(2,2).\n\n# Gráficos de diagnóstico del modelo de regresión lineal\npar(mfrow = c(2,2))\nplot(regL)\n\n\n\n\n\n\n\n\nSi bien el análisis y explicación de cada uno de estos gráficos excede este curso, puede encontrar en este vínculo una buena explicación con ejemplos. Además, puede inscribirse en la próxima edición del excelente curso dictado por Santiago Benitez-Vieyra: Introducción al lenguaje R. Modelos lineales y fundamentos de programación.\nPara jugar un poco más, repitamos los gráficos pero ahora, pidiendo que los mismos estén emplazados en una sola fila de 4 columnas:\n\n# Gráficos de diagnóstico del modelo de regresión lineal\npar(mfrow = c(1,4))\nplot(regL)",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-final",
    "href": "dia4/6.1_graficos_base.html#ejercicio-final",
    "title": "Gráficos con R base",
    "section": "Ejercicio final",
    "text": "Ejercicio final\nCon el conjuntos de datos provisto, y ayudándose con la documentación de las funciones points(), segments() y title(), y buscando como funcionan los parámetros gráficos para líneas lwd y lty, realice un gráfico como el que se muestra a continuación.\n\ndata &lt;- data.frame(tipo = c(\"linea solida\",\"linea guiones\",\"linea punteada\", rep(\"punto\",4)),\n                   lposy = c(1,3,5, rep(NA,4)),\n                   lposx0 = c(rep(1,3), rep(NA, 4)),\n                   lposx1 = c(rep(4,3), rep(NA, 4)),\n                   pposx = c(rep(NA,3), 6,6,8,8),\n                   pposy = c(rep(NA,3), 2,4,2,4))\ndata \n\n            tipo lposy lposx0 lposx1 pposx pposy\n1   linea solida     1      1      4    NA    NA\n2  linea guiones     3      1      4    NA    NA\n3 linea punteada     5      1      4    NA    NA\n4          punto    NA     NA     NA     6     2\n5          punto    NA     NA     NA     6     4\n6          punto    NA     NA     NA     8     2\n7          punto    NA     NA     NA     8     4",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con R base"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fundamentos básicos del lenguaje R",
    "section": "",
    "text": "Curso de posgrado | Doctorado en Cs. Biológicas | FCEFyN - UNC\n\n  Edición 2024\n\n\n¡Bienvenid@s al curso!\nBienvenid@s al curso de Fundamentos básicos del lenguaje R, dictado por el Dr. Pablo Yair Huais y el Biól. Nicolás Pastor. El curso fue diseñado para proveer a l@s estudiantes con las herramientas necesarias para iniciarse en el uso del lenguaje R, mediante el aprendizaje de su lógica programática, y orientado a resolver problemas específicos de sus temas de investigación.\nA la izquierda de la pantalla se encuentran disponibles todos los recursos prácticos y teóricos que utilizaremos durante el desarrollo del curso.\n\n\nObjetivos específicos\n\nQue l@s estudiantes adquieran conceptos teóricos fundamentales y habilidades prácticas básicas del lenguaje R.\nQue l@s estudiantes desarrollen un pensamiento programático en relación al uso del lenguaje R.\nQue l@s estudiantes sean capaces de trasladar las herramientas aprendidas para la resolución de problemas metodológicos específicos de sus investigaciones.\n\n\n\nCronograma\n\n \n\n\n\nOtros cursos de interés\nEn el Doctorado de Ciencias Biológicas (FCEFyN, Universidad Nacional de Córdoba), se dictan con regularidad cursos introductorios y avanzados de modelos estadísticos en R:\n\nIntroducción al lenguaje R. Modelos lineales y fundamentos de programación Dictado por el Dr. Santiago Benitez-Vieyra. Ver curso\nModelos Estadísticos Avanzados Dictado por el Dr. Santiago Benitez-Vieyra. Ver curso\nGráficos para publicaciones en R con énfasis en ggplot2 Dictado por el Dr. Andrés Blanco. Ver curso\n\n\n\nLicencia\n© 2024-2025 Pablo Y. Huais & Nicolás Pastor. Bajo licencia Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n \n\n\n\n\n Volver arriba",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "dia3/5.1_control_flujo.html",
    "href": "dia3/5.1_control_flujo.html",
    "title": "Estructuras de control de flujo",
    "section": "",
    "text": "Como hemos visto hasta ahora, cuando escribimos código y lo ejecutamos el mismo será interpretando línea a línea, hasta que se ejecuta la última línea y el programa termina. Las estructuras de control de flujo permiten alterar este comportamiento para adecuarlo a nuestras necesidades.\nEn general podemos definir dos grandes tipos de estructuras para el control de flujo. Por un lado, aquellas estructuras que evaluan condiciones y ejecutan un código subsiguiente en función de si el resultado de esa evaluación es verdadero o falso, a estas estrucuturas las llamamos condicionales. Por otro lado, tenemos estructuras que repiten iterativamente una porción de código mientras se cumpla alguna condición dada, a estas estructuras las denominamos bucles.\nNota: Antes de continuar es recomendable repasar los operadores aprendidos en el primer día de clases.\n\n\n\nEl constructo if ... else es una estructura de tipo condicional. En pocas palabras, if evaluará una condición dada y si la misma se cumple (i.e. el resultado es TRUE), se ejecutará el código correspondiente. Para definir un bloque de código a ejecutarse si no se cumple la condición previamente establecida, utilizaremos else. Si además quisiéramos definir múltiples condiciones, en caso de que la primera no se cumpla y que deriven en diferentes ejecuciones, deberemos utilizar else if.\n\nif (TRUE) {\n  print(\"Se ejecutará el código bajo 'if' ya que la condición resulta TRUE\")\n}\n\n[1] \"Se ejecutará el código bajo 'if' ya que la condición resulta TRUE\"\n\n\n\n# Invertimos el TRUE usando el operador ! para obtener FALSE\nif (!TRUE) {\n  print(\"Se ejecutará el código bajo 'if' ya que la condición resulta TRUE\")\n} else {\n  print(\"Se ejecutará el código bajo 'else' dado que la condición resulta FALSE\")\n}\n\n[1] \"Se ejecutará el código bajo 'else' dado que la condición resulta FALSE\"\n\n\n\n\nEn ocasiones necesitamos establecer múltiples condiciones. Ejecute el codigo siguiente varias veces, pero cambiando cada vez el valor de a.\n\na &lt;- 25\n\nif (a &gt;= 40) {\n  print(\"a es mayor o igual que 40\")\n} else if (a &gt;= 30) {\n  print(\"a es mayor o igual que 30\")\n} else if (a &gt;= 10) {\n  print(\"a es mayor o igual que 10\")\n} else {\n  print(\"a es menor a 10\")\n}\n\n[1] \"a es mayor o igual que 10\"\n\n\nPara pensar: ¿Qué pasa cuando, por ejemplo, a = 35? ¿Cuántas evaluaciones independientes serían TRUE? ¿Qué porción de código se ejecuta y por qué?\n\n\n\nEs posible agrupar diferentes evaluaciones utilizando los operadores Y (&) y O (|). Ejecute el siguiente código varias veces cambiando los valores de a, b y c.\n\na &lt;- 35\nb &lt;- 12\nc &lt;- 65\n\nif (a &lt; 40 & b &gt; 10 | c &gt; 50) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condición\")\n}\n\n[1] \"'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50\"\n\n\n\n\n\n\nCompare el código de la celda precedente con el de aquí abajo. ¿Qué diferencias nota? Ejecútelo y explique el resultado con el obtenido usando el código previo con los mismos valores para a, b y c.\n\na &lt;- 52\nb &lt;- 8\nc &lt;- 65\n\nif (a &lt; 40 & (b &gt; 10 | c &gt; 50)) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condición\")\n}\n\n\n\nRecién vimos como combinar varias evaluaciones en una misma expresión, pero frecuentemente lo que necesitaremos es realizar diferentes evaluaciones de forma secuencial y ejecutar código consecuentemente a los resultados obtenidos. Para ello podemos incoporar evaluaciones dentro de una evaluación previa, es decir, anidar las evaluaciones.\n\na &lt;- 25\n\nif (a &gt; 10) {\n  print(\"'a' es mayor que 10\")\n  if (a &gt; 20) {\n    print(\"y también es mayor que 20\")\n    if (a &gt; 30) {\n      print(\"y también es mayor que 30\")\n    } else {\n      print(\"pero no mayor que 30\")\n    }\n  }\n}\n\n[1] \"'a' es mayor que 10\"\n[1] \"y también es mayor que 20\"\n[1] \"pero no mayor que 30\"\n\n\nPara pensar: ¿Qué sucede si a &lt;= 10? ¿Qué podemos aprender de esta situación? ¿Cómo podríamos salvar el inconveniente?\n\n\n\n\n\n\n\nAndrea y Ariel fueron a hacer compras, construya con código que indique quién gastó más dinero y de cuanto es la diferencia. El mismo código debe servir para evaluar los tres escenarios siguientes:\n\nEscenario Nº 1: compra_andrea = 690 / compra_ariel = 730\nEscenario Nº 2: compra_andrea = 745 / compra_ariel = 745\nEscenario Nº 3: compra_andrea = 890 / compra_ariel = 730\n\nAyudita: La salida esperada combina texto y variables, por ejemplo “Ariel gasto x pesos más que Andrea”. Para generar una salida de este tipo, podemos utilizar la función paste() de la siguiente manera:\n\nvariable &lt;- 25\nprint(paste(\"La variable vale\", variable))\n\n[1] \"La variable vale 25\"\n\n\nSi no usáramos paste() obtendríamos un error:\n\nprint(\"La variable vale\", variable)\n\nError in print.default(\"La variable vale\", variable): invalid printing digits 25\n\n\n\n\n\n\nEl constructo while es una estructura de tipo bucle. En pocas palabras, evaluará una condición y ejecutará repetitivamente una porción de código siempre y cuando la misma se cumpla (i.e. el resultado sea TRUE).\n\ni &lt;- 1\nwhile (i &lt; 4) {\n  print(paste(\"Repetición nº:\", i))\n  i &lt;- i + 1\n}\n\n[1] \"Repetición nº: 1\"\n[1] \"Repetición nº: 2\"\n[1] \"Repetición nº: 3\"\n\n\nAtención!!! Si en el bucle precedente omitimos incrementar el contador i, nuestro bucle se ejecutará indefinidamente.\n\n\n\n\n\nTeniendo en cuenta lo que aprendimos sobre el acceso a elementos de un vector, podemos utilizar un bucle while para acceder a los mismos. No obstante, existen formas más eficientes de hacer esto y lo veremos posteriormente.\n\ncarreras &lt;- c('Biología', 'Bioquímica', 'Medicina', 'Nutrición')\ni &lt;- 1\nwhile (i &lt;= length(carreras)) {\n  print(carreras[i])\n  i &lt;- i + 1\n}\n\n[1] \"Biología\"\n[1] \"Bioquímica\"\n[1] \"Medicina\"\n[1] \"Nutrición\"\n\n\n\n\n\nSi fuera necesario, podemos utilizar la declaración break para interrumpir la ejecución de un bucle, dada una condición establecida.\n\ni &lt;- 1\nwhile (i &lt; 12) {\n  print(paste(\"Repetición nº:\", i))\n  if (i == 5) {\n    break\n  }\n  i &lt;- i + 1\n}\n\n[1] \"Repetición nº: 1\"\n[1] \"Repetición nº: 2\"\n[1] \"Repetición nº: 3\"\n[1] \"Repetición nº: 4\"\n[1] \"Repetición nº: 5\"\n\n\n\n\n\nDe forma similar podemos, dada una condición, saltearnos ciertas ejecuciones dentro de un bucle. Para ello, utilizaremos la declaración next.\n\ni &lt;- 0\nwhile (i &lt; 9) {\n  i &lt;- i + 1\n  if (i &gt; 2 & i &lt; 7) {\n    next\n  }\n  else {\n    print(paste(\"Repetición nº:\", i))\n  }\n}\n\n[1] \"Repetición nº: 1\"\n[1] \"Repetición nº: 2\"\n[1] \"Repetición nº: 7\"\n[1] \"Repetición nº: 8\"\n[1] \"Repetición nº: 9\"\n\n\n\n\n\n\nAnalice el siguiente código SIN EJECUTARLO e interprete cuál es la salida esperada explicando que sucede en cada iteración. Luego escriba a mano la salida exacta que dará este código.\n\ncompras &lt;- c(\"pan\", \"queso\", \"jamón\", \"tomate\", \"lechuga\")\n\ni &lt;- 1\nwhile (i &lt;= length(compras)) {\n  if (i == 1) {\n    print(paste(\"En mis lista de compras hay\", compras[i]))\n  }\n  else if (i == 2) {\n    print(paste(\"y también hay\", compras[i]))\n  }\n  else {\n    print(paste(\"y\", compras[i]))\n  }\n  i &lt;- i + 1\n}\n\n\n\n\n\nEl constructo for es otra estructura de tipo bucle que permite iterar sobre una colección dada de elementos. En pocas palabras, repetirá la ejecución de un mismo bloque de código tantas veces como elementos existan en dicha secuencia. Por ello, es importante recordar que su sintaxis básica es:\nfor (item in colección) {código a ejecutar}\n\nasistentes &lt;- c(\"Maria Guadalupe\", \"Clarisa\", \"Pablo Alejandro\", \"Andrea\", \"Raúl Andres\", \"Evangelina\",\n                \"Juan Manuel\", \"María Azul\", \"Gala\", \"Lucille\", \"Lucas\", \"Ludmila\", \"Adolfo Emiliano\",\n                \"Ana\", \"Julieta Lourdes\", \"Joaquín\", \"Agostina\", \"Victoria Lucia\")\nfor (nombre in asistentes) {\n  print(nombre)\n}\n\n[1] \"Maria Guadalupe\"\n[1] \"Clarisa\"\n[1] \"Pablo Alejandro\"\n[1] \"Andrea\"\n[1] \"Raúl Andres\"\n[1] \"Evangelina\"\n[1] \"Juan Manuel\"\n[1] \"María Azul\"\n[1] \"Gala\"\n[1] \"Lucille\"\n[1] \"Lucas\"\n[1] \"Ludmila\"\n[1] \"Adolfo Emiliano\"\n[1] \"Ana\"\n[1] \"Julieta Lourdes\"\n[1] \"Joaquín\"\n[1] \"Agostina\"\n[1] \"Victoria Lucia\"\n\n\nPara reflexionar: Compare el código de la celda precedente con el que usamos para listar las carreras usando un bucle while. ¿Que diferencias nota? ¿Cuando usaría uno u otro constructo?\n\n\nEl bucle for es ampliamente utilizado para trabajar sobre filas y columnas de un data.frame. Por ejemplo, podemos tomar la tabla iris (cargada por defecto en R) y generar una nueva columna llamada Rel.SepPet.L:\n\niris$Rel.SepPet.L &lt;- NA\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa           NA\n2          4.9         3.0          1.4         0.2  setosa           NA\n3          4.7         3.2          1.3         0.2  setosa           NA\n4          4.6         3.1          1.5         0.2  setosa           NA\n5          5.0         3.6          1.4         0.2  setosa           NA\n6          5.4         3.9          1.7         0.4  setosa           NA\n\n\nGracias a un bucle for, es posible trabajar sobre cada fila para rellenar la nueva columna creada con los valores resultantes de la relación (el ratio) entre el largo de los sépalos y pétalos:\n\nfor (i in 1:nrow(iris)) {\n  iris$Rel.SepPet.L[i] &lt;- iris$Sepal.Length[i] / iris$Petal.Length[i]\n}\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa     3.642857\n2          4.9         3.0          1.4         0.2  setosa     3.500000\n3          4.7         3.2          1.3         0.2  setosa     3.615385\n4          4.6         3.1          1.5         0.2  setosa     3.066667\n5          5.0         3.6          1.4         0.2  setosa     3.571429\n6          5.4         3.9          1.7         0.4  setosa     3.176471\n\n\nQueda claro que, como hemos visto anteriormente en el práctico de tablas, esta no es la forma más eficiente de generar la nueva columna (¿cuál sería la forma más eficiente?). No obstante, este ejemplo sirve para entender como funciona un bucle for con un data.frame.\n\n\n\nCuando trabajamos con bucles, es muy frecuente establecer un rango para definir la iteración. Allí entra en juego esta útil función que, como vimos en la clase de Vectores devuelve una secuencia numérica y cuya sintaxis es: seq(inicio,fin,paso), recordando que por defecto (es decir, si no explicitamos el valor del argumento), el inicio es “1” y el paso “1”.\n\n# Secuencia de 1 a 3\nfor (n in seq(3)){\n  print(n)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n# Secuencia de 2 a 8, cada 2\nfor (n in seq(2,8,2)){\n  print(n)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n\n\n\n\n\nAl igual que vimos con while, podemos controlar el comportamiento de un bucle for de acuerdo a diferentes condiciones.\n\nfruta &lt;- c(\"banana\", \"manzana\", \"pera\")\n\nfor (f in fruta){\n  print(paste(\"Cortamos el bucle en su primer iteración, con la fruta\", f))\n  if (f == \"banana\"){\n    break\n  }\n}\n\n[1] \"Cortamos el bucle en su primer iteración, con la fruta banana\"\n\n\n\nfor (i in seq(1, 10)) {\n  if (i %% 2 != 0) {\n    next\n  } else {\n    print(paste(\"Me salteo todos los impares:\", i))\n  }\n}\n\n[1] \"Me salteo todos los impares: 2\"\n[1] \"Me salteo todos los impares: 4\"\n[1] \"Me salteo todos los impares: 6\"\n[1] \"Me salteo todos los impares: 8\"\n[1] \"Me salteo todos los impares: 10\"\n\n\n\n\n\nEn muchas ocasiones, nos encontraremos con la necesidad de operar iterativamente sobre más de un conjunto de elementos, en esos casos podemos anidar los bucles.\n\nletras &lt;- c(\"a\", \"b\", \"c\")\nnumeros &lt;- c(1, 2, 3)\n\nfor (i in letras) {\n  for (j in numeros) {\n    print(paste(i, j))\n  }\n}\n\n[1] \"a 1\"\n[1] \"a 2\"\n[1] \"a 3\"\n[1] \"b 1\"\n[1] \"b 2\"\n[1] \"b 3\"\n[1] \"c 1\"\n[1] \"c 2\"\n[1] \"c 3\"\n\n\n\n\n\n\nall_num &lt;- c(17, 6, -12, 38, -88, 147, 1, -140, -19, 24, 74, -36)\n\nEscriba un código que separe los números positivos y los negativos del vector proporcionado en diferentes vectores. Imprima dichos vectores identificando su condición (positivo o negativo) y ordenados de menor a mayor.\nAyuda: ejecute el siguiente código previamente y vea que aprende con ello.\n\nej1 &lt;- c(3,1,2)\nprint(paste(\"Ordenados ej1:\", sort(ej1)))\nprint(ej1)\n\nej2 &lt;- c(4,8,6)\ncat(\"Ordenados ej2:\", sort(ej2))\n\n\n\n\nEl uso de for anidados es muy útil para trabajar con matrices:\n\nmat &lt;- matrix(sample(1:100, size = 9), ncol = 3)\nmat\n\n     [,1] [,2] [,3]\n[1,]   90   49    2\n[2,]   15   59   99\n[3,]   44   26   11\n\nfor (i in 1:nrow(mat)) {\n  for( j in 1:ncol(mat)) {\n    print(paste(\"El elemento de la fila\", i, \"y columna\", j, \"es igual a\", mat[i, j]))\n  }\n}\n\n[1] \"El elemento de la fila 1 y columna 1 es igual a 90\"\n[1] \"El elemento de la fila 1 y columna 2 es igual a 49\"\n[1] \"El elemento de la fila 1 y columna 3 es igual a 2\"\n[1] \"El elemento de la fila 2 y columna 1 es igual a 15\"\n[1] \"El elemento de la fila 2 y columna 2 es igual a 59\"\n[1] \"El elemento de la fila 2 y columna 3 es igual a 99\"\n[1] \"El elemento de la fila 3 y columna 1 es igual a 44\"\n[1] \"El elemento de la fila 3 y columna 2 es igual a 26\"\n[1] \"El elemento de la fila 3 y columna 3 es igual a 11\"\n\n\n¿Cómo funciona este código? La mejor forma de entender un bucle individual, o bucles anidados, es evaluar el primer caso de la serie de repeticiones que el bucle está efectuando y evaluar el código para el caso. Aquí, el primer caso sería cuando i = 1 y j = 1.\n\n\n\n\n\nProgramar desde cero puede ser muy frustrante! Esto es, obviamente, la situación más común si nuestra experiencia en lenguajes de programación es nula. A continuación, presentamos algunos consejos que pueden ayudarnos a programar nuestras primeras rutinas:\n\nPaso a paso. No trates de programar la tarea propuesta entera de una sola vez, mejor descomponer la tarea en tareas más pequeñas concatenadas entre sí.\nPseudocódigo. Es útil pensar, o incluso escribir, los pasos a seguir mediante pseudocódigo. Es decir, representar con oraciones simples cada tarea a realizar.\nEmpezar por el final. Muchas veces es útil pensar cuál es el resultado final que necesitamos y, luego, pensar desde allí, de atrás hacia adelante, que tareas debemos realizar para lograr ese resultado.\nEjemplo de juguete. Ante una tarea compleja, lo mejor es intentar generar la rutina deseada con un ejemplo de juguete o una pequeña porción de lo que nos proponemos hacer. Luego, si salió todo bien, extender la solución al problema en su totalidad.\nPrimero lo primero. Al programar un ciclo (for o while), puede ser difícil desarrollar de un tirón todo el código. Lo más indicado es programar las operaciones a realizar sobre el primer caso y, luego de haber obtenido el resultado exitosamente, generalizar el código para todos los casos.\nPensar en modo tabla. Si lo que quiero es obtener resultados en forma de tabla, una buena estrategia es generar la tabla con la o las columnas vacías. Luego, utilizamos un ciclo for para ir rellenando cada fila de las columnas creadas. Si lo pensamos así, nuestros ciclos for tendrán la siguiente forma general: for (i in 1:nrow(mi_tabla)) {mi código a ejecutar}.\nEl error como parte del proceso. Es normal que aparezcan errores todo el tiempo, pero es clave aprender a leer y comprender los mensajes de error. Estos mensajes suelen indicar exactamente qué está fallando y dónde.\n\n\n\n\n\nTomando de base el conjunto de datos iris, construya el siguiente data.frame:\n\nmodel_outputs &lt;- data.frame(Species = unique(iris$Species),\n                            Estimate = NA,\n                            P.value = NA)\nmodel_outputs\n\n     Species Estimate P.value\n1     setosa       NA      NA\n2 versicolor       NA      NA\n3  virginica       NA      NA\n\n\nLuego, evalúe modelos lineales que relacionen a la variable Petal.Length con la variable Sepal.Length en ese orden, para cada especie. Rellene la tabla generada anteriormente con los valores de los coeficientes (llamado Estimate o coeficiente de la variable predictora) y su valor-P (P.value) en cada caso. Para hacer esto, utilice alguna estructura de control de flujo aprendida!\nAyuda: utilice la función lm() para construir los modelos lineales. La salida de la función summary(), que actúa sobre el modelo (salida de lm()), contiene la información sobre los coeficientes que necesitamos.\n\n\n \n\n\n\n\n\nCuando vimos los condicionales, armamos un código para evaluar en 3 escenarios diferentes los gastos que realizaron Andrea y Ariel. Ahora que sabe usar bucles, escriba un código que evalué en una sola ejecución todos los escenarios planteados en ese ejercicio y que utilice todos los constructos aprendidos, es decir: if, while y for.\nAyuda: recuerde que los bucles while pueden ejecutarse indefinidamente si no imponemos condiciones para que finalicen.",
    "crumbs": [
      "Inicio",
      "Unidad 3",
      "Estructuras de control de flujo"
    ]
  },
  {
    "objectID": "dia3/5.1_control_flujo.html#condicionales-y-bucles",
    "href": "dia3/5.1_control_flujo.html#condicionales-y-bucles",
    "title": "Estructuras de control de flujo",
    "section": "",
    "text": "Como hemos visto hasta ahora, cuando escribimos código y lo ejecutamos el mismo será interpretando línea a línea, hasta que se ejecuta la última línea y el programa termina. Las estructuras de control de flujo permiten alterar este comportamiento para adecuarlo a nuestras necesidades.\nEn general podemos definir dos grandes tipos de estructuras para el control de flujo. Por un lado, aquellas estructuras que evaluan condiciones y ejecutan un código subsiguiente en función de si el resultado de esa evaluación es verdadero o falso, a estas estrucuturas las llamamos condicionales. Por otro lado, tenemos estructuras que repiten iterativamente una porción de código mientras se cumpla alguna condición dada, a estas estructuras las denominamos bucles.\nNota: Antes de continuar es recomendable repasar los operadores aprendidos en el primer día de clases.\n\n\n\nEl constructo if ... else es una estructura de tipo condicional. En pocas palabras, if evaluará una condición dada y si la misma se cumple (i.e. el resultado es TRUE), se ejecutará el código correspondiente. Para definir un bloque de código a ejecutarse si no se cumple la condición previamente establecida, utilizaremos else. Si además quisiéramos definir múltiples condiciones, en caso de que la primera no se cumpla y que deriven en diferentes ejecuciones, deberemos utilizar else if.\n\nif (TRUE) {\n  print(\"Se ejecutará el código bajo 'if' ya que la condición resulta TRUE\")\n}\n\n[1] \"Se ejecutará el código bajo 'if' ya que la condición resulta TRUE\"\n\n\n\n# Invertimos el TRUE usando el operador ! para obtener FALSE\nif (!TRUE) {\n  print(\"Se ejecutará el código bajo 'if' ya que la condición resulta TRUE\")\n} else {\n  print(\"Se ejecutará el código bajo 'else' dado que la condición resulta FALSE\")\n}\n\n[1] \"Se ejecutará el código bajo 'else' dado que la condición resulta FALSE\"\n\n\n\n\nEn ocasiones necesitamos establecer múltiples condiciones. Ejecute el codigo siguiente varias veces, pero cambiando cada vez el valor de a.\n\na &lt;- 25\n\nif (a &gt;= 40) {\n  print(\"a es mayor o igual que 40\")\n} else if (a &gt;= 30) {\n  print(\"a es mayor o igual que 30\")\n} else if (a &gt;= 10) {\n  print(\"a es mayor o igual que 10\")\n} else {\n  print(\"a es menor a 10\")\n}\n\n[1] \"a es mayor o igual que 10\"\n\n\nPara pensar: ¿Qué pasa cuando, por ejemplo, a = 35? ¿Cuántas evaluaciones independientes serían TRUE? ¿Qué porción de código se ejecuta y por qué?\n\n\n\nEs posible agrupar diferentes evaluaciones utilizando los operadores Y (&) y O (|). Ejecute el siguiente código varias veces cambiando los valores de a, b y c.\n\na &lt;- 35\nb &lt;- 12\nc &lt;- 65\n\nif (a &lt; 40 & b &gt; 10 | c &gt; 50) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condición\")\n}\n\n[1] \"'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50\"\n\n\n\n\n\n\nCompare el código de la celda precedente con el de aquí abajo. ¿Qué diferencias nota? Ejecútelo y explique el resultado con el obtenido usando el código previo con los mismos valores para a, b y c.\n\na &lt;- 52\nb &lt;- 8\nc &lt;- 65\n\nif (a &lt; 40 & (b &gt; 10 | c &gt; 50)) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condición\")\n}\n\n\n\nRecién vimos como combinar varias evaluaciones en una misma expresión, pero frecuentemente lo que necesitaremos es realizar diferentes evaluaciones de forma secuencial y ejecutar código consecuentemente a los resultados obtenidos. Para ello podemos incoporar evaluaciones dentro de una evaluación previa, es decir, anidar las evaluaciones.\n\na &lt;- 25\n\nif (a &gt; 10) {\n  print(\"'a' es mayor que 10\")\n  if (a &gt; 20) {\n    print(\"y también es mayor que 20\")\n    if (a &gt; 30) {\n      print(\"y también es mayor que 30\")\n    } else {\n      print(\"pero no mayor que 30\")\n    }\n  }\n}\n\n[1] \"'a' es mayor que 10\"\n[1] \"y también es mayor que 20\"\n[1] \"pero no mayor que 30\"\n\n\nPara pensar: ¿Qué sucede si a &lt;= 10? ¿Qué podemos aprender de esta situación? ¿Cómo podríamos salvar el inconveniente?\n\n\n\n\n\n\n\nAndrea y Ariel fueron a hacer compras, construya con código que indique quién gastó más dinero y de cuanto es la diferencia. El mismo código debe servir para evaluar los tres escenarios siguientes:\n\nEscenario Nº 1: compra_andrea = 690 / compra_ariel = 730\nEscenario Nº 2: compra_andrea = 745 / compra_ariel = 745\nEscenario Nº 3: compra_andrea = 890 / compra_ariel = 730\n\nAyudita: La salida esperada combina texto y variables, por ejemplo “Ariel gasto x pesos más que Andrea”. Para generar una salida de este tipo, podemos utilizar la función paste() de la siguiente manera:\n\nvariable &lt;- 25\nprint(paste(\"La variable vale\", variable))\n\n[1] \"La variable vale 25\"\n\n\nSi no usáramos paste() obtendríamos un error:\n\nprint(\"La variable vale\", variable)\n\nError in print.default(\"La variable vale\", variable): invalid printing digits 25\n\n\n\n\n\n\nEl constructo while es una estructura de tipo bucle. En pocas palabras, evaluará una condición y ejecutará repetitivamente una porción de código siempre y cuando la misma se cumpla (i.e. el resultado sea TRUE).\n\ni &lt;- 1\nwhile (i &lt; 4) {\n  print(paste(\"Repetición nº:\", i))\n  i &lt;- i + 1\n}\n\n[1] \"Repetición nº: 1\"\n[1] \"Repetición nº: 2\"\n[1] \"Repetición nº: 3\"\n\n\nAtención!!! Si en el bucle precedente omitimos incrementar el contador i, nuestro bucle se ejecutará indefinidamente.\n\n\n\n\n\nTeniendo en cuenta lo que aprendimos sobre el acceso a elementos de un vector, podemos utilizar un bucle while para acceder a los mismos. No obstante, existen formas más eficientes de hacer esto y lo veremos posteriormente.\n\ncarreras &lt;- c('Biología', 'Bioquímica', 'Medicina', 'Nutrición')\ni &lt;- 1\nwhile (i &lt;= length(carreras)) {\n  print(carreras[i])\n  i &lt;- i + 1\n}\n\n[1] \"Biología\"\n[1] \"Bioquímica\"\n[1] \"Medicina\"\n[1] \"Nutrición\"\n\n\n\n\n\nSi fuera necesario, podemos utilizar la declaración break para interrumpir la ejecución de un bucle, dada una condición establecida.\n\ni &lt;- 1\nwhile (i &lt; 12) {\n  print(paste(\"Repetición nº:\", i))\n  if (i == 5) {\n    break\n  }\n  i &lt;- i + 1\n}\n\n[1] \"Repetición nº: 1\"\n[1] \"Repetición nº: 2\"\n[1] \"Repetición nº: 3\"\n[1] \"Repetición nº: 4\"\n[1] \"Repetición nº: 5\"\n\n\n\n\n\nDe forma similar podemos, dada una condición, saltearnos ciertas ejecuciones dentro de un bucle. Para ello, utilizaremos la declaración next.\n\ni &lt;- 0\nwhile (i &lt; 9) {\n  i &lt;- i + 1\n  if (i &gt; 2 & i &lt; 7) {\n    next\n  }\n  else {\n    print(paste(\"Repetición nº:\", i))\n  }\n}\n\n[1] \"Repetición nº: 1\"\n[1] \"Repetición nº: 2\"\n[1] \"Repetición nº: 7\"\n[1] \"Repetición nº: 8\"\n[1] \"Repetición nº: 9\"\n\n\n\n\n\n\nAnalice el siguiente código SIN EJECUTARLO e interprete cuál es la salida esperada explicando que sucede en cada iteración. Luego escriba a mano la salida exacta que dará este código.\n\ncompras &lt;- c(\"pan\", \"queso\", \"jamón\", \"tomate\", \"lechuga\")\n\ni &lt;- 1\nwhile (i &lt;= length(compras)) {\n  if (i == 1) {\n    print(paste(\"En mis lista de compras hay\", compras[i]))\n  }\n  else if (i == 2) {\n    print(paste(\"y también hay\", compras[i]))\n  }\n  else {\n    print(paste(\"y\", compras[i]))\n  }\n  i &lt;- i + 1\n}\n\n\n\n\n\nEl constructo for es otra estructura de tipo bucle que permite iterar sobre una colección dada de elementos. En pocas palabras, repetirá la ejecución de un mismo bloque de código tantas veces como elementos existan en dicha secuencia. Por ello, es importante recordar que su sintaxis básica es:\nfor (item in colección) {código a ejecutar}\n\nasistentes &lt;- c(\"Maria Guadalupe\", \"Clarisa\", \"Pablo Alejandro\", \"Andrea\", \"Raúl Andres\", \"Evangelina\",\n                \"Juan Manuel\", \"María Azul\", \"Gala\", \"Lucille\", \"Lucas\", \"Ludmila\", \"Adolfo Emiliano\",\n                \"Ana\", \"Julieta Lourdes\", \"Joaquín\", \"Agostina\", \"Victoria Lucia\")\nfor (nombre in asistentes) {\n  print(nombre)\n}\n\n[1] \"Maria Guadalupe\"\n[1] \"Clarisa\"\n[1] \"Pablo Alejandro\"\n[1] \"Andrea\"\n[1] \"Raúl Andres\"\n[1] \"Evangelina\"\n[1] \"Juan Manuel\"\n[1] \"María Azul\"\n[1] \"Gala\"\n[1] \"Lucille\"\n[1] \"Lucas\"\n[1] \"Ludmila\"\n[1] \"Adolfo Emiliano\"\n[1] \"Ana\"\n[1] \"Julieta Lourdes\"\n[1] \"Joaquín\"\n[1] \"Agostina\"\n[1] \"Victoria Lucia\"\n\n\nPara reflexionar: Compare el código de la celda precedente con el que usamos para listar las carreras usando un bucle while. ¿Que diferencias nota? ¿Cuando usaría uno u otro constructo?\n\n\nEl bucle for es ampliamente utilizado para trabajar sobre filas y columnas de un data.frame. Por ejemplo, podemos tomar la tabla iris (cargada por defecto en R) y generar una nueva columna llamada Rel.SepPet.L:\n\niris$Rel.SepPet.L &lt;- NA\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa           NA\n2          4.9         3.0          1.4         0.2  setosa           NA\n3          4.7         3.2          1.3         0.2  setosa           NA\n4          4.6         3.1          1.5         0.2  setosa           NA\n5          5.0         3.6          1.4         0.2  setosa           NA\n6          5.4         3.9          1.7         0.4  setosa           NA\n\n\nGracias a un bucle for, es posible trabajar sobre cada fila para rellenar la nueva columna creada con los valores resultantes de la relación (el ratio) entre el largo de los sépalos y pétalos:\n\nfor (i in 1:nrow(iris)) {\n  iris$Rel.SepPet.L[i] &lt;- iris$Sepal.Length[i] / iris$Petal.Length[i]\n}\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa     3.642857\n2          4.9         3.0          1.4         0.2  setosa     3.500000\n3          4.7         3.2          1.3         0.2  setosa     3.615385\n4          4.6         3.1          1.5         0.2  setosa     3.066667\n5          5.0         3.6          1.4         0.2  setosa     3.571429\n6          5.4         3.9          1.7         0.4  setosa     3.176471\n\n\nQueda claro que, como hemos visto anteriormente en el práctico de tablas, esta no es la forma más eficiente de generar la nueva columna (¿cuál sería la forma más eficiente?). No obstante, este ejemplo sirve para entender como funciona un bucle for con un data.frame.\n\n\n\nCuando trabajamos con bucles, es muy frecuente establecer un rango para definir la iteración. Allí entra en juego esta útil función que, como vimos en la clase de Vectores devuelve una secuencia numérica y cuya sintaxis es: seq(inicio,fin,paso), recordando que por defecto (es decir, si no explicitamos el valor del argumento), el inicio es “1” y el paso “1”.\n\n# Secuencia de 1 a 3\nfor (n in seq(3)){\n  print(n)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n# Secuencia de 2 a 8, cada 2\nfor (n in seq(2,8,2)){\n  print(n)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n\n\n\n\n\nAl igual que vimos con while, podemos controlar el comportamiento de un bucle for de acuerdo a diferentes condiciones.\n\nfruta &lt;- c(\"banana\", \"manzana\", \"pera\")\n\nfor (f in fruta){\n  print(paste(\"Cortamos el bucle en su primer iteración, con la fruta\", f))\n  if (f == \"banana\"){\n    break\n  }\n}\n\n[1] \"Cortamos el bucle en su primer iteración, con la fruta banana\"\n\n\n\nfor (i in seq(1, 10)) {\n  if (i %% 2 != 0) {\n    next\n  } else {\n    print(paste(\"Me salteo todos los impares:\", i))\n  }\n}\n\n[1] \"Me salteo todos los impares: 2\"\n[1] \"Me salteo todos los impares: 4\"\n[1] \"Me salteo todos los impares: 6\"\n[1] \"Me salteo todos los impares: 8\"\n[1] \"Me salteo todos los impares: 10\"\n\n\n\n\n\nEn muchas ocasiones, nos encontraremos con la necesidad de operar iterativamente sobre más de un conjunto de elementos, en esos casos podemos anidar los bucles.\n\nletras &lt;- c(\"a\", \"b\", \"c\")\nnumeros &lt;- c(1, 2, 3)\n\nfor (i in letras) {\n  for (j in numeros) {\n    print(paste(i, j))\n  }\n}\n\n[1] \"a 1\"\n[1] \"a 2\"\n[1] \"a 3\"\n[1] \"b 1\"\n[1] \"b 2\"\n[1] \"b 3\"\n[1] \"c 1\"\n[1] \"c 2\"\n[1] \"c 3\"\n\n\n\n\n\n\nall_num &lt;- c(17, 6, -12, 38, -88, 147, 1, -140, -19, 24, 74, -36)\n\nEscriba un código que separe los números positivos y los negativos del vector proporcionado en diferentes vectores. Imprima dichos vectores identificando su condición (positivo o negativo) y ordenados de menor a mayor.\nAyuda: ejecute el siguiente código previamente y vea que aprende con ello.\n\nej1 &lt;- c(3,1,2)\nprint(paste(\"Ordenados ej1:\", sort(ej1)))\nprint(ej1)\n\nej2 &lt;- c(4,8,6)\ncat(\"Ordenados ej2:\", sort(ej2))\n\n\n\n\nEl uso de for anidados es muy útil para trabajar con matrices:\n\nmat &lt;- matrix(sample(1:100, size = 9), ncol = 3)\nmat\n\n     [,1] [,2] [,3]\n[1,]   90   49    2\n[2,]   15   59   99\n[3,]   44   26   11\n\nfor (i in 1:nrow(mat)) {\n  for( j in 1:ncol(mat)) {\n    print(paste(\"El elemento de la fila\", i, \"y columna\", j, \"es igual a\", mat[i, j]))\n  }\n}\n\n[1] \"El elemento de la fila 1 y columna 1 es igual a 90\"\n[1] \"El elemento de la fila 1 y columna 2 es igual a 49\"\n[1] \"El elemento de la fila 1 y columna 3 es igual a 2\"\n[1] \"El elemento de la fila 2 y columna 1 es igual a 15\"\n[1] \"El elemento de la fila 2 y columna 2 es igual a 59\"\n[1] \"El elemento de la fila 2 y columna 3 es igual a 99\"\n[1] \"El elemento de la fila 3 y columna 1 es igual a 44\"\n[1] \"El elemento de la fila 3 y columna 2 es igual a 26\"\n[1] \"El elemento de la fila 3 y columna 3 es igual a 11\"\n\n\n¿Cómo funciona este código? La mejor forma de entender un bucle individual, o bucles anidados, es evaluar el primer caso de la serie de repeticiones que el bucle está efectuando y evaluar el código para el caso. Aquí, el primer caso sería cuando i = 1 y j = 1.\n\n\n\n\n\nProgramar desde cero puede ser muy frustrante! Esto es, obviamente, la situación más común si nuestra experiencia en lenguajes de programación es nula. A continuación, presentamos algunos consejos que pueden ayudarnos a programar nuestras primeras rutinas:\n\nPaso a paso. No trates de programar la tarea propuesta entera de una sola vez, mejor descomponer la tarea en tareas más pequeñas concatenadas entre sí.\nPseudocódigo. Es útil pensar, o incluso escribir, los pasos a seguir mediante pseudocódigo. Es decir, representar con oraciones simples cada tarea a realizar.\nEmpezar por el final. Muchas veces es útil pensar cuál es el resultado final que necesitamos y, luego, pensar desde allí, de atrás hacia adelante, que tareas debemos realizar para lograr ese resultado.\nEjemplo de juguete. Ante una tarea compleja, lo mejor es intentar generar la rutina deseada con un ejemplo de juguete o una pequeña porción de lo que nos proponemos hacer. Luego, si salió todo bien, extender la solución al problema en su totalidad.\nPrimero lo primero. Al programar un ciclo (for o while), puede ser difícil desarrollar de un tirón todo el código. Lo más indicado es programar las operaciones a realizar sobre el primer caso y, luego de haber obtenido el resultado exitosamente, generalizar el código para todos los casos.\nPensar en modo tabla. Si lo que quiero es obtener resultados en forma de tabla, una buena estrategia es generar la tabla con la o las columnas vacías. Luego, utilizamos un ciclo for para ir rellenando cada fila de las columnas creadas. Si lo pensamos así, nuestros ciclos for tendrán la siguiente forma general: for (i in 1:nrow(mi_tabla)) {mi código a ejecutar}.\nEl error como parte del proceso. Es normal que aparezcan errores todo el tiempo, pero es clave aprender a leer y comprender los mensajes de error. Estos mensajes suelen indicar exactamente qué está fallando y dónde.\n\n\n\n\n\nTomando de base el conjunto de datos iris, construya el siguiente data.frame:\n\nmodel_outputs &lt;- data.frame(Species = unique(iris$Species),\n                            Estimate = NA,\n                            P.value = NA)\nmodel_outputs\n\n     Species Estimate P.value\n1     setosa       NA      NA\n2 versicolor       NA      NA\n3  virginica       NA      NA\n\n\nLuego, evalúe modelos lineales que relacionen a la variable Petal.Length con la variable Sepal.Length en ese orden, para cada especie. Rellene la tabla generada anteriormente con los valores de los coeficientes (llamado Estimate o coeficiente de la variable predictora) y su valor-P (P.value) en cada caso. Para hacer esto, utilice alguna estructura de control de flujo aprendida!\nAyuda: utilice la función lm() para construir los modelos lineales. La salida de la función summary(), que actúa sobre el modelo (salida de lm()), contiene la información sobre los coeficientes que necesitamos.\n\n\n \n\n\n\n\n\nCuando vimos los condicionales, armamos un código para evaluar en 3 escenarios diferentes los gastos que realizaron Andrea y Ariel. Ahora que sabe usar bucles, escriba un código que evalué en una sola ejecución todos los escenarios planteados en ese ejercicio y que utilice todos los constructos aprendidos, es decir: if, while y for.\nAyuda: recuerde que los bucles while pueden ejecutarse indefinidamente si no imponemos condiciones para que finalicen.",
    "crumbs": [
      "Inicio",
      "Unidad 3",
      "Estructuras de control de flujo"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html",
    "href": "dia5/7.1_Funciones.html",
    "title": "Funciones",
    "section": "",
    "text": "Las funciones en R son las herramientas que nos permiten realizar una gran diversidad de análisis. Para ello, R provee de una numerosa y potente biblioteca de ellas, las cuales vienen instalada por defecto. Además, como hemos desarrollado al principio del curso, existe una abanico mega-diverso de paquetes de R desarrollados por los propios usuarios, especialmente desarrollados para la realización de tareas específicas.\nNo obstante, es usual que en un flujo de trabajo de intermedio a avanzado necesitemos desarrollar nuestras propias funciones. La razón para ello radica en la ejecución de una tarea muy específica como parte de nuestros análisis, pero que al mismo tiempo debe realizarse múltiples veces para que amerite su desarrollo en forma de función.\nLas funciones en R se asignan a objetos, cuyo nombre será el nombre de la función, con la expresión function(). Dentro de los paréntesis debemos indicar los argumentos de la función. Estos serán los objetos con los que la función trabajará de alguna manera, y devolverá alguna salida determinada. La sintaxis general es la siguiente:\n\nmi_funcion &lt;- function(argumento1, argumento2, argumento3){\n  # Inserte aqui el codigo que trabajara con los objetos definidos en los argumentos,\n  # junto con la salida que se propone para la nueva funcion\n}\n\nPor ejemplo:\n\nblabla &lt;- function(nombre = \"- inserte aquí su nombre -\"){\n  print(paste(\"Mi nombre es\", nombre, \"y me encanta el curso de Fundamentos básicos del lenguaje R.\"))\n}\n\nAl correr el bloque de código anterior, simplemente estamos creando la función, y no corriendo el código programado. Esta se carga como un objeto propio en el entorno, quedando disponible para su uso futuro.\nEn este ejemplo, el argumento nombre se encuentra asignado a una línea de texto. De esta manera, la función entiende que el valor indicado es el valor por defecto, para los casos los que el usuario no define un valor particular para dicho argumento. La definición de valores por defecto no es obligatoria, pero puede ser útil en muchos casos. Si corremos dicha función suelta, sin definir nada en específico, podemos observar el resultado:\n\nblabla()\n\n[1] \"Mi nombre es - inserte aquí su nombre - y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n\n\nEn cambio, podemos asignarle un valor al argumento nombre:\n\nblabla(nombre = \"Lionel Scaloni\")\n\n[1] \"Mi nombre es Lionel Scaloni y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n\n\n\n\nUna cuestión a considerar en el contexto de creación de funciones es el uso que las mismas hacen de los entornos. Podemos definir a un entorno como al espacio en donde se guardan nuestros objetos. Cuando creamos un objeto, sea una tabla, un vector, una función o cualquier otro, estos se guardan en el entorno global, y de hecho aparecen visibles en el panel correspondiente de la interfaz de RStudio. Cuando creamos una función, se crea un sub-entorno contenido dentro de la función. ¿Por qué es esto relevante? Porque los entornos son los lugares en donde se guardan los objetos de los que haremos uso para nuestras funciones, y una función buscará primero en el entorno de la función, luego en el entorno que se encuentra un nivel por encima de este.\nVeámoslo con un ejemplo. La siguiente función toma un número y le suma 5:\n\nfff &lt;- function(x){\n  y &lt;- x + 5\n  y\n}\n\nPor ejemplo:\n\nfff(x = 3)\n\n[1] 8\n\n\nEsta función guarda el resultado en un objeto llamado y. Sin embargo, podemos ver que este objeto no se guarda en el entorno global, lo cual se evidencia cuando intentamos leer dicho objeto:\n\ny\n\nError: objeto 'y' no encontrado\n\n\nLa razón es que y se creó en el entorno de la función fff(), se guarda allí dentro, se utiliza para la ejecución de la función, y finalmente se descarta.\nVeamos ahora la siguiente variante de la función:\n\nfff &lt;- function(){\n  y &lt;- x + 5\n  y\n}\n\nLa diferencia es que esta función no tiene argumentos. Veamos lo que sucede al correrla:\n\nfff()\n\nError in fff(): objeto 'x' no encontrado\n\n\nEl error se debe a que x no está definido. Pero miremos lo que pasa si definimos a x por fuera de la función:\n\nx &lt;- 9\nfff()\n\n[1] 14\n\n\n¿Que pasó? La función buscó al objeto x dentro del entorno de la función, no lo encontró, pero luego buscó en el entorno un nivel por encima, que es el entorno global. Encontró un objeto con dicho nombre, y lo utilizó para su ejecución.\nPara testear: ¿Qué sucedería si x está definido por fuera de la función pero también dentro de la misma?",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#cómo-creo-una-función",
    "href": "dia5/7.1_Funciones.html#cómo-creo-una-función",
    "title": "Funciones",
    "section": "",
    "text": "Las funciones en R son las herramientas que nos permiten realizar una gran diversidad de análisis. Para ello, R provee de una numerosa y potente biblioteca de ellas, las cuales vienen instalada por defecto. Además, como hemos desarrollado al principio del curso, existe una abanico mega-diverso de paquetes de R desarrollados por los propios usuarios, especialmente desarrollados para la realización de tareas específicas.\nNo obstante, es usual que en un flujo de trabajo de intermedio a avanzado necesitemos desarrollar nuestras propias funciones. La razón para ello radica en la ejecución de una tarea muy específica como parte de nuestros análisis, pero que al mismo tiempo debe realizarse múltiples veces para que amerite su desarrollo en forma de función.\nLas funciones en R se asignan a objetos, cuyo nombre será el nombre de la función, con la expresión function(). Dentro de los paréntesis debemos indicar los argumentos de la función. Estos serán los objetos con los que la función trabajará de alguna manera, y devolverá alguna salida determinada. La sintaxis general es la siguiente:\n\nmi_funcion &lt;- function(argumento1, argumento2, argumento3){\n  # Inserte aqui el codigo que trabajara con los objetos definidos en los argumentos,\n  # junto con la salida que se propone para la nueva funcion\n}\n\nPor ejemplo:\n\nblabla &lt;- function(nombre = \"- inserte aquí su nombre -\"){\n  print(paste(\"Mi nombre es\", nombre, \"y me encanta el curso de Fundamentos básicos del lenguaje R.\"))\n}\n\nAl correr el bloque de código anterior, simplemente estamos creando la función, y no corriendo el código programado. Esta se carga como un objeto propio en el entorno, quedando disponible para su uso futuro.\nEn este ejemplo, el argumento nombre se encuentra asignado a una línea de texto. De esta manera, la función entiende que el valor indicado es el valor por defecto, para los casos los que el usuario no define un valor particular para dicho argumento. La definición de valores por defecto no es obligatoria, pero puede ser útil en muchos casos. Si corremos dicha función suelta, sin definir nada en específico, podemos observar el resultado:\n\nblabla()\n\n[1] \"Mi nombre es - inserte aquí su nombre - y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n\n\nEn cambio, podemos asignarle un valor al argumento nombre:\n\nblabla(nombre = \"Lionel Scaloni\")\n\n[1] \"Mi nombre es Lionel Scaloni y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n\n\n\n\nUna cuestión a considerar en el contexto de creación de funciones es el uso que las mismas hacen de los entornos. Podemos definir a un entorno como al espacio en donde se guardan nuestros objetos. Cuando creamos un objeto, sea una tabla, un vector, una función o cualquier otro, estos se guardan en el entorno global, y de hecho aparecen visibles en el panel correspondiente de la interfaz de RStudio. Cuando creamos una función, se crea un sub-entorno contenido dentro de la función. ¿Por qué es esto relevante? Porque los entornos son los lugares en donde se guardan los objetos de los que haremos uso para nuestras funciones, y una función buscará primero en el entorno de la función, luego en el entorno que se encuentra un nivel por encima de este.\nVeámoslo con un ejemplo. La siguiente función toma un número y le suma 5:\n\nfff &lt;- function(x){\n  y &lt;- x + 5\n  y\n}\n\nPor ejemplo:\n\nfff(x = 3)\n\n[1] 8\n\n\nEsta función guarda el resultado en un objeto llamado y. Sin embargo, podemos ver que este objeto no se guarda en el entorno global, lo cual se evidencia cuando intentamos leer dicho objeto:\n\ny\n\nError: objeto 'y' no encontrado\n\n\nLa razón es que y se creó en el entorno de la función fff(), se guarda allí dentro, se utiliza para la ejecución de la función, y finalmente se descarta.\nVeamos ahora la siguiente variante de la función:\n\nfff &lt;- function(){\n  y &lt;- x + 5\n  y\n}\n\nLa diferencia es que esta función no tiene argumentos. Veamos lo que sucede al correrla:\n\nfff()\n\nError in fff(): objeto 'x' no encontrado\n\n\nEl error se debe a que x no está definido. Pero miremos lo que pasa si definimos a x por fuera de la función:\n\nx &lt;- 9\nfff()\n\n[1] 14\n\n\n¿Que pasó? La función buscó al objeto x dentro del entorno de la función, no lo encontró, pero luego buscó en el entorno un nivel por encima, que es el entorno global. Encontró un objeto con dicho nombre, y lo utilizó para su ejecución.\nPara testear: ¿Qué sucedería si x está definido por fuera de la función pero también dentro de la misma?",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#uso-de-return",
    "href": "dia5/7.1_Funciones.html#uso-de-return",
    "title": "Funciones",
    "section": "Uso de return()",
    "text": "Uso de return()\nDesarrollemos una función un poco más compleja. Por ejemplo, imaginemos una función que calcula el valor promedio de un conjunto de números (tarea que, ya sabemos, ejecuta mean()). Una forma de hacerlo es la siguiente:\n\nvalor_promedio &lt;- function(x){\n  # Sumo todos los valores del vector x con un ciclo for\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i]\n  }\n  \n  # Divido la suma por la cantidad de elementos\n  promedio &lt;- sum/length(x)\n  \n  return(promedio)\n}\n\nNotar que el contenido de la función es casi idéntico a como programaríamos por fuera del contexto de una función. La única diferencia es que la función permite realizar la tarea propuesta para cualquier caso, y no para solo uno en particular. Aquí, podemos definir cualquier vector numérico que quisiéramos, y calcular el promedio a partir del vector indicado.\nOtra diferencia que vemos aquí respecto de la función del ejemplo anterior (blabla()) es el uso de la función return(). Esta expresión indica el valor a devolver por la función, y su llamado termina la ejecución de la función en esa línea. Es decir, toda línea de código por debajo de un return() no se ejecutará. ¿De qué serviría esto? Por ejemplo, la función podría ejecutar un bloque de código si se cumple una condición, y otro bloque si no se cumple, justificando la presencia de más de un return().\nLa siguiente línea calcula el valor promedio para el vector 1:30:\n\nvalor_promedio(1:30)\n\n[1] 15.5\n\n\nNotar que no es necesario aclarar explícitamente el nombre del argumento x, basta con que sea el primero.\nUna versión un poquito más compleja que la anterior posee un segundo argumento que le otorga un peso a cada elemento de la muestra. Por lo tanto, estaremos calculando un promedio ponderado. Se espera un vector numérico de longitud igual a x, indicando el peso otorgado a cada elemento. Por defecto, definimos un vector numérico de unos, otorgando así el mismo peso a cada elemento:\n\nvalor_promedio &lt;- function(x, pesos = rep(1, length(x))){\n  # Sumo todos los valores del vector x\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i] * pesos[i]\n  }\n  \n  promedio &lt;- sum/length(x)\n  return(promedio)\n}\n\nPor ejemplo, para el mismo conjunto de números anterior:\n\npesos_aleatorios &lt;- sample(c(0.5, 0.75, 1), length(1:30), replace = TRUE)\nvalor_promedio(x = 1:30, pesos = pesos_aleatorios)\n\n[1] 11.10833",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#uso-de-stop-y-warning",
    "href": "dia5/7.1_Funciones.html#uso-de-stop-y-warning",
    "title": "Funciones",
    "section": "Uso de stop() y warning()",
    "text": "Uso de stop() y warning()\nAdemás de return(), las funciones stop() y warning() serán de utilidad cuando creemos nuestras propias funciones. Por ejemplo, imaginemos que el usuario indica para el argumento x un vector de tipo character(). Obviamente, el promedio no puede calcularse, y obtenemos un error. Este error, sin embargo, no es muy informativo:\n\nvalor_promedio(x = LETTERS[1:10])\n\nError in x[i] * pesos[i]: argumento no-numérico para operador binario\n\n\nPodemos agregar una condición que evalúe si el vector es numérico, caso contrario utilizamos stop().\n\nvalor_promedio &lt;- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser numérico.\")\n  }\n  \n  # Sumo todos los valores del vector x\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i] * pesos[i]\n  }\n  \n  promedio &lt;- sum/length(x)\n  return(promedio)\n}\n\nCon el uso de stop() la ejecución de la función se termina, y se imprime un mensaje informativo en la consola:\n\nvalor_promedio(x = LETTERS[1:10])\n\nError in valor_promedio(x = LETTERS[1:10]): El vector indicado en 'x' debe ser numérico.\n\n\nLa función warning() imprime una advertencia, pero continúa con la ejecución. Por ejemplo, imaginemos que el usuario indica un vector de pesos de diferente longitud a la longitud del vector indicado en x. Una opción para contemplar este escenario sería la siguiente:\n\nvalor_promedio &lt;- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser numérico.\")\n  }\n  \n  # Evalua si la longitud del vector en 'pesos' es igual a la de 'x'\n  if(length(x) != length(pesos)){\n    warning(\"El argumento 'pesos' debe ser un vector numérico de la misma longitud que el vector en 'x'. Se tomó el valor por defecto.\")\n    pesos &lt;- rep(1, length(x))\n  }\n  \n  # Sumo todos los valores del vector x\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i] * pesos[i]\n  }\n  \n  promedio &lt;- sum/length(x)\n  return(promedio)\n}\n\nNotar que se evalúa la condición planteada para el argumento pesos. Si no se cumple que la longitud del vector indicado es igual a la longitud del vector en x, la función imprime una advertencia. Además, para que la función siga ejecutándose correctamente, definimos pesos &lt;- rep(1, length(x)), es decir, el valor por defecto. Este último paso es fundamental, de lo contrario la salida de la función sería impredecible.\n\nvalor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75))\n\nWarning in valor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75)): El argumento\n'pesos' debe ser un vector numérico de la misma longitud que el vector en 'x'.\nSe tomó el valor por defecto.\n\n\n[1] 15.5\n\n\nVemos que el promedio es calculado correctamente (con pesos = rep(1, length(x))), pero además se imprime una advertencia.\nEl uso de las funciones stop() y warning() en el contexto de funciones no es fundamental, pero adquieren relevancia para funciones que usarán otras personas. Uno nunca sabe con absoluta seguridad el tipo de entrada que un usuario externo usaría en una de nuestras funciones, y uno debe prevenir distintos escenarios. Sin embargo, si a las funciones las usaremos sólo nosotros, contemplar estos escenarios no será vital, por lo que no sería absolutamente necesario el uso de stop() o warning().",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#funciones-del-tipo-apply",
    "href": "dia5/7.1_Funciones.html#funciones-del-tipo-apply",
    "title": "Funciones",
    "section": "Funciones del tipo apply",
    "text": "Funciones del tipo apply\nLas funciones de la familia apply se utilizan para aplicar una función determinada a una lista o a un vector. Es útil para realizar un mismo cálculo a un conjunto de elementos dado, evitando utilizar, por ejemplo, un ciclo for.\nPor ejemplo, imaginemos una lista de 3 elementos, cada elemento un vector numérico:\n\nlista_numeros &lt;- list(sample(1:1000, size = 50),\n                      sample(1:1000, size = 50),\n                      sample(1:1000, size = 50))\nlista_numeros\n\n[[1]]\n [1] 708  62 723 393 285 212 944 489  38 576 106 265 200 898 878 104 338 485 941\n[20] 658 416  61 768 366 131 765 871 473 113  25  59 803 641 888 135 442 512 315\n[39]  89 372 932 102 284 546 340 897 627 682 578 604\n\n[[2]]\n [1] 938 383 884 139 549 702 870 305 151 236 221 993 266 239   6 605 319 829 573\n[20] 786 517 634 165 519 342 323 853 102 684 643 138 348 466 584 930 353 941 371\n[39] 253 677  14 729 290 110 751 116 631 133 231  89\n\n[[3]]\n [1] 933 873 869 555 579  37 817 587 691 318 118 838 241 169 760 900 899 495 664\n[20] 876 513  51 147 151 995 577 865 970 290 506 330  30 912  81 801 897 570 416\n[39] 413 305 389 757 563 635 945 123 308 923 154 629\n\n\nLa función sapply() aplica una función dada a un objeto de tipo list(), y devuelve un vector. En este ejemplo, utilizaremos la función recientemente creada (valor_promedio()), para calcular el promedio de cada conjunto de números de la lista (indicados en el primer argumento):\n\npromedios &lt;- sapply(lista_numeros, FUN = valor_promedio)\npromedios\n\n[1] 462.80 458.62 549.30\n\n\nNotar que para el argumento FUN indicamos el nombre de la función sin los paréntesis, la cual debe existir en el entorno (cargada por el usuario o por defecto en R).\nSi quisiéramos indicar otros argumentos para la función valor_promedio(), estos pueden definirse luego del argumento FUN:\n\npesos_aleatorios &lt;- sample(c(0.5, 0.75, 1), size = 50, replace = TRUE)\npromedios &lt;- sapply(lista_numeros, FUN = valor_promedio, pesos = pesos_aleatorios)\npromedios\n\n[1] 350.735 357.310 443.125\n\n\nPara pensar: tal cual como está programada, la función valor_promedio() no es útil para ser utilizada con la función sapply(), especialmente en cuanto al argumento pesos. ¿Por qué?\nExisten otras variantes a la función sapply(), como por ejemplo lapply(), que funciona de manera idéntica pero devuelve una lista en vez de un vector.",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#ejercicios",
    "href": "dia5/7.1_Funciones.html#ejercicios",
    "title": "Funciones",
    "section": "Ejercicios",
    "text": "Ejercicios\n\nCree una función que calcule el área de un triángulo a partir de su base y altura. Contemple el escenario en el que el usuario indique valores no numéricos para los argumentos.\nCree una función que calcule el error estándar de un conjunto de números. El error estándar se calcula realizando el cociente entre el desvío estándar de la muestra y la raíz cuadrada de la cantidad de números evaluados.\nA partir de la función que calcula el error estándar, utilice la función sapply() para calcular el error estándar del conjunto de números seq(1, 50, 20), c(501, 920, 759, 233) y -14:28.",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html",
    "href": "dia4/6.2_ggplot2.html",
    "title": "Introducción a gráficos con ggplot2",
    "section": "",
    "text": "El paquete ggplot2 ofrece una nutrida biblioteca de funciones para la creación de gráficos de diversos tipos en R. La diversidad de gráficos y formas de personalización es enorme -es un curso en sí mismo- y aquí simplemente desarrollaremos los fundamentos básicos para su comprensión. Existen varias páginas web útiles para aprender sobre el desarrollo de gráficos con ggplot2, incluyendo a The R Graph Gallery y R Charts. En esta página se muestra una tabla de colores junto con su nombre a utilizar dentro del entorno R.\nA diferencia de otros paquetes de graficación, incluyendo a las funciones nativas de R que ya hemos visto, la creación de gráficos con ggplot2 sigue una lógica diferente. Se trabaja mediante la apilación de “capas gráficas” a través de un lenguaje propio del paquete. Si tradujéramos el código en palabras, sería algo así:\ncreo espacio de graficación →   añado capa gráfica nº1 (e.g. puntos) →   añado capa gráfica nº2 (e.g. líneas) →   configuro eje x →   configuro eje y →   configuro parámetros generales del gráfico\nMejor que explicarlo, es mostrarlo!\nAntes que nada, es necesario cargar el paquete al entorno de R:\n\nlibrary(ggplot2)\n\n\n\nPara crear un nuevo gráfico, por ejemplo un simple gráfico de puntos, lo hacemos con el siguiente bloque de código:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\nLa primera línea llama a la función ggplot(). Esta función será el inicio de todos nuestros gráficos con ggplot2. Allí, indicamos el conjunto de datos que se utilizará para obtener los datos de graficación, típicamente un data.frame, en el argumento llamado data. El argumento mapping debe definirse a través de la función aes(), dentro de la cual definimos las variables a graficar y su asociación a las columnas del data.frame indicado. Aquí indicamos que la variable x será “Sepal.Length” y la variable y “Petal.Length”. Ambas son columnas del dataset iris indicado en el argumento data.\nSeguidamente a la primera línea observamos un +, y esta es la gran diferencia de la lógica de ggplot2 respecto de otros paquetes. El operador + indica que seguido a él se añadirá una nueva capa al gráfico. Aquí, en la segunda línea (y está en la segunda línea por simple prolijidad, pero podría ir seguido en la primera línea), la función geom_point() indica que se añadirá un gráfico de nube de puntos (o scatterplot). En general, todas las funciones que comienzan congeom_ refieren a tipos de gráficos particulares, entre ellas:\n\ngeom_point(): puntos.\ngeom_line(): líneas.\ngeom_bar() y geom_col(): barras.\ngeom_boxplot(): cajas (boxplots),\n\nPara probar: Escriba en la consola geom_, y espera a observar las sugerencias de funciones disponibles para la generación de distintos tipos de gráficos en ggplot2.\n\n\n\n\n\n\nEl grado de personalización de los gráficos con ggplot2 es inmenso. Por ejemplo, podemos cambiar el color, tamaño, forma y transparencia:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7)\n\n\n\n\n\n\n\n\nSi comparamos los argumentos utilizados en ggplot2 con los de los gráficos base de R, size es equivalente a cex, col vale para ambos enfoques, fill es equivalente a bg y shape es equivalente a pch.\nEl operador + permite agregar nuevas capas de información y personalización:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7) +\n  geom_hline(yintercept = mean(iris$Petal.Length), lty = \"dashed\") +\n  ggtitle(\"Scatterplot de ejemplo\")\n\n\n\n\n\n\n\n\nLa función geom_hline() agrega una línea horizontal: el argumento yintercept indica el valor para y por donde pasará la línea, aquí indicado por el valor promedio de la variable y; el argumento lty permite elegir un estilo para la línea. La función ggtitle() añade un título.\n\n\n\nLas funciones del tipo scale_ son muy importantes, ya que permiten personalizar aspectos relacionados a las variables indicadas dentro de la función aes(). Aquí, con scale_x_continuous() indicamos un nombre para el eje x en el argumento name, los límites numéricos del eje con el argumento limits (vector de dos elementos, con valor mínimo y máximo) y los cortes del eje con el argumento breaks (vector numérico indicando dónde se ubicaran los cortes).\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\", limits = c(5, 7), breaks = seq(5, 7, 0.5)) +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n\nWarning: Removed 34 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nNotar la advertencia generada. ¿Qué significa?\nAhora bien, el gráfico que venimos haciendo incluye a las variables florales de las tres especies de Iris provistas dentro del conjunto de datos. ¿Cómo hacemos para diferenciarlas en el gráfico? Debemos indicar una nueva variable dentro de aes(), asociada a un parámetro gráfico apropiado. En este contexto, lo mejor sería que los puntos tengan diferentes colores por especie:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n\n\n\n\n\n\n\n\nNotar el agregado de la variable color asignada a la columna “Species” de nuestra tabla, así también como la no definición de un color fijo dentro de la función geom_point() (porque la idea es que haya un color distinto para cada especie). Aquí, bien podríamos haber definido otro parámetro gráfico a modificar según las distintas especies, tales como la forma (shape) o el tamaño (size). Volviendo a nuestro código anterior, ¿cómo definimos colores específicos para cada nivel? La función scale_color_manual() es la indicada:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n\n\n\n\n\n\n\nLos colores se encuentran definidos en el argumento values. Los argumentos name y labels permiten modificar el nombre asignado para la leyenda, y las etiquetas para cada especie.\nPor otro lado, la función geom_smooth() añade líneas o curvas de tendencia para los datos. Aquí, el argumento method = \"lm\" indica que la línea a aproximar en la nube de puntos se calculará mediante una regresión lineal (“linear model”):\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\nVeamos ahora un gráfico de cajas, con la función geom_boxplot():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nDentro de aes() definimos para x la variable discreta “Species” y para y la variable continua “Petal.Length”. La incorporación del argumento fill indica colores distintos para cada especie.\nPara jugar: Cambie fill por col y observe los resultados.\nPara configurar aspectos del eje x de un boxplot, scale_x_continuos() no servirá, porque la variable definida para x no es continua (son especies). La función adecuada es scale_x_discrete():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nPara observar: Vea también los otros cambios incorporados al gráfico y asocie esos cambios con cada línea de código.\nLa función geom_jitter() permite agregar una nube de puntos, las observaciones, pero dispuestas de manera aleatoria a lo largo de uno o ambos ejes:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3, outliers = FALSE) +\n  geom_jitter(shape = 21, height = 0, width = 0.3, alpha = 0.4) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nAl indicar height = 0, los puntos mantendrán la ubicación original para la variable y. En cambio, width = 0.3 reubica aleatoriamente cada punto a lo largo del eje x. El valor 0.3 simplemente indica el nivel de ruido, en este caso horizontal, que tendrá cada punto.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#otra-lógica-de-programación",
    "href": "dia4/6.2_ggplot2.html#otra-lógica-de-programación",
    "title": "Introducción a gráficos con ggplot2",
    "section": "",
    "text": "El paquete ggplot2 ofrece una nutrida biblioteca de funciones para la creación de gráficos de diversos tipos en R. La diversidad de gráficos y formas de personalización es enorme -es un curso en sí mismo- y aquí simplemente desarrollaremos los fundamentos básicos para su comprensión. Existen varias páginas web útiles para aprender sobre el desarrollo de gráficos con ggplot2, incluyendo a The R Graph Gallery y R Charts. En esta página se muestra una tabla de colores junto con su nombre a utilizar dentro del entorno R.\nA diferencia de otros paquetes de graficación, incluyendo a las funciones nativas de R que ya hemos visto, la creación de gráficos con ggplot2 sigue una lógica diferente. Se trabaja mediante la apilación de “capas gráficas” a través de un lenguaje propio del paquete. Si tradujéramos el código en palabras, sería algo así:\ncreo espacio de graficación →   añado capa gráfica nº1 (e.g. puntos) →   añado capa gráfica nº2 (e.g. líneas) →   configuro eje x →   configuro eje y →   configuro parámetros generales del gráfico\nMejor que explicarlo, es mostrarlo!\nAntes que nada, es necesario cargar el paquete al entorno de R:\n\nlibrary(ggplot2)\n\n\n\nPara crear un nuevo gráfico, por ejemplo un simple gráfico de puntos, lo hacemos con el siguiente bloque de código:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\nLa primera línea llama a la función ggplot(). Esta función será el inicio de todos nuestros gráficos con ggplot2. Allí, indicamos el conjunto de datos que se utilizará para obtener los datos de graficación, típicamente un data.frame, en el argumento llamado data. El argumento mapping debe definirse a través de la función aes(), dentro de la cual definimos las variables a graficar y su asociación a las columnas del data.frame indicado. Aquí indicamos que la variable x será “Sepal.Length” y la variable y “Petal.Length”. Ambas son columnas del dataset iris indicado en el argumento data.\nSeguidamente a la primera línea observamos un +, y esta es la gran diferencia de la lógica de ggplot2 respecto de otros paquetes. El operador + indica que seguido a él se añadirá una nueva capa al gráfico. Aquí, en la segunda línea (y está en la segunda línea por simple prolijidad, pero podría ir seguido en la primera línea), la función geom_point() indica que se añadirá un gráfico de nube de puntos (o scatterplot). En general, todas las funciones que comienzan congeom_ refieren a tipos de gráficos particulares, entre ellas:\n\ngeom_point(): puntos.\ngeom_line(): líneas.\ngeom_bar() y geom_col(): barras.\ngeom_boxplot(): cajas (boxplots),\n\nPara probar: Escriba en la consola geom_, y espera a observar las sugerencias de funciones disponibles para la generación de distintos tipos de gráficos en ggplot2.\n\n\n\n\n\n\nEl grado de personalización de los gráficos con ggplot2 es inmenso. Por ejemplo, podemos cambiar el color, tamaño, forma y transparencia:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7)\n\n\n\n\n\n\n\n\nSi comparamos los argumentos utilizados en ggplot2 con los de los gráficos base de R, size es equivalente a cex, col vale para ambos enfoques, fill es equivalente a bg y shape es equivalente a pch.\nEl operador + permite agregar nuevas capas de información y personalización:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7) +\n  geom_hline(yintercept = mean(iris$Petal.Length), lty = \"dashed\") +\n  ggtitle(\"Scatterplot de ejemplo\")\n\n\n\n\n\n\n\n\nLa función geom_hline() agrega una línea horizontal: el argumento yintercept indica el valor para y por donde pasará la línea, aquí indicado por el valor promedio de la variable y; el argumento lty permite elegir un estilo para la línea. La función ggtitle() añade un título.\n\n\n\nLas funciones del tipo scale_ son muy importantes, ya que permiten personalizar aspectos relacionados a las variables indicadas dentro de la función aes(). Aquí, con scale_x_continuous() indicamos un nombre para el eje x en el argumento name, los límites numéricos del eje con el argumento limits (vector de dos elementos, con valor mínimo y máximo) y los cortes del eje con el argumento breaks (vector numérico indicando dónde se ubicaran los cortes).\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\", limits = c(5, 7), breaks = seq(5, 7, 0.5)) +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n\nWarning: Removed 34 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nNotar la advertencia generada. ¿Qué significa?\nAhora bien, el gráfico que venimos haciendo incluye a las variables florales de las tres especies de Iris provistas dentro del conjunto de datos. ¿Cómo hacemos para diferenciarlas en el gráfico? Debemos indicar una nueva variable dentro de aes(), asociada a un parámetro gráfico apropiado. En este contexto, lo mejor sería que los puntos tengan diferentes colores por especie:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n\n\n\n\n\n\n\n\nNotar el agregado de la variable color asignada a la columna “Species” de nuestra tabla, así también como la no definición de un color fijo dentro de la función geom_point() (porque la idea es que haya un color distinto para cada especie). Aquí, bien podríamos haber definido otro parámetro gráfico a modificar según las distintas especies, tales como la forma (shape) o el tamaño (size). Volviendo a nuestro código anterior, ¿cómo definimos colores específicos para cada nivel? La función scale_color_manual() es la indicada:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n\n\n\n\n\n\n\nLos colores se encuentran definidos en el argumento values. Los argumentos name y labels permiten modificar el nombre asignado para la leyenda, y las etiquetas para cada especie.\nPor otro lado, la función geom_smooth() añade líneas o curvas de tendencia para los datos. Aquí, el argumento method = \"lm\" indica que la línea a aproximar en la nube de puntos se calculará mediante una regresión lineal (“linear model”):\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\nVeamos ahora un gráfico de cajas, con la función geom_boxplot():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nDentro de aes() definimos para x la variable discreta “Species” y para y la variable continua “Petal.Length”. La incorporación del argumento fill indica colores distintos para cada especie.\nPara jugar: Cambie fill por col y observe los resultados.\nPara configurar aspectos del eje x de un boxplot, scale_x_continuos() no servirá, porque la variable definida para x no es continua (son especies). La función adecuada es scale_x_discrete():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nPara observar: Vea también los otros cambios incorporados al gráfico y asocie esos cambios con cada línea de código.\nLa función geom_jitter() permite agregar una nube de puntos, las observaciones, pero dispuestas de manera aleatoria a lo largo de uno o ambos ejes:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3, outliers = FALSE) +\n  geom_jitter(shape = 21, height = 0, width = 0.3, alpha = 0.4) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nAl indicar height = 0, los puntos mantendrán la ubicación original para la variable y. En cambio, width = 0.3 reubica aleatoriamente cada punto a lo largo del eje x. El valor 0.3 simplemente indica el nivel de ruido, en este caso horizontal, que tendrá cada punto.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#ejercicio-1",
    "href": "dia4/6.2_ggplot2.html#ejercicio-1",
    "title": "Introducción a gráficos con ggplot2",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nGenere un gráfico idéntico al último expuesto, pero con un orden distinto para los niveles del eje x. El orden debe ser, de izquierda a derecha, I. virginica, I. versicolor e I. setosa. Para ello, debe redefinir la variable “Species” de la tabla como un factor con niveles en el orden indicado. Si no se acuerda como hacerlo, vuelva a la clase de Vectores.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#funciones-de-tipo-theme",
    "href": "dia4/6.2_ggplot2.html#funciones-de-tipo-theme",
    "title": "Introducción a gráficos con ggplot2",
    "section": "Funciones de tipo theme",
    "text": "Funciones de tipo theme\nLas funciones que inician con theme permiten la personalización general del gráfico. Por un lado, contamos con funciones como theme_light(), las cuales vienen asociadas con configuraciones gráficas preestablecidas. Por otro lado, la función theme() permite un grado de personalización del gráfico muy alta. Por ejemplo:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = NULL, \n                     labels = c(expression(italic(\"I. setosa\")), \n                                expression(italic(\"I. versicolor\")), \n                                expression(italic(\"I. virginica\"))), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  annotate(\"text\", x = 4, y = 6.5, label = \"p &lt; 0.05\", hjust = 0) +\n  theme_light() +\n  theme(aspect.ratio = 9/16, legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nUn primer aspecto a considerar es el orden de las nuevas capas añadidas. Notar que primero se agregó theme_light(), luego theme(). Esto es importante porque, de haberlo hecho al revés, las personalizaciones hechas en theme() hubieran sido reemplazadas por la configuración preestablecida de theme_light().\nDentro de theme(), es posible indicar una gran cantidad de argumentos (ver ?theme). Entre ellos, el argumento aspect.ratio es muy útil, ya que permite establecer la relación de aspecto de la figura. Asimismo, con legend.position = \"bottom\" se indica que la leyenda se ubique en la parte baja de la figura.\nVale la pena mencionar la nueva capa añadida mediante annotate(), la cual sirve para añadir información al gráfico de manera directa (sin necesidad de referencias a un dataset). En el ejemplo, se utilizó para agregar texto, pero también sirve para agregar líneas o segmentos, entre otros.\nPara observar: Además de lo ya explicado, ¿qué otras cosas cambiaron en el último gráfico respecto del anterior? ¿Qué líneas de código son las responsables de ello?\nPara jugar: Cambie theme_light() por otras funciones del tipo con otras configuraciones preestablecida y observe los distintos resultados.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#ejemplo-de-caso-típico-gráficos-de-barras-con-error",
    "href": "dia4/6.2_ggplot2.html#ejemplo-de-caso-típico-gráficos-de-barras-con-error",
    "title": "Introducción a gráficos con ggplot2",
    "section": "Ejemplo de caso típico: gráficos de barras con error",
    "text": "Ejemplo de caso típico: gráficos de barras con error\nUn gráfico muy popular es el gráfico de barras con error asociado. Usualmente, la barra indica un valor promedio y la barra de error el error estándar o la desviación estándar. ¿Cómo haríamos este gráfico en ggplot2? Primero, es necesario generar un data.frame con los valores promedio y de error asociados (en este ejemplo, la desviación estándar). Lo haremos para cada especie del género Iris:\n\niris_agg1 &lt;- aggregate(Petal.Width ~ Species, data = iris, mean)\ncolnames(iris_agg1)[2] &lt;- \"Petal.Width.mean\"\niris_agg2 &lt;- aggregate(Petal.Width ~ Species, data = iris, sd)\ncolnames(iris_agg2)[2] &lt;- \"Petal.Width.sd\"\niris_agg_3 &lt;- merge(iris_agg1, iris_agg2, by = \"Species\")\niris_agg_3\n\n     Species Petal.Width.mean Petal.Width.sd\n1     setosa            0.246      0.1053856\n2 versicolor            1.326      0.1977527\n3  virginica            2.026      0.2746501\n\n\nLuego, la función adecuada para generar la barra es geom_col(), mientras que para la barra de error utilizamos geom_errorbar:\n\nggplot(data = iris_agg_3, aes(x = Species)) +\n  geom_col(aes(y = Petal.Width.mean)) +\n  geom_errorbar(aes(ymin = Petal.Width.mean - Petal.Width.sd, \n                    ymax = Petal.Width.mean + Petal.Width.sd), \n                width = 0.3)\n\n\n\n\n\n\n\n\nEste ejemplo también sirve para mostrar cómo podemos distribuir variables indicadas en aes(), no sólamente en el inicio del gráfico con la función ggplot(), sino también en particular sobre las nuevas capas gráficas añadidas. En este ejemplo, la variable x es la misma para todas las capas (la barra y la barra de error), por lo que se la indica en la función principal, y dicha variable vale para todos las capas subsiguientes del gráfico. Luego, para geom_col(), indicamos la variable y asociada al promedio calculado. Finalmente, definimos máximos y mínimos de la barra de error dentro de aes() de geom_errorbar(), con los argumentos específicos ymin y ymax.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#asignación-de-gráficos-a-objetos",
    "href": "dia4/6.2_ggplot2.html#asignación-de-gráficos-a-objetos",
    "title": "Introducción a gráficos con ggplot2",
    "section": "Asignación de gráficos a objetos",
    "text": "Asignación de gráficos a objetos\nLos gráficos de ggplot2 pueden asignarse a objetos. La ventaja de ello es que el nuevo objeto creado queda guardado en el entorno, y el gráfico puede personalizarse en el futuro haciendo referencia al objeto creado.\n\nplot1 &lt;- ggplot(iris, aes(x = Petal.Width))\n\nAquí, al objeto plot1 le es asignado a un gráfico que aún no posee capas gráficas, pero sí posee una tabla asociada y una variable x asociada a una columna de esa tabla. Podemos hacer uso del nuevo objeto y el operador + para añadir nuevas capas y personalizaciones al gráfico:\n\nplot1 &lt;- plot1 + \n  geom_histogram() +\n  theme_bw()\n\nEl gráfico puede ser mostrado en el panel simplemente llamando al objeto:\n\nplot1\n\n\n\n\n\n\n\n\nEn ggplot2, los histogramas son generados mediante la función geom_histogram().\nUna de las ventajas de asignar gráficos a objetos es que, una vez creado el objeto, es posible trabajar en otras tareas asociadas para obtener alguna información relevante, que será luego utilizada para continuar personalizando el gráfico.\nUna situación común del flujo de trabajo de nuestras investigaciones consiste en generar un panel de gráficos de manera automática, sin recurrir a software externos a R. Por ejemplo, además del objeto plot1, creemos otros tres gráficos similares pero con otras variables:\n\nplot2 &lt;- ggplot(iris, aes(x = Petal.Length)) +\n  geom_histogram() +\n  theme_bw()\n\nplot3 &lt;- ggplot(iris, aes(x = Sepal.Width)) +\n  geom_histogram() +\n  theme_bw()\n\nplot4 &lt;- ggplot(iris, aes(x = Sepal.Length)) +\n  geom_histogram() +\n  theme_bw()\n\nPara crear un panel con ggplot2, la función par() utilizada para gráficos nativos de R no nos servirá. Existen otras funciones asociadas que permiten hacerlo, entre ellas, la función ggarrange() del paquete egg:\n\nlibrary(egg)\nggarrange(plot1, plot2, plot3, plot4, ncol = 2, nrow = 2)\n\n\n\n\n\n\n\n\nSimplemente se indican los objetos asociados a los gráficos, junto con la cantidad de columnas y filas, como si fuera una matriz con espacios vacíos a ser rellenados por cada gráfico (aquí, una matriz de 2x2).\nLa función ggarrange() del paquete egg es una de muchas formas de generar paneles con gráficos de ggplot2. También podemos mencionar a la función plot_grid() del paquete cowplot y a grid.arrange() del paquete gridExtra.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#exportación-de-gráficos",
    "href": "dia4/6.2_ggplot2.html#exportación-de-gráficos",
    "title": "Introducción a gráficos con ggplot2",
    "section": "Exportación de gráficos",
    "text": "Exportación de gráficos\nExisten varias formas de exportar los gráficos de ggplot2. Una de ellas es a través de la interfaz gráfica de RStudio, en el panel de gráficos. Otra opción es encerrar el bloque de código de la siguiente manera, y correr todo el bloque a la vez, bloque de código que también es válido para gráficos en R base:\n\npng(filename = \"dia4/scatterplot.png\", width = 1200, height = 1000, res = 300)\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\ndev.off()\n\nComo podemos observar, entre otros argumentos, es posible indicar el ancho, largo y la resolución (en ppi). Otras alternativas a png() son jpeg() y tiff().\nOtra alternativa es utilizar la función ggsave(), por ejemplo:\n\nggsave(filename = \"dia4/scatterplot.png\", dpi = 600, units = \"px\")\n\nAl no especificar qué gráfico exportar, se exporta el último gráfico devuelto en el panel de gráficos. De lo contrario, es posible indicar explícitamente qué gráfico exportar:\n\nplot5 &lt;- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  theme(aspect.ratio = 3/4)\n\nggsave(filename = \"scatterplot.png\", plot = plot5, dpi = 600, units = \"px\")",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#ejercicios",
    "href": "dia4/6.2_ggplot2.html#ejercicios",
    "title": "Introducción a gráficos con ggplot2",
    "section": "Ejercicios",
    "text": "Ejercicios\nEl dataset Indometh contiene los datos de concentración en sangre de una droga en función del tiempo para 6 sujetos (para mayor información sobre el dataset, explore la ayuda con ?Indometh). Antes que nada, explore el dataset, su estructura y tipo de dato.\n\nGenere un gráfico de líneas que relacione la concentración de la droga en sangre en función del tiempo, pero diferencie las tendencias entre sujetos con colores diferentes de líneas. Incremente el grosor de cada línea lo que considere suficiente. Indique el título “(a)” para el gráfico. Coloque nombres, en español, a los ejes y a la leyenda. Inserte una línea vertical discontinua pasando por el valor x = 1. Establezca la relación de aspecto en 9/16.\n\nLos niveles de la columna “Subject” están desordenados. ¿Por qué? Arreglar eso!\n\nGenere un gráfico relacionando las mismas variables que el anterior, pero haciendo un zoom a una región particular del gráfico. Para ello, el código será casi idéntico al gráfico anterior, pero además deberá utilizar la función coord_fixed(), en donde deberá indicar la región del gráfico de interés (explore ?coord_fixed sobre cómo hacer esto). La región donde hará zoom será la de mayor variación de cambio entre la concentración de la droga en sangre y el tiempo. Indique el título “(b)” para el gráfico.\nGenere un panel con los gráficos anteriores, a la izquierda el gráfico del punto 1 y a la derecha el del punto 2. El panel, al estar compuesto por gráficos individuales, posiblemente contenga información redundante: el nombre para el eje vertical y la leyenda (está repetida). No es necesario repetir la información. Arreglar eso!\nExporte el panel gráfico con una resolución de 300 ppi dentro de la carpeta “dia4” del proyecto del curso. Para ello, explore ?png.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gráficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html",
    "href": "dia1/3.1_Operadores.html",
    "title": "Objetos y operadores",
    "section": "",
    "text": "Como ya vimos anteriormente, R es un lenguaje orientado a objetos y existe una gran variedad de “cosas” que estos objetos pueden contener/almacenar. En general, los objetos que presentamos a continuación permiten realizar la mayoría de las tareas cotidianas en R.\n\n\n\n\n\n\n\nObjeto\nDescripción\n\n\n\n\nvector\nColección de objetos de un mismo tipo (números enteros, números reales, texto, etc.). Los vectores son los objetos básicos a partir de los cuales pueden crearse gran parte del resto de los objetos más relevantes en R.\n\n\ndata.frame\nTabla que contiene datos, conformada por una serie de columnas como vectores. Las columnas de un data.frame pueden ser vectores de distinto tipo. Generalmente, estos objetos son cargados por el usuario a partir de un archivo, pero también pueden ser creados con la función data.frame().\n\n\nmatrix\nColección de vectores organizado en filas y columnas. A diferencia de un data.frame, es un objeto que permite operaciones matemáticas propias de las matrices (e.g., suma o producto de matrices).\n\n\nlist\nEs una coleccion de objetos de cualquier tipo, sean vectores, tablas, matrices, otras listas y más. Gran parte de las salidas de las funciones de R son listas, por ejemplo, la salida de un modelo lineal con la funcion lm().",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html#objetos-comunes-en-r",
    "href": "dia1/3.1_Operadores.html#objetos-comunes-en-r",
    "title": "Objetos y operadores",
    "section": "",
    "text": "Como ya vimos anteriormente, R es un lenguaje orientado a objetos y existe una gran variedad de “cosas” que estos objetos pueden contener/almacenar. En general, los objetos que presentamos a continuación permiten realizar la mayoría de las tareas cotidianas en R.\n\n\n\n\n\n\n\nObjeto\nDescripción\n\n\n\n\nvector\nColección de objetos de un mismo tipo (números enteros, números reales, texto, etc.). Los vectores son los objetos básicos a partir de los cuales pueden crearse gran parte del resto de los objetos más relevantes en R.\n\n\ndata.frame\nTabla que contiene datos, conformada por una serie de columnas como vectores. Las columnas de un data.frame pueden ser vectores de distinto tipo. Generalmente, estos objetos son cargados por el usuario a partir de un archivo, pero también pueden ser creados con la función data.frame().\n\n\nmatrix\nColección de vectores organizado en filas y columnas. A diferencia de un data.frame, es un objeto que permite operaciones matemáticas propias de las matrices (e.g., suma o producto de matrices).\n\n\nlist\nEs una coleccion de objetos de cualquier tipo, sean vectores, tablas, matrices, otras listas y más. Gran parte de las salidas de las funciones de R son listas, por ejemplo, la salida de un modelo lineal con la funcion lm().",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html#operadores",
    "href": "dia1/3.1_Operadores.html#operadores",
    "title": "Objetos y operadores",
    "section": "Operadores",
    "text": "Operadores\nUn operador es una expresión, compuesta por uno o más símbolos, que realiza una operación específica sobre uno o más valores para producir un resultado.\n\nOperadores aritméticos\nRelacionan dos números para generar un resultado.\n\n\n\nSímbolo\nOperación\n\n\n\n\n+\nSuma\n\n\n-\nResta\n\n\n*\nMultiplicación\n\n\n/\nDivisión\n\n\n^\nPotenciación\n\n\n%/%\nDivisión entera\n\n\n%%\nResto de la división\n\n\n\nPor ejemplo:\n\n5 + 7\n\n[1] 12\n\n\n\n3^4\n\n[1] 81\n\n\nEl uso de paréntesis muchas veces es necesario:\n\n3^(4+3)\n\n[1] 2187\n\n\n\n10 %/% 3\n\n[1] 3\n\n\n\n10 %% 3\n\n[1] 1\n\n\n\n\nOperadores relacionales\nRelacionan un valor con otro y devuelven una constante lógica (TRUE o FALSE).\n\n\n\nSímbolo\nOperación\n\n\n\n\n&lt;\nMenor a…\n\n\n&lt;=\nMenor o igual a..\n\n\n&gt;\nMayor a…\n\n\n&gt;=\nMayor o igual a…\n\n\n==\nIgual a…\n\n\n!=\nDistinto de…\n\n\n\nPor ejemplo:\n\n8 &gt; 9\n\n[1] FALSE\n\n\n\n8 &gt;= 9\n\n[1] FALSE\n\n\n\n5 == 5\n\n[1] TRUE\n\n\n\n12 != 12\n\n[1] FALSE\n\n\n\n\nOperadores lógicos o booleanos\n\n\nEstos operadores devuelven una constante lógica (TRUE o FALSE).\n\n\n\nSímbolo\nOperación\n\n\n\n\n!\nNegación\n\n\n&\nY\n\n\n&&\nY secuencial\n\n\n|\nO\n\n\n||\nO secuencial\n\n\nxor\nUnión excluyente\n\n\n\n\n\n\n\nGeorge Boole, matemático inglés. En su honor, los operadores\nlógicos también se llaman “booleanos”.\n\n\n\n\nPara entender cómo funcionan estos operadores las tablas de verdad son útiles. Aquí, aprenderemos el comportamiento de estos operadores mediante ejemplos.\nEl operador ! devuelve el resultado opuesto de una expresión lógica dada:\n\n!(10 &gt; 5)\n\n[1] FALSE\n\n\nEl operador & (Y) combina dos o más expresiones, y devuelve TRUE sólo si todas las expresiones lógicas son verdaderas:\n\n(10 &gt; 5) & (30 &gt; 20)\n\n[1] TRUE\n\n\nEn cambio, devuelve FALSE si alguna de ellas no es verdadera:\n\n(10 &gt; 5) & (30 &gt; 40)\n\n[1] FALSE\n\n\nEl operador | (O) combina dos o más expresiones, y devuelve TRUE si al menos una de las expresiones lógicas son verdaderas:\n\n(10 &gt; 5) | (30 &gt; 40)\n\n[1] TRUE\n\n\nEn cambio, devuelve FALSE si ninguna de las expresiones son verdaderas:\n\n(10 &gt; 15) | (30 &gt; 40)\n\n[1] FALSE\n\n\nEl operador xor es en realidad una función con dos argumentos. Sólo devuelve TRUE cuando una condición es verdadera y la otra es falsa:\n\nxor(10 &gt; 5, 30 &gt; 40)\n\n[1] TRUE\n\n\nEn cambio, devuelve FALSE cuando ambas expresiones son verdaderas:\n\nxor(10 &gt; 5, 30 &gt; 20)\n\n[1] FALSE\n\n\nO ambas son falsas:\n\nxor(10 &gt; 15, 30 &gt; 40)\n\n[1] FALSE\n\n\nLos operadores && y || trabajan secuencialmente, sólo evalúan la segunda condición si la primera es TRUE. Si la primera condición ya es FALSE, no se evalúa la segunda condición. Adquieren mayor sentido cuando el segundo elemento de la comparación no está definido, y suele utilizarse en contextos de programación más avanzada. Por ejemplo:\n\na &lt;- 5\na &lt; 3 && b &gt; 10\n\n[1] FALSE\n\n\nAquí vemos que el objeto b no existe en el ambiente de R. Sin embargo, el resultado es FALSE porque la primera condición ya es falsa. Si hiciéramos la misma comparación con &, R devuelve un error:\n\na &lt;- 5\na &lt; 3 & b &gt; 10\n\nError: objeto 'b' no encontrado\n\n\nVeamos un ejemplo similar con el operador ||:\n\na &lt;- 5\na &gt; 3 || b &gt; 10\n\n[1] TRUE\n\n\nEl resultado es TRUE, porque la primera condición ya es verdadera. El mismo código con | arroja un error:\n\na &lt;- 5\na &gt; 3 | b &gt; 10\n\nError: objeto 'b' no encontrado\n\n\nLas funciones all() y any() permiten evaluar más de una condición simultáneamente. La función all() devuelve TRUE si todas las condiciones indicadas son verdaderas, caso contrario devuelve FALSE. Su comportamiento es análogo al operador & utilizado secuencialmente. Las condiciones se escriben de a una y separadas por coma. Por ejemplo:\n\na &lt;- 5\nb &lt;- 10\nc &lt;- 15\nall(a &gt; 3, b &gt; 8, c &gt; 11)\n\n[1] TRUE\n\n\nTodas las condiciones son verdaderas, por lo que devuelve TRUE. Si en cambio al menos una es falsa, obtenemos FALSE:\n\nall(a &gt; 3, b &gt; 8, c &gt; 21)\n\n[1] FALSE\n\n\nLa función any() devuelve TRUE si al menos una condición es verdadera. Su comportamiento es análogo al operador | utilizado de manera secuencial. Por ejemplo:\n\nany(a &gt; 7, b &gt; 12, c &gt; 13)\n\n[1] TRUE\n\n\nEn cambio, si todas las condiciones son falsas, any() devuelve FALSE:\n\nany(a &gt; 7, b &gt; 12, c &gt; 23)\n\n[1] FALSE",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html#ejercicios",
    "href": "dia1/3.1_Operadores.html#ejercicios",
    "title": "Objetos y operadores",
    "section": "Ejercicios",
    "text": "Ejercicios\n\nLa variable y puede calcularse mediante la siguiente fórmula:\n\n\\[ \\hspace{-9cm} y = a + b\\sqrt{x+2} + cx^2 \\]\nSiendo a = 5.3, b = 3.2 y c = 1.7, calcule el valor de y cuando x = 20.\n\nSin correr las siguientes líneas, ¿cuál es el resultado de cada expresión?\n\n\nx &lt;- 10\ny &lt;- 90\n\n(x &lt;= 10) & (y &gt; 40)\n(x == 10) | (y == 89)\n((x &gt; 5) & (y != 70)) & (x*y &gt; 1000)\n\n\n¿Qué hacen las funciones round(), floor(), ceiling() y trunc()?\n\n\nround(x = 6.756)\nround(6.756, digits = 2)\ntrunc(6.756)\nceiling(6.356)\nfloor(x = 6.756)",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html",
    "href": "dia1/1.2_UsandoR.html",
    "title": "Primeros pasos con R y RStudio",
    "section": "",
    "text": "R puede ser utilizado de forma interactiva iniciándolo directamente de cualquier terminal de BASH (en sistemas UNIX-like), o desde el “Simbolo del sistema” o haciendo doble click en el ejecutable típicamente localizado en “C:\\Program Files\\R\\R-version\\bin\\x64\\” (en sistemas Windows). Por ejemplo en cualquier distribución GNU/Linux, bastará con abrir la terminal e ingresar el comando “R”.\n\n Click en la imagen para agrandar.\n\nCuando R es iniciado de esa forma, veremos un texto con una pequeña presentación de R, incluyendo la versión que se está ejecutando y algunas ayudas básicas. Luego de este texto, vemos una linea vacía comenzada por el carácter &gt;. Este último carácter se conoce como prompt y nos indica que R está listo para recibir órdenes. Así pues, podríamos pedir que nos imprima una bienvenida al curso utilizando la función print(), haciendo por ejemplo:\n\nprint(\"Bienvenides al curso!!!\")\n\n\n Click en la imagen para agrandar.\n\nAún funcionando desde un CLI, sin una interfaz gráfica, debido a que R está pensado para funcionar en sistemas de ventanas, es posible realizar gráficos y estos se mostraran en una nueva ventana exclusivamente creada para tal fin. Podríamos por ejemplo graficar 3 puntos de diferentes colores, ubicados en las coordenadas (x,y)=(1,1 ; 2,1 ; 3,1):\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n Click en la imagen para agrandar.\n\nComo al usar R de esta forma solo podremos ir ejecutando de a una orden a la vez, puede ser conveniente disponer de algún editor de texto plano para poder ir guardando nuestro código a medida que lo vamos escribiendo y ejecutando. Para ello podemos utilizar cualquier editor de texto plano (e.g., en GNU/Linux podemos usar “gedit” o el editor que traiga nuestra distribución; en Windows podemos utilizar “Bloc de Notas”, “Notepad++”, etc). Aprovechando el espacio del escritorio de nuestra PC podríamos entonces hacer una disposición con las ventanas abiertas de nuestra terminal donde ejecutamos R, la ventana gráfica donde se mostrarán nuestros gráficos, el archivo de texto plano con nuestro código y podríamos sumar también una ventana con las carpetas donde estamos guardando el trabajo y desde donde leeremos los datos que cargaremos a R. Algo parecido a lo siguiente:\n\n Click en la imagen para agrandar.\n\nFinalmente, si deseamos salir de la sesión de R activa, podemos utilizar la función quit() (o su forma abreviada q()), a lo que R responderá preguntando si queremos guardar una imagen del espacio de trabajo, a lo que responderemos que NO ingresando n. Esto cerrara cualquier ventana gráfica que hubiera abierta, así como en nuestra terminal veremos que el prompt vuelve a ser el de nuestro sistema.\n\n\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#cómo-se-usa-r",
    "href": "dia1/1.2_UsandoR.html#cómo-se-usa-r",
    "title": "Primeros pasos con R y RStudio",
    "section": "",
    "text": "R puede ser utilizado de forma interactiva iniciándolo directamente de cualquier terminal de BASH (en sistemas UNIX-like), o desde el “Simbolo del sistema” o haciendo doble click en el ejecutable típicamente localizado en “C:\\Program Files\\R\\R-version\\bin\\x64\\” (en sistemas Windows). Por ejemplo en cualquier distribución GNU/Linux, bastará con abrir la terminal e ingresar el comando “R”.\n\n Click en la imagen para agrandar.\n\nCuando R es iniciado de esa forma, veremos un texto con una pequeña presentación de R, incluyendo la versión que se está ejecutando y algunas ayudas básicas. Luego de este texto, vemos una linea vacía comenzada por el carácter &gt;. Este último carácter se conoce como prompt y nos indica que R está listo para recibir órdenes. Así pues, podríamos pedir que nos imprima una bienvenida al curso utilizando la función print(), haciendo por ejemplo:\n\nprint(\"Bienvenides al curso!!!\")\n\n\n Click en la imagen para agrandar.\n\nAún funcionando desde un CLI, sin una interfaz gráfica, debido a que R está pensado para funcionar en sistemas de ventanas, es posible realizar gráficos y estos se mostraran en una nueva ventana exclusivamente creada para tal fin. Podríamos por ejemplo graficar 3 puntos de diferentes colores, ubicados en las coordenadas (x,y)=(1,1 ; 2,1 ; 3,1):\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n Click en la imagen para agrandar.\n\nComo al usar R de esta forma solo podremos ir ejecutando de a una orden a la vez, puede ser conveniente disponer de algún editor de texto plano para poder ir guardando nuestro código a medida que lo vamos escribiendo y ejecutando. Para ello podemos utilizar cualquier editor de texto plano (e.g., en GNU/Linux podemos usar “gedit” o el editor que traiga nuestra distribución; en Windows podemos utilizar “Bloc de Notas”, “Notepad++”, etc). Aprovechando el espacio del escritorio de nuestra PC podríamos entonces hacer una disposición con las ventanas abiertas de nuestra terminal donde ejecutamos R, la ventana gráfica donde se mostrarán nuestros gráficos, el archivo de texto plano con nuestro código y podríamos sumar también una ventana con las carpetas donde estamos guardando el trabajo y desde donde leeremos los datos que cargaremos a R. Algo parecido a lo siguiente:\n\n Click en la imagen para agrandar.\n\nFinalmente, si deseamos salir de la sesión de R activa, podemos utilizar la función quit() (o su forma abreviada q()), a lo que R responderá preguntando si queremos guardar una imagen del espacio de trabajo, a lo que responderemos que NO ingresando n. Esto cerrara cualquier ventana gráfica que hubiera abierta, así como en nuestra terminal veremos que el prompt vuelve a ser el de nuestro sistema.\n\n\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-1",
    "href": "dia1/1.2_UsandoR.html#ejercicio-1",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nAbra R desde una terminal de su sistema operativo e intente replicar las líneas de código mostradas en la parte previa, de paso, sabremos que su sistema tiene correctamente instalado R.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#presentando-a-rstudio",
    "href": "dia1/1.2_UsandoR.html#presentando-a-rstudio",
    "title": "Primeros pasos con R y RStudio",
    "section": "Presentando a RStudio",
    "text": "Presentando a RStudio\nA pesar de lo sencillo que resulta usar R nativamente en cualquier sistema, para ahorrarnos tener que usar múltiples programas en simultáneo, así como para sumar toda una gran colección de funcionalidades y herramientas que nos facilitarán mucho el trabajo, es recomendable utilizar R en conjunto con alguna IDE. En este curso, utilizaremos RStudio.\n\n Click en la imagen para agrandar.\n\nEn la figura precedente podemos identificar rápidamente las principales áreas de trabajo con diferentes funcionalidades que nos ofrece el programa (estos paneles pueden maximizarse, minimizarse o redimensionarse a gusto con el puntero del mouse, así como personalizarse en “Tools &gt; Global Options &gt; Pane Layout”):\n\n\nConsola: una consola de R equivalente a la que iniciamos previamente y con la misma funcionalidad.\n\n\nFuente: equivalente al editor de texto plano (este panel puede no abrirse por defecto si todavía no creamos ninguna rutina, para ello hacer “File &gt; New File &gt; R Script” o click en el botón  [a])\n\n\nEntorno: muestra todos los objetos creados ordenados por tipo, permite la carga de dataset gráficamente y la gestión de la memoria en uso.\n\n\nArchivos, Gráficos, Paquetes, Ayuda: esta es una área de mucho uso ya que permite ver y manipular el sistema de archivos dónde estamos trabajando [b], así como gestionar los paquetes de R gráficamente [c]. Además, cambiará automáticamente al área gráfica cuando realicemos un gráfico [d] y cambiará a las ayudas internas disponibles en caso de solicitarlo [e].\n\n\nCuando tengamos una rutina (i.e. un script) creada, podremos ejecutar directamente desde la misma el código sin necesidad de “copiar y pegar” en la consola de R. Para ello, con el cursor de texto sobre la linea de código podemos utilizar el botón  Run ubicado en el sector superior derecho del panel Fuente, o utilizar el atajo de teclado Ctrl + Enter. Esto mismo podemos hacerlo sobre varias líneas, seleccionando con el cursor todas aquellas líneas que querramos ejecutar.\nPara prestar atención: un script no es más que una serie ordenada de órdenes que se ejecutan una tras otra. Por defecto, siempre que ejecutemos un script completo, no importa si lo hacemos línea a línea o seleccionado todo el conjunto, la ejecución subyacente es secuencial. Para romper este comportamiento existen estructuras especiales conocidas como “Estructuras de control de flujo”, que estudiaremos más adelante.\nPara pensar: en el ejemplo de la figura previa existen líneas que comienzan con un carácter # (llamado de muchas formas: numeral, almohadilla, hashtag). Si presta atención, esas líneas están coloreadas de forma homogénea en el editor y, además, aparentan tener mensajes que explican el código. ¿Qué imagina que sucede cuando se ejecutan? ¿Cómo se llama y qué función cumplen esas líneas? Más adelante veremos otra forma adicional de utilizarlas para organizar nuestro código en RStudio.\n\nProyectos en RStudio\nUna de las primeras nociones sobre las buenas prácticas de trabajo es intentar mantener una organización coherente de nuestro código, así como de los archivos de entrada (i.e. los datos) y salida (i.e. resultados, gráficos, etc). Aunque estrictamente no existe una forma única ni correcta de organización y cada persona debe encontrar lo que le resulta más práctico, siempre debemos considerar que existen potenciales receptores de nuestro código que idealmente tendrían que interpretar con el menor esfuerzo posible la organización seguida. Incluso podemos ser nosotros mismos quienes en un futuro revisitemos algo que hicimos hace un tiempo y le estaremos enormemente agradecidos a nuestra versión del pasado por haber mantenido una organización coherente.\nCuando trabajamos con RStudio, esto último puede ser muy sencillo de realizar utilizando los proyectos, que no son otra cosa más que una forma de mantener nuestro trabajo en un contexto dado, con su propio directorio de trabajo, historial, rutinas, entradas, salidas, etc. De esta forma, pensemos por ejemplo en una organización con una estructura hipotética similar a la siguiente:\n\n\nAnalisisTesis\n  |\n  |-- CapII\n  |     |\n  |     |-- datos\n  |     |     |-- muestreoEne-Mar.csv\n  |     |     |-- muestreoAgo-Oct.csv\n  |     |      \n  |     |--resultados\n  |     |     |-- diversidad.txt\n  |     |     |-- composicion.txt\n  |     |     |-- graficos\n  |     |            |-- fig_div_estacion.pdf\n  |     |            |-- fig_NMDS.pdf\n  |     |\n  |     |-- analisis\n  |           |-- exploratorios.R\n  |           |-- anova.R\n  |           |-- NMDS.R\n  |-- CapIII\n  |     |\n  |    ...\n ...\nEn este caso, podríamos entonces pensar en crear un proyecto para todo el conjunto de “AnalisisTesis” o podemos subdividir y crear un proyecto por cada capítulo que requiera realizar algun tipo de análisis. De nuevo, no hay una manera única, todo dependerá del contexto y lo que resulte -o parezca resultar- óptimo en cada situación.\nExisten múltiples formas de crear un nuevo proyecto. Podemos hacer “File &gt; New Project…”; podemos usar el botón  en la esquina superior izquierda; o utilizar el menú de proyectos  Project: (None), situado en la esquina superior derecha. A la hora de crear un nuevo proyecto, podemos elegir partir de un directorio nuevo o de uno previamente creado. Así mismo, podemos elegir un tipo específico de proyecto según si estemos haciendo un proyecto general, un proyecto para un nuevo paquete de R, una aplicación Shiny, etc. Todo esto se realiza mediante una serie de menús gráficos que se nos irán presentado y que son sumamente intuitivos de seguir.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-2",
    "href": "dia1/1.2_UsandoR.html#ejercicio-2",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nLuego de ver la demostración del docente sobre la creación de proyectos en RStudio, abra una sesión propia de RStudio y cree un proyecto para este curso. La organización sugerida es la siguiente:\nfundamentosR\n  |\n  |-- fundamentosR.Rproj\n  |-- dia1\n  |     |-- mi_rutinaR.R\n  |\n  |--dia2\n  |--dia3\n ...\nA medida que el curso avance, iremos completando estos directorios con datos, rutinas, etc.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-3",
    "href": "dia1/1.2_UsandoR.html#ejercicio-3",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nCree una rutina dentro de dia1, como se muestra en la estructura precedente, que contenga el código ejecutado en el Ejercicio 1 para el mensaje de bienvenida y el gráfico. Corra esas líneas y explore las funciones del panel gráfico. Finalmente, guarde el mismo como un archivo PNG dentro del directorio dia1.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#el-directorio-de-trabajo",
    "href": "dia1/1.2_UsandoR.html#el-directorio-de-trabajo",
    "title": "Primeros pasos con R y RStudio",
    "section": "El directorio de trabajo",
    "text": "El directorio de trabajo\nCuando trabajamos con R, implícitamente lo estamos haciendo en alguna ubicación de nuestro sistema de archivos. Los proyectos de RStudio facilitan esta cuestión haciendo que el directorio de trabajo sea aquel en el cual creamos el proyecto. Para conocer en donde estamos trabajando, podemos utilizar la función getwd(). Por ejemplo, mientras escribo esta guía puedo ver en qué ubicación se encuentra el proyecto en la cual la estoy realizando (Sí! R es tan versátil, que hasta podemos crear páginas web y cualquier otro tipo de documento con su propio formato, imágenes embebidas, vínculos de internet, etc.):\n\ngetwd()\n\n[1] \"/home/usuario/cursoR/repos/fundamentos_R/dia1\"\n\n\nSi por algun motivo deseara cambiar el directorio de trabajo, puedo hacerlo desde el menú “Session &gt; Set Working Directory &gt; Choose Directory” o, de forma más sencilla, utilizar la función setwd():\n\n# setwd(\"/home/usuario/R/mi_proyecto_de_R\") # ejecución sin salida en consola\n# getwd() # muestra el nuevo working directory\n# setwd(\"/home/usuario/cursoR/clases/1_2_usandoR/\") # regreso al original\n# getwd() # muestra el nuevo working directory\n\n\nRutas relativas y absolutas\nUna ruta (en inglés path) en R o en cualquier otro sistema informático es la “dirección” de cada archivo que existe en el sistema de archivos. De forma general, existen dos formas de representar a cualquier ruta:\n\nLas rutas absolutas son aquellas en las que explícitamente se indica todo el trayecto realizado desde la ráiz del sistema hasta la ubicación en cuestión. En los sistemas GNU/Linux, la raíz del sistema es / (llamado root); mientras que en los sistemas Windows será el origen del disco que este utilizándose, típicamente C:\\. Teniendo esto en cuenta, la ruta anterior al directorio de trabajo es una ruta absoluta, ya que en la misma se explicita toda la ruta desde la raíz hasta el archivo.\nLas rutas relativas por su parte, nos muestran la ubicación de un archivo o directorio en sentido relativo al directorio de trabajo activo. Generalmente, las mismas empiezan con uno o dos caracteres de punto “.”, teniendo la expresión ./ el significado literal de “en este directorio”, es decir, en el directorio actual; mientras que la expresión ../ indica el directorio superior en la jerarquía del directorio actual. Tener en cuenta que en sistemas Windows, el caracter que separa directorios es la “barra inversa”, por lo que en esos sistemas será: .\\ y ..\\.\n\nComo ejemplo, tomando como referencia la estructura sugerida para el proyecto de los analisis de la tesis, si el directorio de trabajo activo fuera analisis dentro de CapII, la ruta relativa a CapIII seria ../../CapIII",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-4",
    "href": "dia1/1.2_UsandoR.html#ejercicio-4",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nImagine que dentro del directorio /home/usuario/Documentos, posee la siguiente estructura de directorios:\ncarpeta0/\n├── archivo0_a\n├── archivo0_b\n├── carpeta1\n│  ├── archivo1_a\n│  ├── archivo1_b\n│  └── archivo1_c\n└── carpeta2\n    ├── archivo2_a\n    ├── archivo2_b\n    └── carpeta2a\n        ├── archivo2a_a\n        └── carpeta2b\n            └── archivo2b_a     \n\n¿Cuál sería la ruta absoluta al archivo “archivo1_c”?\n\n\nSu respuesta:  OK\n\n\n\n\n\n¿Cómo sería la ruta relativa desde el directorio “carpeta2b” hacia el archivo “archivo1_c”?\n\n\nSu respuesta:  OK",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#las-rutas-en-los-proyectos-de-rstudio",
    "href": "dia1/1.2_UsandoR.html#las-rutas-en-los-proyectos-de-rstudio",
    "title": "Primeros pasos con R y RStudio",
    "section": "Las rutas en los proyectos de RStudio",
    "text": "Las rutas en los proyectos de RStudio\nCuando trabajamos dentro de un proyecto de RStudio, todas las rutas son relativas a la raíz del proyecto. Esto tiene algunas ventajas, como por ejemplo si compartimos nuestro proyecto con colaboradores, estos no necesitarán configurar las rutas para su sistema, ya que las rutas se mantienen relativas al proyecto. Por otro lado, no es necesario que anonimicemos nuestras rutas, ya que si trabajamos exclusivamente dentro de la carpeta raíz del proyecto, no debería aparecer ninguna ruta absoluta. Las razones por las que quisiéramos mantener nuestras otras carpetas internas privadas son muchas, y variarán en cada caso, pero para un ejemplo interesante podemos considerar el siguiente caso:\n\n Click en la imagen para agrandar.\n\nPor cierto, Alexandra es, ni más ni menos, la creadora del sitio Sci-Hub y esa captura corresponde a una guía básica para voluntarias/os de Anna’s Archive.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#buscando-ayuda-en-r",
    "href": "dia1/1.2_UsandoR.html#buscando-ayuda-en-r",
    "title": "Primeros pasos con R y RStudio",
    "section": "Buscando ayuda en R",
    "text": "Buscando ayuda en R\nUna de las cosas que más intimidan a quienes intentan aprender un lenguaje de programación suele ser intentar recordar el nombre de todas las funciones disponibles y cómo se usa exactamente cada una. Pero lo cierto es que esto rara vez preocupa a quienes llevan un tiempo inmersos en algún lenguaje. Esto es así, ya que como el resto de los lenguajes más populares, R posee un compendio de documentación interna que explica detalladamente cada una de sus funciones. Esta ayuda se encuentra disponible desde la instalación de R, así como de cada uno de los paquetes oficiales, y puede ser consultada incluso fuera de línea (i.e. sin conexión a internet).\nExisten múltiples formas de consultar esta documentación. Si nos encontramos trabajando directamente desde una consola de R, podremos invocar la ayuda con la función help(funcion), donde funcion es el nombre de la función o el objeto sobre el que estamos requiriendo la documentación. Por ejemplo, con la formula help(help) podemos obtener la ayuda de la función de ayuda:\n\n Click en la imagen para agrandar.\n\nAsí mismo, disponemos de una versión corta de la función previa, que es la función ?funcion y en caso de que queramos buscar con una palabra clave, ya que no recordamos siquiera el nombre de la función o paquete, podemos utilizar ??palabraclave.\nEn RStudio, como ya mencionamos antes, disponemos de un área específica para mostrar la ayuda. Está área se activará automáticamente al solicitar alguna ayuda, e incluso disponemos de una función de autocompletado con ayudas en ventanas emergentes. Para activarla, solo debemos comenzar a escribir el nombre de la función y apretar la tecla Tab ↹. En la siguiente figura, podemos ver que sucede al comenzar a escribir “me + Tab ↹”:\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-5",
    "href": "dia1/1.2_UsandoR.html#ejercicio-5",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nEn RStudio corra las siguientes líneas de a una y observe que salidas le brinda el programa. Anímese a explorar, no hay nada que pueda romper, haga click aquí y allá, vaya y vuelva. De igual forma, intente utilizar el autocompletado y las ayudas emergentes, fomente su creatividad buscando lo que se le ocurra, o intente averiguar como se usa esa función que hace 2 o 3 semanas que no logra ejecutar sin error. En clase discutiremos que partes componen la ayuda y como interpretarla.\n\nhelp(help)\n?help\n??distance\n?plot\n\n\nForos y bitácoras de la comunidad\nAdemás de estas útiles ayudas offline, si contamos con una conexión a internet, por supuesto no dudaremos en hacer uso extensivo de buscadores. Muchas veces, más que saber cómo opera una función en particular, queremos conocer como realizar una acción dada, con el método que sea. Aprender a buscar es en sí mismo un arte. La cantidad de sitios con información sobre R es inabarcable y muchas veces podemos perdernos en el afán de encontrar lo que buscamos, por ello a continuación veremos algunas recomendaciones.\n\nEl idioma en que buscamos importa. Como para cualquier otra búsqueda, no encontraremos los mismos recursos si buscamos en español que si buscamos en inglés.\n\n\n Click en la imagen para agrandar.\n\n\nExisten múltiples foros que incluyen hilos específicos para R, buscar en ellos muchas veces es una forma segura de aprender como hacer algo. La única recomendación en este sentido, aunque no podemos enfatizarla lo suficiente, es que nunca debemos ejecutar código que no comprendamos. Si creemos que cierto fragmento de código nos puede ser útil, primero intentemos entenderlo con un ejemplo de juguete, en una sesión nueva, lejos de nuestros scripts de los análisis en curso. Cuando pensemos que hemos podido entender como funciona, entonces ya estamos listos para trasladar ese código a nuestro script. Si no encontramos la respuesta al problema específico que tenemos, en estos foros también podemos realizar una pregunta y nos responderán bastante rápido. La clave es poder expresar concretamente el problema, el resultado esperado y, en la medida de lo posible, brindar un conjunto de datos mínimo que sirva de ejemplo al que realmente queremos procesar. A continuación un ejemplo de Stack Overflow\n\n\n Click en la imagen para agrandar.\n\n\nAdemas de los foros, existe una cantidad inmensa de artículos en sitios webs dedicados a R, así como en blogs personales. Muchas personas, que de hecho investigan en problemas similares a los nuestros, dedican mucho tiempo a publicar métodos de análisis en R, incluyendo muchas veces apartados con explicaciones teóricas sobre ciertos tópicos. Nunca está de más tomarse el tiempo para ver que encontramos. Debajo un ejemplo correspondiente a los materiales de un sitio sobre Analisis en ecologia de comunidades en R.\n\n\n Click en la imagen para agrandar.\n\n\n\nLos errores como una oportunidad de aprendizaje\nMuy frecuentemente nos encontraremos con errores en la ejecución de alguna línea. Lejos de desanimarnos y/o frustrarnos, debemos pensar que los errores son una oportunidad de aprendizaje. Los errores puede ir desde pequeños errores de tipeo, hasta la falta de memoria de cómputo para la acción requerida, pasando por operaciones imposibles de realizar o falta de argumentos obligatorios en las funciones. En cualquier caso, lo primero que debemos hacer es mantener la calma e intentar interpretar el mensaje de error. Si no logramos solucionarlo por nuestra cuenta, siempre podemos copiar el mensaje y ver que ayuda obtenemos en línea.\n\ndata(iris)\niris[iris$Sepal.Length &gt; 3]\n\nError in `[.data.frame`(iris, iris$Sepal.Length &gt; 3): columnas no definidas seleccionadas\n\n\n\n Click en la imagen para agrandar.\n\nSobre los warnings: ocasionalmente R no producirá un mensaje de error, sino una advertencia. En estos casos, también es importante que intentemos entender que está ocasionando este mensaje para saber si es algo crítico o no, sobre todo en cuanto a resultados de análisis se refiere.\n\n\nUso de IA\nOtra fuente de ayuda en los tiempos modernos, es recurrir al chatbot de inteligencia artificial de su preferencia. Una vez más, lo importante es intentar interpretar el código previo a su ejecución. En sentido estricto, podríamos darle nuestros datos a un chatbot y pedirle todos los análisis necesarios y, si supimos desmenuzar e indicar nuestra pregunta correctamente, incluso es posible que la salida sea correcta. Dicho esto, estamos aquí para aprender a hacerlo nosotros mismos, por ende, si bien es una fuente más de ayuda, el objetivo es que aunque el código lo produzca la IA, seamos capaces de entender completamente lo que está sucediendo.\nFuera de estas consideraciones, podemos preguntar directamente como hacer algo, como en el ejemplo que sigue:\n\n Click en la imagen para agrandar.\n\nO incluso podemos darle algún fragmento de código que falla, y pedirle que intente encontrar el error y explicarnos que es lo que lo esta generando:\n\n Click en la imagen para agrandar.\n\nPara pensar: más adelante aprenderemos efectivamente a filtrar una tabla basados en una condición. Recuerde la respuesta brindada por la IA en este ejemplo y veremos luego si es una “buena” respuesta.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#instalación-y-carga-de-paquetes",
    "href": "dia1/1.2_UsandoR.html#instalación-y-carga-de-paquetes",
    "title": "Primeros pasos con R y RStudio",
    "section": "Instalación y carga de paquetes",
    "text": "Instalación y carga de paquetes\nA medida que usemos R nos surgirá la necesidad de instalar paquetes por fuera de la versión básica, para añadir funcionalidades extras a R. Esto se puede realizar sencillamente desde RStudio, ya sea utilizando la interfaz gráfica o con funciones especificas para la instalación; así como podemos realizar la instalación desde CRAN o desde repositorios externos (e.g. GitHub).\n\nInstalación desde CRAN\nLa forma más sencilla de instalar paquetes es usando la función install.packages(), indicando en el argumento de la función el nombre del paquete. Si no recordamos exactamente el nombre, podemos hacer uso de la función de autocompletado (con la tecla Tab ↹). También podemos utilizar el botón  para instalar paquetes, en el área correspondiente de RStudio. Si usamos esta última forma, se abrirá una ventana de diálogo, donde podemos indicar el nombre del paquete a instalar.\n\n\n\n\n Click en la imagen para agrandar.\n\nEs importante recordar que cuando realicemos la instalación, muchas veces será necesario instalar otros paquetes que son requeridos para que funcione correctamente el paquete que queremos usar. Estos paquetes necesarios se conocen como dependencias y por defecto R instalará todas las dependencias necesarias. En la siguiente imagen se muestra la descripción de vegan, un paquete muy popular para Ecología de Comunidades, dónde podemos ver que depende de los paquetes permutey lattice, en sus versiones mínimas 0.9 y 4.1 respectivamente, así como “importa” los paquetes MASS, cluster y mgcv.\n\n Click en la imagen para agrandar.\n\nDentro de los errores comunes que podemos encontrar tenemos:\n\nNo indicamos entre comillas el nombre del paquete. Recordar que la sintaxis correcta es install.packages(\"paquete\") y no install.packages(paquete).\nQueremos instalar múltiples paquetes sin indicar correctamente la lista de paquetes a instalar. Recordar que en ese caso sería install.packages(c(\"paquete1\", \"paquete2\", \"paquete3\")) utilizando la nomenclatura de un vector (más adelante esto tendrá sentido, no se preocupe si ahora no lo entiende).\nAlguna dependencia se encuentra en una versión anterior a la necesaria y no puede actualizarse. Esto normalmente se debe a que otro paquete la tiene fijada en una versión anterior. Se soluciona, generalmente, reiniciando la sesión de R, actualizando independientemente el paquete en cuestión y luego re-intentando la instalación del paquete objetivo. Atención: si un paquete tiende a fijar alguna dependencia en una versión dada, es posible que ese paquete sea viejo y ya no se esté manteniendo; en cuyo caso debemos evaluar si tiene sentido seguir usándolo, principalmente porque al actualizar su dependencia se generará un conflicto y ya no funcionará.\n\n\n\n\n\n\n\n\nAlguna dependencia no puede ser instalada y por ende falla la instalación del paquete objetivo. Esto puede deberse a un problema de compatibilidad entre versiones de las dependencias o de algún conflicto entre la dependencia necesaria y otra que exista (o falte) en nuestro Sistema Operativo. Muchas veces este problema se debe a que faltan los compiladores (gcc, gfortran, g++, etc) necesarios para compilar el nuevo paquete. Resolver estos conflictos puede requerir un poco de tiempo, en tanto necesitamos identificar cuál es la librería que esta generando el conflicto, pero suelen resolverse simplemente luego de haber instalado la dependencia correcta en nuestro Sistema Operativo.\n\n\n\nCargando paquetes\nPor defecto, cuando abrimos una nueva sesión de R o apenas luego de que instalamos un nuevo paquete, estos no se encuentran disponibles en la memoria de trabajo. Para que un paquete particular (y todas las funciones que este contiene), se carguen en la memoria de trabajo, debemos llamarlo usando la función library(). Así mismo, si lo deseamos podemos “descargar” un paquete a fin de liberar memoria, utilizando la función detach().\n\n# Carga de paquetes\nlibrary(\"remotes\")\n# Descarga de paquetes\ndetach(\"package:remotes\", unload = TRUE)\n\nTodo esto en RStudio también puede ser realizado simplemente tildando o destildando el paquete correspondiente en la lista de paquetes.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-6",
    "href": "dia1/1.2_UsandoR.html#ejercicio-6",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\nInstale con el medio que le sea conveniente el paquete remotes, tal como se muestra en la imagen previa. Luego use la función library() para cargarlo. Utilizando las ayudas internas de R responda: ¿para qué sirve este paquete?\n\n\nLlamando funciones de paquetes específicos\nEn ocasiones, algunas funciones puede tener igual nombre en diferentes paquetes. Por defecto, cuando llamamos a una función R intentará utilizar la función del paquete que más recientemente se haya cargado. Si deseamos referirnos a una función de un paquete específico podemos hacerlo utilizando la expresión paquete::funcion(). Por ejemplo:\n\ncar::Anova(lm(hp ~ as.factor(cyl), data = mtcars))\n\nAnova Table (Type II tests)\n\nResponse: hp\n               Sum Sq Df F value    Pr(&gt;F)    \nas.factor(cyl) 104031  2  36.177 1.319e-08 ***\nResiduals       41696 29                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nboxplot(hp ~ cyl, data = mtcars, main = \"Relación entre caballos de fuerza (hp) y nº de cilindros (cyl)\")\n\n\n\n\n\n\n\n\n\n\nInstalación desde otros repositorios\nAsí como instalamos paquetes desde CRAN, también podemos instalar paquetes directamente desde los repositorios de código en los que se encuentran. Existen múltiples paquetes que permiten interactuar con diferentes repositorios, uno de ellos es el paquete remotes que instalamos en el ejercicio previo. Si por ejemplo queremos instalar el paquete multilandr que se encuentra en este repositorio, podemos hacer:\n\n# URL al repositorio: https://github.com/phuais/multilandr\ninstall_github(repo = \"phuais/multilandr\")\nlibrary(multilandr)",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-final",
    "href": "dia1/1.2_UsandoR.html#ejercicio-final",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio Final",
    "text": "Ejercicio Final\nInstale el paquete ggplot2. Una vez instalado, cárguelo y realice algún gráfico de los ejemplos disponibles en su vignette. Finalmente, guarde el gráfico en el directorio de trabajo.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html",
    "href": "dia2/4.1_Tablas.html",
    "title": "Tablas",
    "section": "",
    "text": "La tabla será posiblemente el objeto de R más utilizado en el contexto de nuestro trabajo científico. Consiste en una estructura de datos que organiza la información en filas y columnas. Desde un punto de vista programático es útil considerar a las tablas como una colección de vectores. Consideradas de esta manera, veremos que la manipulación de las filas y columnas de una tabla es análoga a la manipulación de vectores individuales. En una tabla, cada columna es un vector, pudiendo haber vectores de distintos tipos en una misma tabla (por ejemplo, vectores numéricos y de texto).\nPara crear una tabla desde cero, en R utilizamos la clase data.frame, y una función con el mismo nombre para generarla:\n\n\n\n\n\n\n\ndf &lt;- data.frame(Especie = c(\"Algarrobo\", \"Piquillin\", \"Molle\"),\n                 Individuos = c(15, 17, 9))\n\nAquí, generamos un objeto de tipo data.frame, definiendo el nombre de cada columna e igualando cada columna a un contenido en forma de vector. Existen algunas buenas prácticas a la hora de definir los nombres de las columnas, tanto si la generamos en R o con algún software externo (Excel, Calc, Google Sheets, etc.), que nos ahorrarán dolores de cabeza en el futuro:\n\nLos nombres de las columnas no pueden comenzar con un número.\nUtilizar caracteres alfanuméricos simples. Evitar la ñ u otras letras específicas de otros idiomas.\nEvitar símbolos extraños reservados para el uso del lenguaje, tales como: !?¿$%&()@*+-&gt;&lt;{}\nEvitar el uso de tildes, comas y puntos y coma.\nEvitar el uso de espacios, y reemplazarlos por punto, guión medio o guión bajo.\n\nAl crear o cargar una tabla, veremos la tabla en el panel de entorno. Desplegando la flechita azul podemos obtener información sobre las columnas de la tabla. Además, haciendo click sobre el nombre del objeto, podemos visualizar la tabla entera en otra pestaña.\nNormalmente, las tablas se generan fuera del entorno R para ser luego importadas a R. La creación de tablas desde cero adquiere mayor relevancia para tareas mas posteriores del flujo de análisis, como veremos más adelante.\nAntes que nada, descargue el archivo zip con los datos necesarios para realizar el práctico, y extraiga los archivos dentro de una carpeta llamada “data” en el directorio “dia2” del proyecto del curso.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#creación-de-tablas-desde-cero",
    "href": "dia2/4.1_Tablas.html#creación-de-tablas-desde-cero",
    "title": "Tablas",
    "section": "",
    "text": "La tabla será posiblemente el objeto de R más utilizado en el contexto de nuestro trabajo científico. Consiste en una estructura de datos que organiza la información en filas y columnas. Desde un punto de vista programático es útil considerar a las tablas como una colección de vectores. Consideradas de esta manera, veremos que la manipulación de las filas y columnas de una tabla es análoga a la manipulación de vectores individuales. En una tabla, cada columna es un vector, pudiendo haber vectores de distintos tipos en una misma tabla (por ejemplo, vectores numéricos y de texto).\nPara crear una tabla desde cero, en R utilizamos la clase data.frame, y una función con el mismo nombre para generarla:\n\n\n\n\n\n\n\ndf &lt;- data.frame(Especie = c(\"Algarrobo\", \"Piquillin\", \"Molle\"),\n                 Individuos = c(15, 17, 9))\n\nAquí, generamos un objeto de tipo data.frame, definiendo el nombre de cada columna e igualando cada columna a un contenido en forma de vector. Existen algunas buenas prácticas a la hora de definir los nombres de las columnas, tanto si la generamos en R o con algún software externo (Excel, Calc, Google Sheets, etc.), que nos ahorrarán dolores de cabeza en el futuro:\n\nLos nombres de las columnas no pueden comenzar con un número.\nUtilizar caracteres alfanuméricos simples. Evitar la ñ u otras letras específicas de otros idiomas.\nEvitar símbolos extraños reservados para el uso del lenguaje, tales como: !?¿$%&()@*+-&gt;&lt;{}\nEvitar el uso de tildes, comas y puntos y coma.\nEvitar el uso de espacios, y reemplazarlos por punto, guión medio o guión bajo.\n\nAl crear o cargar una tabla, veremos la tabla en el panel de entorno. Desplegando la flechita azul podemos obtener información sobre las columnas de la tabla. Además, haciendo click sobre el nombre del objeto, podemos visualizar la tabla entera en otra pestaña.\nNormalmente, las tablas se generan fuera del entorno R para ser luego importadas a R. La creación de tablas desde cero adquiere mayor relevancia para tareas mas posteriores del flujo de análisis, como veremos más adelante.\nAntes que nada, descargue el archivo zip con los datos necesarios para realizar el práctico, y extraiga los archivos dentro de una carpeta llamada “data” en el directorio “dia2” del proyecto del curso.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#importación-y-exploración-de-tablas",
    "href": "dia2/4.1_Tablas.html#importación-y-exploración-de-tablas",
    "title": "Tablas",
    "section": "Importación y exploración de tablas",
    "text": "Importación y exploración de tablas\nExisten muchas formas de importar tablas al ambiente de R. Quizás la forma más fácil es hacerlo desde la interfaz gráfica de RStudio: en el panel de entorno, clickeando en el ícono de importación.\nPara hacerlo desde la consola, read.table() es la función genérica, indicando la dirección y nombre del archivo a importar:\n\niris &lt;- read.table(file = \"data/iris.csv\")\n\nEn realidad, el dataset iris viene instalado por defecto con R, pero para ejemplificar lo hacemos visible en el panel de entorno mediante su importación. Esta tabla contiene el valor de distintas variables para 50 flores de 3 especies del género Iris.\nOtras funciones similares son read.csv() y read.csv2(), cuyo funcionamiento es idéntico a read.table() pero sus argumentos poseen otras especificaciones por defecto.\nExisten algunas funciones útiles para obtener información sobre su contenido o estructura. Simplemente llamando a la tabla por su nombre en la consola, R imprime todo el contenido de la tabla. Generalmente no es útil ver una tabla de esta forma, sobre todo si tiene muchas filas y columnas. Podemos visualizar las primeras filas con la función head():\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nLa cual imprime las primeras 6 filas de la tabla. Podemos cambiar este número con el segundo argumento de la función (n):\n\nhead(iris, n = 10)\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           5.1         3.5          1.4         0.2  setosa\n2           4.9         3.0          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n4           4.6         3.1          1.5         0.2  setosa\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa\n\n\nLa función tail() imprime las últimas filas de la tabla.\n\ntail(iris)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n145          6.7         3.3          5.7         2.5 virginica\n146          6.7         3.0          5.2         2.3 virginica\n147          6.3         2.5          5.0         1.9 virginica\n148          6.5         3.0          5.2         2.0 virginica\n149          6.2         3.4          5.4         2.3 virginica\n150          5.9         3.0          5.1         1.8 virginica\n\n\nLa función str() devuelve información básica sobre las columnas, similar a lo que se detalla en el panel de entorno.\n\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n\n\nLa función dim() imprime las dimensiones de la tabla (número de filas y de columnas, respectivamente).\n\ndim(iris)\n\n[1] 150   5\n\n\nLa funciones nrow() y ncol() devuelven dichos valores individualmente.\nLa función colnames() devuelve los nombres de las columnas en un vector de texto:\n\ncolnames(iris)\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n\nLa función rownames() funciona de manera idéntica, pero para las filas.\nAl importar un dataset, una buena práctica es realizar una exploración inicial de la estructura de la tabla, especialmente sus columnas y nombres. La importación incorrecta de datasets es una fuente de error muy frecuente.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#manipulación-de-tablas",
    "href": "dia2/4.1_Tablas.html#manipulación-de-tablas",
    "title": "Tablas",
    "section": "Manipulación de tablas",
    "text": "Manipulación de tablas\nUna tarea usual consiste en, una vez cargada una tabla, realizar modificaciones a la misma. Esto incluye, por ejemplo, obtener una nueva tabla de acuerdo a ciertas condiciones, eliminar ciertas filas o agregar nuevas columnas.\n\nIndexación y filtrado\nLos corchetes son muy versátiles para manipular y extraer datos de un data.frame. La sintaxis general es data[filas, columnas], siendo posible indicar índices, expresiones lógicas o nombres de columnas para obtener un subconjunto de datos (i.e. un subset).\n\niris_sub &lt;- iris[1:5, ]\n\nAquí, generamos un nuevo dataset con sólo las 5 primeras filas de la tabla iris. Notar que al mismo tiempo que se realiza el filtrado, lo asigno a un nuevo objeto. Si la asignación no se realiza, el objeto no queda guardado en el entorno, pero es útil si queremos probar rápidamente alguna línea de código, sin necesidad de generar un nuevo objeto.\nAhora, generamos un nuevo dataset que contiene sólo las columnas \"Species\" y \"Sepal.Length\".\n\niris_sub2 &lt;- iris[, c(\"Species\", \"Sepal.Length\")]\nhead(iris_sub2)\n\n  Species Sepal.Length\n1  setosa          5.1\n2  setosa          4.9\n3  setosa          4.7\n4  setosa          4.6\n5  setosa          5.0\n6  setosa          5.4\n\n\nNotar que la nueva tabla mantiene la identidad pero también el orden de las columnas indicadas en la sintaxis. Por lo tanto, esta sintaxis también puede utilizarse para cambiar el orden de las columnas, pudiendo indicar el nombre (como en el ejemplo) o los índices (para este ejemplo sería c(5, 1)).\nLa función order() permite ordenar una tabla de acuerdo a los valores de una columna o más columnas:\n\niris &lt;- iris[order(iris$Sepal.Length), ]\nhead(iris, 10)\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n14          4.3         3.0          1.1         0.1  setosa\n9           4.4         2.9          1.4         0.2  setosa\n39          4.4         3.0          1.3         0.2  setosa\n43          4.4         3.2          1.3         0.2  setosa\n42          4.5         2.3          1.3         0.3  setosa\n4           4.6         3.1          1.5         0.2  setosa\n7           4.6         3.4          1.4         0.3  setosa\n23          4.6         3.6          1.0         0.2  setosa\n48          4.6         3.2          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n\n\nPara seleccionar una columna de una table utilizamos la sintaxis tabla$columna.\nEn esto contexto, la expresión order(iris$Sepal.Length) genera nuevos índices para cada fila, indicando que nueva posición deberían ocupar para que la tabla quede ordenada. Por defecto, order() ordena de manera creciente. Indicando decreasing = TRUE se ordena la tabla de manera decreciente.\nEs posible indicar una ordenación por más de una columna:\n\niris &lt;- iris[order(iris$Species, iris$Sepal.Length, decreasing = TRUE), ]\nhead(iris, 10)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n132          7.9         3.8          6.4         2.0 virginica\n118          7.7         3.8          6.7         2.2 virginica\n119          7.7         2.6          6.9         2.3 virginica\n123          7.7         2.8          6.7         2.0 virginica\n136          7.7         3.0          6.1         2.3 virginica\n106          7.6         3.0          6.6         2.1 virginica\n131          7.4         2.8          6.1         1.9 virginica\n108          7.3         2.9          6.3         1.8 virginica\n110          7.2         3.6          6.1         2.5 virginica\n126          7.2         3.2          6.0         1.8 virginica\n\n\nEs posible obtener subconjuntos de datos que cumplan con ciertas condiciones. Las condiciones, en general, serán sobre los datos contenidos en las filas.\n\niris_sub3 &lt;- iris[iris$Sepal.Length &gt; 5, ]\nhead(iris_sub3)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n132          7.9         3.8          6.4         2.0 virginica\n118          7.7         3.8          6.7         2.2 virginica\n119          7.7         2.6          6.9         2.3 virginica\n123          7.7         2.8          6.7         2.0 virginica\n136          7.7         3.0          6.1         2.3 virginica\n106          7.6         3.0          6.6         2.1 virginica\n\n\nAquí estamos seleccionando aquellas filas para los cuales Sepal.Length es mayor a 5. ¿Por qué esta sintáxis tan rara? En realidad, lo que estamos haciendo es indicar una expresión lógica para las filas, especificando el nombre de la tabla y la columna (es un vector!) mediante el operador $:\n\niris$Sepal.Length &gt; 5\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[121]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nEs posible, entonces, indicar cualquier expresión lógica referida a una o más columnas de la tabla. El mismo filtrado puede realizarse mediante la función subset(), siendo este método un poco menos “engorroso”:\n\niris_sub3 &lt;- subset(iris, Sepal.Length &gt; 5)\nhead(iris_sub3)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n132          7.9         3.8          6.4         2.0 virginica\n118          7.7         3.8          6.7         2.2 virginica\n119          7.7         2.6          6.9         2.3 virginica\n123          7.7         2.8          6.7         2.0 virginica\n136          7.7         3.0          6.1         2.3 virginica\n106          7.6         3.0          6.6         2.1 virginica\n\n\nEl primer argumento indica el conjunto de datos a utilizar, y el segundo argumento la expresión a aplicar para filtrar dicho conjunto de datos. Notar que no es necesario aclarar la sintaxis iris$Sepal.Length. Esto es hace más fácil la escritura cuando haya que indicar múltiples condiciones lógicas.\nEl argumento select permite además seleccionar una o más columnas a dejar luego del filtro:\n\niris_sub4 &lt;- subset(iris, Sepal.Length &gt; 5, select = c(\"Species\", \"Sepal.Width\"))\nhead(iris_sub4)\n\n      Species Sepal.Width\n132 virginica         3.8\n118 virginica         3.8\n119 virginica         2.6\n123 virginica         2.8\n136 virginica         3.0\n106 virginica         3.0\n\n\n¿Cómo modificamos el contenido de una tabla? Para ello, debemos primero seleccionar qué campos queremos modificar, y luego asignarle el nuevo contenido. Por ejemplo, si quisiéramos cambiar el nombre de una de las especies por un sinónimo:\n\niris$Species[iris$Species == \"setosa\"] &lt;- \"arctica\"\n\nAnalicemos con cuidado esta expresión. La primera parte, iris$Species, indica la columna Species. Es decir, selecciono dicho el vector-columna. Entre corchetes indico una expresión lógica para seleccionar todos aquellos elementos del vector en donde dicha expresión sea verdadera. En este caso, donde el vector iris$Species sea igual (==) a \"setosa\". Finalmente, le asignamos el valor \"arctica\". Dado que queremos un único valor para todos los campos, no es necesario asignar un vector con elementos repetidos para \"arctica\".\nPara pensar: ¿Por qué no hay coma en la sintaxis de filtrado anterior?\nPodemos corroborar que se ha modificado la tabla con la función unique(), que devuelve los valores únicos para un objeto dado:\n\nunique(iris$Species)\n\n[1] \"virginica\"  \"versicolor\" \"arctica\"",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-1",
    "href": "dia2/4.1_Tablas.html#ejercicio-1",
    "title": "Tablas",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nGenere nuevas tablas a partir de la tabla iris (utilizar nombres nuevos para cada tabla), para:\n\nLa especie “setosa”, y las columnas “Species” y “Petal.Width”.\nLas especies “setosa” y “versicolor”. Deberá utilizar el operador %in% en vez del == (recordá de qué estamos hablando en Vectores).\nFlores en donde “Petal.Length” es mayor o igual a 4.\nFlores en donde “Sepal.Width” es mayor a 3 o “Sepal.Length” &lt; 4.\n\n\nCreación de nuevas columnas\nPara agregar una nueva columna utilizamos la sintaxis data$nueva_columna. La columna debe asociarse a un contenido, las filas, mediante el operador de asignación. Lo que hacemos es agregar un nuevo vector-columna a la colección de vectores-columnas que es el data.frame:\n\niris$Seed.set &lt;- NA\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n\n\nVemos que se ha generado una nueva columna con campos igual a NA (no dato). Crear una columna con datos vacíos de esta manera puede llegar a ser útil para luego ir rellenando cada fila de acuerdo al contenido de otras columnas. Spoiler: el control de flujo podría ser útil para esta tarea.\nLa siguiente línea genera una nueva columna a partir del cociente de otras dos:\n\niris$Sepal.Petal.ratio &lt;- iris$Sepal.Length/iris$Petal.Length\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio\n1          3.642857\n2          3.500000\n3          3.615385\n4          3.066667\n5          3.571429\n6          3.176471\n\n\nLa función ifelse() es útil para generar nuevas columnas basadas en la información de columnas ya existentes. Funciona de manera similar a un “SI()” de Excel/Calc. El primer argumento establece la condición, el segundo el valor devuelto si la condición es verdadera, y el tercero si es falsa:\n\niris$Sepal.width.cat &lt;- ifelse(iris$Sepal.Width &lt; 3, \"Corto\", \"Largo\")\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio Sepal.width.cat\n1          3.642857           Largo\n2          3.500000           Largo\n3          3.615385           Largo\n4          3.066667           Largo\n5          3.571429           Largo\n6          3.176471           Largo\n\n\nEs posible anidar la función ifelse() para obtener más categorías:\n\niris$Sepal.width.cat2 &lt;- ifelse(iris$Sepal.Width &lt; 2.8, \"Corto\",\n                               ifelse(iris$Sepal.Width &gt;= 2.8 & iris$Sepal.Width &lt; 3.3, \"Mediano\", \"Largo\"))\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio Sepal.width.cat Sepal.width.cat2\n1          3.642857           Largo            Largo\n2          3.500000           Largo          Mediano\n3          3.615385           Largo          Mediano\n4          3.066667           Largo          Mediano\n5          3.571429           Largo            Largo\n6          3.176471           Largo            Largo\n\n\nTraducción en palabras: Si el largo del sépalo es menor a 2.8, clasificarlo como “Corto”. En caso contrario, si es mayor o igual a 2.8 Y menor a 3.3, clasificarlo como “Mediano”; si no es así, clasificarlo como “Largo”.\nCon la función factor(), es posible aisgnarle a un vector-columna la clase de factor:\n\niris$Sepal.width.cat2 &lt;- factor(iris$Sepal.width.cat2)\niris$Sepal.width.cat2\n\n  [1] Largo   Mediano Mediano Mediano Largo   Largo   Largo   Largo   Mediano\n [10] Mediano Largo   Largo   Mediano Mediano Largo   Largo   Largo   Largo  \n [19] Largo   Largo   Largo   Largo   Largo   Largo   Largo   Mediano Largo  \n [28] Largo   Largo   Mediano Mediano Largo   Largo   Largo   Mediano Mediano\n [37] Largo   Largo   Mediano Largo   Largo   Corto   Mediano Largo   Largo  \n [46] Mediano Largo   Mediano Largo   Largo   Mediano Mediano Mediano Corto  \n [55] Mediano Mediano Largo   Corto   Mediano Corto   Corto   Mediano Corto  \n [64] Mediano Mediano Mediano Mediano Corto   Corto   Corto   Mediano Mediano\n [73] Corto   Mediano Mediano Mediano Mediano Mediano Mediano Corto   Corto  \n [82] Corto   Corto   Corto   Mediano Largo   Mediano Corto   Mediano Corto  \n [91] Corto   Mediano Corto   Corto   Corto   Mediano Mediano Mediano Corto  \n[100] Mediano Largo   Corto   Mediano Mediano Mediano Mediano Corto   Mediano\n[109] Corto   Largo   Mediano Corto   Mediano Corto   Mediano Mediano Mediano\n[118] Largo   Corto   Corto   Mediano Mediano Mediano Corto   Largo   Mediano\n[127] Mediano Mediano Mediano Mediano Mediano Largo   Mediano Mediano Corto  \n[136] Mediano Largo   Mediano Mediano Mediano Mediano Mediano Corto   Mediano\n[145] Largo   Mediano Corto   Mediano Largo   Mediano\nLevels: Corto Largo Mediano\n\n\nRecordemos, como vimos en la clase de Vectores, que al indicar un factor es posible también indicar el orden de sus niveles. Esto también aplica en el contexto de manipulación de tablas.\nNo obstante, a la hora de generar vectores (aquí asociados a una tabla), la función cut() es más adecuada. Esta función divide el rango de valores de un vector en intervalos específicos, y define nombres para cada intervalo. Por ejemplo:\n\niris$Sepal.width.cat4 &lt;- cut(x = iris$Sepal.Width, breaks = 3, labels = c(\"Corto\", \"Mediano\", \"Largo\"))\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio Sepal.width.cat Sepal.width.cat2 Sepal.width.cat4\n1          3.642857           Largo            Largo          Mediano\n2          3.500000           Largo          Mediano          Mediano\n3          3.615385           Largo          Mediano          Mediano\n4          3.066667           Largo          Mediano          Mediano\n5          3.571429           Largo            Largo          Mediano\n6          3.176471           Largo            Largo            Largo\n\n\nAquí, creamos una nueva columna, construida a partir de los valores de la columna Sepal.Width. Mediante breaks = 3, indicamos que el rango de valores de Sepal.Width se divida en 3 partes iguales, y definimos los nombres para cada intervalo en el argumento labels. El argumento breaks también admite un vector numérico con los valores que dividirán los intervalos generados.\nLa función cut() devuelve un factor con niveles, adecuado en contextos de análisis estadísticos y graficación:\n\nclass(iris$Sepal.width.cat4)\n\n[1] \"factor\"",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-2",
    "href": "dia2/4.1_Tablas.html#ejercicio-2",
    "title": "Tablas",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nGenere una nueva columna para la tabla iris llamada “Flower.color”. Para las especie Iris setosa y Iris versicolor, asignarle “Purple”. Para la especie Iris virginica asignarle “Blue”.\n\n\nUnión de tablas\nLas funciones rbind() y cbind() permiten añadir filas (“r” de “row”) y columnas (“c” de “column”) a un data.frame, respectivamente.\nA modo de ejemplo, importaremos un data.frame conteniendo las medidas de variables florales (inventadas para el ejemplo) para la especie Iris florentina. Asimismo, cargamos nuevamente la tavla iris con la estructura y datos originales:\n\n# Cargamos nuevamente la tabla con la estructura y datos originales\niris &lt;- read.table(\"data/iris.csv\")\n# Cargamos la nueva tabla\niris_fl &lt;- read.table(\"data/iris_florentina.csv\")\nhead(iris_fl)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          6.9         2.5          3.8         1.6 florentina\n2          5.4         3.1          3.5         2.0 florentina\n3          7.8         3.0          5.8         0.5 florentina\n4          6.2         2.0          3.5         0.3 florentina\n5          7.2         3.2          5.2         2.2 florentina\n6          5.7         1.9          5.4         0.6 florentina\n\n\nPodemos ver que tiene la misma cantidad de columnas y los mismos nombres que la tabla original con la que venimos trabajando. Lo lógico sería unir estas dos tablas mediante rbind():\n\niris_new &lt;- rbind(iris, iris_fl)\n\nLa exploración de las últimas filas de la nueva tabla comprueban que hemos hecho la unión correctamente:\n\ntail(iris_new)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n451          5.1         3.2          4.0         0.6 florentina\n461          6.7         4.0          5.0         0.7 florentina\n471          5.3         3.9          4.2         0.6 florentina\n481          7.1         2.5          4.8         1.9 florentina\n491          4.7         2.1          3.5         1.0 florentina\n501          4.7         2.0          5.0         0.9 florentina\n\n\nAl utilizar rbind(), debemos asegurarnos de que la cantidad de columnas y sus nombres sean idénticos. De lo contrario, R devuelve un error.\nDe manera similar, la función cbind() une tablas a lo largo de sus columnas, y su sintaxis tiene la forma de cbind(tabla1, tabla2). Lógicamente, el número de filas de ambas tablas debe ser el mismo, de lo contraria obtendremos una advertencia o un error.\nUsualmente, la información está repartida en más de una tabla. ¿Cómo generamos una nueva tabla que reúna toda la información junta? Para ello utilizamos la función merge() (fusionar/combinar). A modo de ejemplo, cargamos una nueva tabla con los nombres comunes de las especies de Iris con las que venimos trabajando:\n\niris_names &lt;- read.table(\"data/iris_common_names.csv\")\niris_names\n\n     Species           Common.name\n1     setosa Iris de punta erizada\n2 versicolor Iris azul de arlequín\n3  virginica     Iris azul del sur\n4 florentina           Iris blanca\n\n\nVemos que la tabla tiene dos columnas, una para la especie y otra para el nombre común. La idea sería agregar a la tabla generada anteriormente iris_new una nueva columna con los nombres comunes, repetidos para cada fila correspondiente. Hacerlo manualmente no es viable, siendo la función merge() la adecuada para esta tarea:\n\niris_new2 &lt;- merge(iris_new, iris_names, by = \"Species\")\nhead(iris_new2)\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width Common.name\n1 florentina          6.9         2.5          3.8         1.6 Iris blanca\n2 florentina          5.4         3.1          3.5         2.0 Iris blanca\n3 florentina          7.8         3.0          5.8         0.5 Iris blanca\n4 florentina          6.2         2.0          3.5         0.3 Iris blanca\n5 florentina          7.2         3.2          5.2         2.2 Iris blanca\n6 florentina          5.7         1.9          5.4         0.6 Iris blanca\n\n\nLos primeros dos argumentos indican las tablas a combinar, y el argumento by la columna común a ambas tablas (pueden indicarse más columnas con la sintaxis c(\"columna1\", \"columna2\")). La función busca coincidencias de campos en la columna (o columnas) en ambas tablas, y rellena correspondientemente.\nLa función merge() es una función muy útil para combinar tablas, pero debe utilizarse con cuidado, pensando qué tabla final es la que nos proponemos generar. Por ejemplo, obtendremos resultados distintos si los campos de la columna especificada en by (en el ejemplo, las especies) difieren de alguna manera, o si hay campos faltantes. Esto es particularmente importante para datasets muy grandes en donde no podemos corroborar que lo que se ha fusionado es lo que realmente nos proponíamos hacer. Es conveniente explorar las distintas opciones en ?merge.\n\n\nCálculo de estadísticas sobre tablas\nLa función aggregate() es útil para generar tablas con estadísticas de resumen de acuerdo a los niveles de un determinado factor. Por ejemplo, para calcular el valor medio de la longitud del sépalo para cada especie utilizamos la siguiente sintaxis:\n\niris_mean &lt;- aggregate(Sepal.Width ~ Species, data = iris, FUN = mean)\niris_mean\n\n     Species Sepal.Width\n1     setosa       3.428\n2 versicolor       2.770\n3  virginica       2.974\n\n\nEl primer argumento indica una fórmula con la sintaxis variable ~ factor, el segundo el data.frame de referencia y el tercero la función a aplicar. Esta función debe existir en el entorno, tanto por defecto (las cuales no aparecen visibles, como mean() o sd()) o programadas por el usuario.\nNo es útil que la columna de esta nueva tabla se siga llamando Sepal.Width. Podemos cambiarla asignando un nuevo nombre al vector generado con la función colnames():\n\ncolnames(iris_mean) &lt;- c(\"Species\", \"Sepal.Width.mean\")\niris_mean\n\n     Species Sepal.Width.mean\n1     setosa            3.428\n2 versicolor            2.770\n3  virginica            2.974\n\n\nPara pensar: Aquí debí aclarar “Species” para la primera columna, que no cambia de nombre. ¿Cuál podría ser la línea de código para cambiar únicamente la segunda columna?\nPara calcular la media de varias variables en una misma línea de código, utilizamos la función cbind():\n\niris_mean &lt;- aggregate(cbind(Sepal.Length, Sepal.Width) ~ Species, data = iris, FUN = mean)\niris_mean\n\n     Species Sepal.Length Sepal.Width\n1     setosa        5.006       3.428\n2 versicolor        5.936       2.770\n3  virginica        6.588       2.974\n\n\nEl uso del punto . es útil para hacer el cálculo sobre todas las columnas del dataset, a excepción de la definida a la derecha de ~:\n\niris_mean &lt;- aggregate(. ~ Species, data = iris, FUN = mean)\niris_mean\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-3",
    "href": "dia2/4.1_Tablas.html#ejercicio-3",
    "title": "Tablas",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nGenerar una tabla que contenga el cálculo de la media de “Petal.Length” para cada especie. Luego, generar otra tabla con la desviación estándar de “Petal.Length” para cada especie. En cada tabla, cambiar los nombres de las nuevas columnas a “Petal.Length.mean” y “Petal.Length.sd”. Finalmente, unir ambas tablas con cbind().",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#exportación-de-tablas",
    "href": "dia2/4.1_Tablas.html#exportación-de-tablas",
    "title": "Tablas",
    "section": "Exportación de tablas",
    "text": "Exportación de tablas\nLa exportación de un data.frame se realiza con write.table:\n\nwrite.table(iris_mean, file = \"iris.mean.csv\", row.names = F)\n\nAnálogamente a las funciones de importación, también disponemos de las funciones write.csv() y write.csv2.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#otras-estructuras-de-datos",
    "href": "dia2/4.1_Tablas.html#otras-estructuras-de-datos",
    "title": "Tablas",
    "section": "Otras estructuras de datos",
    "text": "Otras estructuras de datos\n\nMatrices\nLas matrices en R pertenecen a la clase matrix. Es una colección de datos agrupados en filas y columnas y, si bien admiten objetos de distinto tipo, en general se utilizan para almacenar números. La utilidad principal de una matriz, a diferencia de un data.frame, es que permite operaciones matemáticas propias. Por ello, es un objeto fundamental para el análisis estadístico en múltiples disciplinas.\nPara crear una matriz en R, utilizamos la función matrix():\n\nmat &lt;- matrix(data = 1:25, ncol = 5, nrow = 5)\nmat\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\n\nEl primer argumento indica los elementos que contendrá la matriz. En este caso, se utiliza la sucesión de números enteros desde el 1 al 25. Los argumentos ncol y nrow indican el número de columnas y filas correspondientes para generar la matriz. Un detalle importante es la forma en la que los elementos de la matriz se van rellenando. Por defecto, los datos se van agregando por columnas. En cambio, si se indica byrow = TRUE, los datos se agregan por fila:\n\nmat &lt;- matrix(data = 1:25, ncol = 5, nrow = 5, byrow = TRUE)\nmat\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n[4,]   16   17   18   19   20\n[5,]   21   22   23   24   25\n\n\nLa función dim() nos indica el número de filas y columnas de la matriz:\n\ndim(mat)\n\n[1] 5 5\n\n\nAl igual que para la clase data.frame, las funciones nrow() y ncol() indican el número de filas y columnas de una matriz.\nLos corchetes son los operadores indicados para acceder a los elementos de una matriz, indicando los índices para las filas y las columnas separado por una coma:\n\nmat[2, 3]\n\n[1] 8\n\n\nLas matrices se asocian a numerosas funciones especiales para matrices, pero no es la idea de este curso indagar mucho en este tema. Podemos mencionar las funciones rowSums() y colSums(), que devuelven las sumas de las filas y las columnas respectivamente. Análogamente, las funciones rowMeans() y colMeans() devuelven los valores medios.\n\n\nListas\nUna gran parte de diversos paquetes de R contienen funciones cuyas salidas son estructuras más complejas que las aprendidas hasta ahora. Un tipo de estas estructuras es la lista; estos son objetos de clase list. Es una colección de objetos de cualquier tipo. Por ejemplo:\n\niris_info &lt;- list(data = iris,\n                  mean_stats = iris_mean,\n                  year_of_creation = 2024)\n\nLa información guardada en una lista se accede mediante el operador $, si es que los elementos de la lista a acceder tienen asociado un nombre:\n\niris_info$mean_stats\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026\n\n\nTambién es posible acceder a la información de un elemento de una lista indicando el índice del elemento entre corchetes dobles:\n\niris_info[[3]]\n\n[1] 2024\n\n\nLa estructura y parte del contenido de una lista también puede desplegarse en el panel de entorno.\nEs posible modificar el contenido de un elemento de la lista, incluso indicando un elemento de otra clase:\n\niris_info$year_of_creation &lt;- \"Dos mil veinticuatro\"\niris_info$year_of_creation\n\n[1] \"Dos mil veinticuatro\"\n\n\nPor ejemplo, la salida de la función lm(), que confecciona una regresión lineal, es una lista:\n\n\n\n\n\n\n\nmod &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)\nis.list(mod)\n\n[1] TRUE\n\n\nAquí, en el primer argumento, indicamos para modelar la variable Sepal.Length en función de la variable Petal.Length. El símbolo ~ (virgulilla) es el indicado para expresar la fórmula. En el argumento data indicamos el data.frame de referencia. Por otro lado, la función is.list() devuelve TRUE si el objeto indicado es de clase list.\nLa función summary() devuelve información relevante sobre el modelo:\n\nmod_summ &lt;- summary(mod)\nmod_summ\n\n\nCall:\nlm(formula = Sepal.Length ~ Petal.Length, data = iris)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1.24675 -0.29657 -0.01515  0.27676  1.00269 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   4.30660    0.07839   54.94   &lt;2e-16 ***\nPetal.Length  0.40892    0.01889   21.65   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4071 on 148 degrees of freedom\nMultiple R-squared:   0.76, Adjusted R-squared:  0.7583 \nF-statistic: 468.6 on 1 and 148 DF,  p-value: &lt; 2.2e-16\n\n\nQue también guarda la información en una lista:\n\nis.list(mod_summ)\n\n[1] TRUE\n\n\nEs posible acceder a los coeficientes del modelo, en forma de tabla, explorando la salida de summary():\n\nmod_summ$coefficients\n\n              Estimate Std. Error  t value      Pr(&gt;|t|)\n(Intercept)  4.3066034 0.07838896 54.93890 2.426713e-100\nPetal.Length 0.4089223 0.01889134 21.64602  1.038667e-47\n\n\n\nClases S4\nOtra salida menos común de algunos paquetes son las clases S4. En esencia, son muy similares a las listas en el sentido de que pueden almacenar cualquier tipo de objeto. Una de las diferencias radica en que el tipo de elemento a almacenar está predefinido, y no puede cambiarse.\nUn ejemplo es la salida de la función raster() del paquete raster, la cual genera un objeto de tipo raster, muy utilizado en el contexto de Sistemas de Información Geográfica. Por ahora, basta con saber que la información de estos objetos se acceden con el operador @, mediante la sintaxis objeto@elemento.\n\n\n\n\nEl paquete dplyr\nEl paquete dplyr ofrece numerosas herramientas R para manipular y transformar datos. Es parte del universo tidyverse, diseñado para facilitar el trabajo con datos tabulares de manera eficiente y legible. A diferencia del manejo básico de tablas en R, dplyr introduce una sintaxis diferente a través del operador %&gt;%, que relaciona una expresión con otra como si fuera una oración de texto:\ncargar tabla %&gt;% seleccionar columnas %&gt;% filtrar filas %&gt;% crear nueva columna\nPor ejemplo, dplyr ofrece funciones intuitivas para realizar operaciones comunes, como filtrar filas (filter()), seleccionar columnas (select()), reordenar datos (arrange()), crear nuevas variables (mutate()) y resumir información (summarize()).\nEl presente curso está orientado a entender los fundamentos básicos del lenguaje R y no ahondaremos en el uso de este paquete. No obstante, creemos que es útil saber de su existencia y explorar sobre su uso en caso de necesidad.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-final",
    "href": "dia2/4.1_Tablas.html#ejercicio-final",
    "title": "Tablas",
    "section": "Ejercicio final",
    "text": "Ejercicio final\n\nCargue la tabla del archivo “analisis_tierra.csv”, la cual muestra los resultados de un análisis de muestras de tierra, detallando las concentraciones de N, C y Ca. Explore su estructura y contenido utilizando las funciones head(), tail(), str() y dim().\nExplore los nombres de las columnas. Corrija el error en la segunda columna, que debería llamarse “Parcela”.\nHay valores negativos para la concentración de Ca, lo cual no tiene sentido. Cambie estos valores por ceros.\nHay valores NA en la columna que indica la concentración de N. Genere una nueva tabla, utilizando el mismo nombre que antes, que no contenga estas observaciones (filas). Puede utilizar la expresión is.na(), pero explore también la ayuda de na.omit().\nCargue la tabla del archivo “analisis_tierra2.csv”, la cual muestra los resultados realizados por otra técnica (Claudia). Incorpore estos nuevos datos a la tabla anterior. Es necesario corregir algunos errores antes de hacer esto . Entre ellos, los números asignados a cada muestra deben cambiarse, para que estos no coincidan con los números de muestra de la tabla anterior.\nOrdene la tabla según la Parcela (orden alfabético) y por valores crecientes en la cantidad de N, en ese orden!\nExprese a la columna “Tecnico” como factor.\nGenere una tabla resumen con los valores medios de N, C y Ca por Parcela, y otra con los valores de desviación estándar de N, C y Ca por Técnico. Exporte dichas tablas resumen.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  }
]