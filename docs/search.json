[
  {
    "objectID": "codigo_colab.html",
    "href": "codigo_colab.html",
    "title": "¬°C√≥digo colaborativo!",
    "section": "",
    "text": "Envi√° tu c√≥digo para probarlo en la clase en vivo.\nUtiliz√° el siguiente formulario para enviarnos tu bloque de c√≥digo de los ejercicios que realicemos durante la clase. Lo ejecutaremos en vivo frente a todos, revisando juntos c√≥mo funciona y resolviendo dudas en tiempo real!\n\n\n\n\n\n  \n\n    \n    \n    \n    \n    \n\n    \n      \n        Nombre\n        \n      \n      \n        Bloque de c√≥digo\n        \n      \n    \n    Enviar\n  \n\n\n\n\n\n Volver arriba",
    "crumbs": [
      "Inicio",
      "C√≥digo colaborativo!"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html",
    "href": "dia1/3.2_Vectores.html",
    "title": "Vectores",
    "section": "",
    "text": "En R, un vector es una colecci√≥n ordenada de objetos de un mismo tipo o clase. Aprender sobre la creaci√≥n y manipulaci√≥n de vectores es un paso fundamental para comprender la manipulaci√≥n de objetos m√°s complejos, por ejemplo, las tablas y las matrices. Esto se debe a que estos objetos son justamente una colecci√≥n de vectores.\nLa forma m√°s simple de crear un vector es mediante la funci√≥n gen√©rica c(), que simplemente combina los elementos indicados entre comas:\n\nvec &lt;- c(1, 2, 3)\nvec\n\n[1] 1 2 3\n\n\nEs posible asignarles un nombre a cada elemento, lo cual puede ser √∫til en algunos contextos:\n\nvec &lt;- c(a = 1, b = 2, c = 3)\nvec\n\na b c \n1 2 3 \n\n\nSi quisi√©ramos averiguar qu√© clase de elementos contiene el vector, utilizamos la funci√≥n class():\n\nclass(vec)\n\n[1] \"numeric\"\n\n\nEn general, podemos utilizar la funci√≥n str() para conocer la estructura (structure) de cualquier objeto de R, incluyendo vectores:\n\nstr(vec)\n\n Named num [1:3] 1 2 3\n - attr(*, \"names\")= chr [1:3] \"a\" \"b\" \"c\"\n\n\nUn vector puede componerse de cinco clases principales de elementos:\n\n\n\n\n\n\n\nnumeric\nContienen n√∫meros reales (decimales). Por ejemplo: c(1.2, 1.5, 1.7).\n\n\ninteger\nContienen n√∫meros enteros. Debemos indicarse con la letra L luego del n√∫mero. Por ejemplo: c(1L, -5L, 16L, 17L).\n\n\nlogical\nContienen valores booleanos o l√≥gicos. Por ejemplo: c(TRUE, FALSE, NA) o c(T, F, T).\n\n\ncharacter\nContienen texto, el cual debe explicitarse con comillas simples o dobles. Por ejemplo: c(\"Algarrobo\", \"Quebracho\", \"Espinillo\").\n\n\nNULL\nRepresenta un vector vac√≠o. Se genera al crear el vector: vec &lt;- NULL.\n\n\n\nRecordemos que al crear un vector, este puede componerse de un solo tipo de elementos. Por ello, debemos tener cuidado a la hora de generar nuestros vectores, y asegurarnos de que estamos generando un vector con elementos de la clase deseada. El uso de vectores con elementos de una clase incorrecta es un error muy com√∫n en distintos contextos del flujo de trabajo. Por ejemplo:\n\nvec &lt;- c(1985, \"Algarrobo\", \"Quebracho\")\nclass(vec)\n\n[1] \"character\"\n\n\nObservamos que el vector generado es de clase character. A la hora de forzar una clase para los elementos de un vector, R asigna prioridad a ciertas clases sobre otras. Si bien es posible correr l√≠neas de c√≥digo como la anterior, en general no ser√≠a una buena pr√°ctica hacerlo. Mejor ser expl√≠cito!\n\n\nOtra clase importante para los elementos de un vector es factor. Sirve para definir un factor categ√≥rico, compuesto por niveles (los elementos distintos y √∫nicos del vector), los cuales siguen un orden espec√≠fico:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies &lt;- factor(especies)\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Algarrobo Espinillo Quebracho\n\n\nEs posible cambiar el orden de los niveles, definiendo al factor con el argumento levels:\n\nespecies &lt;- factor(especies, levels = c(\"Quebracho\", \"Espinillo\", \"Algarrobo\"))\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Quebracho Espinillo Algarrobo\n\n\n\n\n\nDurante nuestro trabajo, puede ser √∫til la creaci√≥n de vectores que sigan una l√≥gica determinada. Si queremos generar una secuencia de n√∫meros enteros con incremento de a una unidad, el operador de secuencia : es el indicado, siguiendo la l√≥gica ‚Äúdesde:hasta‚Äù:\n\nsuc &lt;- 5:30\nsuc\n\n [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29\n[26] 30\n\n\nPara generar vectores con una l√≥gica m√°s compleja, las funciones seq() y rep() son adecuadas. La funci√≥n seq() genera un sucesi√≥n de n√∫meros (i.e.¬†un vector de clase numeric o integer):\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nLos argumentos from y to determinan respectivamente los valores m√≠nimos y m√°ximos de la secuencia, mientras que el argumento by determina el incremento de la secuencia. Otra forma de generar el mismo vector del ejemplo ser√≠a:\n\nseq(from = 1, by = 2, length.out = 5)\n\n[1] 1 3 5 7 9\n\n\nEl argumento length.out determina el n√∫mero m√°ximo de elementos que contendr√° el vector.\nAl correr la funci√≥n con un √∫nico n√∫mero, obtenemos una sucesi√≥n de n√∫meros enteros, comenzando desde el 1:\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLa funci√≥n rep() genera un nuevo vector a partir de la repetici√≥n de los elementos de un vector dado:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nvec_sp &lt;- rep(x = especies, times = 2)\nvec_sp\n\n[1] \"Algarrobo\" \"Quebracho\" \"Espinillo\" \"Algarrobo\" \"Quebracho\" \"Espinillo\"\n\n\nEl argumento x recibe un vector dado, mientras que el argumento times indica la cantidad de veces que debe repetirse el vector dado. Otro argumento relevante de la funci√≥n rep() es el argumento each:\n\nvec_sp &lt;- rep(x = especies, each = 3)\nvec_sp\n\n[1] \"Algarrobo\" \"Algarrobo\" \"Algarrobo\" \"Quebracho\" \"Quebracho\" \"Quebracho\"\n[7] \"Espinillo\" \"Espinillo\" \"Espinillo\"\n\n\nAqu√≠, each = 3 indica que cada elemento del vector en x debe repetirse 3 veces.\n\n\n\nAdem√°s de las expuestas, existen numerosas funciones nativas de R para generar vectores. Entre ellas, podemos mencionar a sample(), la cual genera un vector con un subconjunto aleatorio de elementos a partir un vector dado; runif() y rnorm(), los cuales generan vectores de elementos provenientes de una distribuci√≥n uniforme o normal, respectivamente. Por otro lado, las funciones letters() y LETTERS() generan vectores de letras en min√∫scula o may√∫scula.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#creaci√≥n-de-vectores",
    "href": "dia1/3.2_Vectores.html#creaci√≥n-de-vectores",
    "title": "Vectores",
    "section": "",
    "text": "En R, un vector es una colecci√≥n ordenada de objetos de un mismo tipo o clase. Aprender sobre la creaci√≥n y manipulaci√≥n de vectores es un paso fundamental para comprender la manipulaci√≥n de objetos m√°s complejos, por ejemplo, las tablas y las matrices. Esto se debe a que estos objetos son justamente una colecci√≥n de vectores.\nLa forma m√°s simple de crear un vector es mediante la funci√≥n gen√©rica c(), que simplemente combina los elementos indicados entre comas:\n\nvec &lt;- c(1, 2, 3)\nvec\n\n[1] 1 2 3\n\n\nEs posible asignarles un nombre a cada elemento, lo cual puede ser √∫til en algunos contextos:\n\nvec &lt;- c(a = 1, b = 2, c = 3)\nvec\n\na b c \n1 2 3 \n\n\nSi quisi√©ramos averiguar qu√© clase de elementos contiene el vector, utilizamos la funci√≥n class():\n\nclass(vec)\n\n[1] \"numeric\"\n\n\nEn general, podemos utilizar la funci√≥n str() para conocer la estructura (structure) de cualquier objeto de R, incluyendo vectores:\n\nstr(vec)\n\n Named num [1:3] 1 2 3\n - attr(*, \"names\")= chr [1:3] \"a\" \"b\" \"c\"\n\n\nUn vector puede componerse de cinco clases principales de elementos:\n\n\n\n\n\n\n\nnumeric\nContienen n√∫meros reales (decimales). Por ejemplo: c(1.2, 1.5, 1.7).\n\n\ninteger\nContienen n√∫meros enteros. Debemos indicarse con la letra L luego del n√∫mero. Por ejemplo: c(1L, -5L, 16L, 17L).\n\n\nlogical\nContienen valores booleanos o l√≥gicos. Por ejemplo: c(TRUE, FALSE, NA) o c(T, F, T).\n\n\ncharacter\nContienen texto, el cual debe explicitarse con comillas simples o dobles. Por ejemplo: c(\"Algarrobo\", \"Quebracho\", \"Espinillo\").\n\n\nNULL\nRepresenta un vector vac√≠o. Se genera al crear el vector: vec &lt;- NULL.\n\n\n\nRecordemos que al crear un vector, este puede componerse de un solo tipo de elementos. Por ello, debemos tener cuidado a la hora de generar nuestros vectores, y asegurarnos de que estamos generando un vector con elementos de la clase deseada. El uso de vectores con elementos de una clase incorrecta es un error muy com√∫n en distintos contextos del flujo de trabajo. Por ejemplo:\n\nvec &lt;- c(1985, \"Algarrobo\", \"Quebracho\")\nclass(vec)\n\n[1] \"character\"\n\n\nObservamos que el vector generado es de clase character. A la hora de forzar una clase para los elementos de un vector, R asigna prioridad a ciertas clases sobre otras. Si bien es posible correr l√≠neas de c√≥digo como la anterior, en general no ser√≠a una buena pr√°ctica hacerlo. Mejor ser expl√≠cito!\n\n\nOtra clase importante para los elementos de un vector es factor. Sirve para definir un factor categ√≥rico, compuesto por niveles (los elementos distintos y √∫nicos del vector), los cuales siguen un orden espec√≠fico:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies &lt;- factor(especies)\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Algarrobo Espinillo Quebracho\n\n\nEs posible cambiar el orden de los niveles, definiendo al factor con el argumento levels:\n\nespecies &lt;- factor(especies, levels = c(\"Quebracho\", \"Espinillo\", \"Algarrobo\"))\nespecies\n\n[1] Algarrobo Quebracho Espinillo\nLevels: Quebracho Espinillo Algarrobo\n\n\n\n\n\nDurante nuestro trabajo, puede ser √∫til la creaci√≥n de vectores que sigan una l√≥gica determinada. Si queremos generar una secuencia de n√∫meros enteros con incremento de a una unidad, el operador de secuencia : es el indicado, siguiendo la l√≥gica ‚Äúdesde:hasta‚Äù:\n\nsuc &lt;- 5:30\nsuc\n\n [1]  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29\n[26] 30\n\n\nPara generar vectores con una l√≥gica m√°s compleja, las funciones seq() y rep() son adecuadas. La funci√≥n seq() genera un sucesi√≥n de n√∫meros (i.e.¬†un vector de clase numeric o integer):\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nLos argumentos from y to determinan respectivamente los valores m√≠nimos y m√°ximos de la secuencia, mientras que el argumento by determina el incremento de la secuencia. Otra forma de generar el mismo vector del ejemplo ser√≠a:\n\nseq(from = 1, by = 2, length.out = 5)\n\n[1] 1 3 5 7 9\n\n\nEl argumento length.out determina el n√∫mero m√°ximo de elementos que contendr√° el vector.\nAl correr la funci√≥n con un √∫nico n√∫mero, obtenemos una sucesi√≥n de n√∫meros enteros, comenzando desde el 1:\n\nseq(10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLa funci√≥n rep() genera un nuevo vector a partir de la repetici√≥n de los elementos de un vector dado:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nvec_sp &lt;- rep(x = especies, times = 2)\nvec_sp\n\n[1] \"Algarrobo\" \"Quebracho\" \"Espinillo\" \"Algarrobo\" \"Quebracho\" \"Espinillo\"\n\n\nEl argumento x recibe un vector dado, mientras que el argumento times indica la cantidad de veces que debe repetirse el vector dado. Otro argumento relevante de la funci√≥n rep() es el argumento each:\n\nvec_sp &lt;- rep(x = especies, each = 3)\nvec_sp\n\n[1] \"Algarrobo\" \"Algarrobo\" \"Algarrobo\" \"Quebracho\" \"Quebracho\" \"Quebracho\"\n[7] \"Espinillo\" \"Espinillo\" \"Espinillo\"\n\n\nAqu√≠, each = 3 indica que cada elemento del vector en x debe repetirse 3 veces.\n\n\n\nAdem√°s de las expuestas, existen numerosas funciones nativas de R para generar vectores. Entre ellas, podemos mencionar a sample(), la cual genera un vector con un subconjunto aleatorio de elementos a partir un vector dado; runif() y rnorm(), los cuales generan vectores de elementos provenientes de una distribuci√≥n uniforme o normal, respectivamente. Por otro lado, las funciones letters() y LETTERS() generan vectores de letras en min√∫scula o may√∫scula.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#ejercicio-1",
    "href": "dia1/3.2_Vectores.html#ejercicio-1",
    "title": "Vectores",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nDado el vector rep(x = 3:1, each = 5), explore qu√© hacen las siguientes funciones: length(), sort(), rev() y unique().",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#vectores-y-expresiones-l√≥gicas",
    "href": "dia1/3.2_Vectores.html#vectores-y-expresiones-l√≥gicas",
    "title": "Vectores",
    "section": "Vectores y expresiones l√≥gicas",
    "text": "Vectores y expresiones l√≥gicas\nAhora que aprendimos c√≥mo generar un vector, veremos c√≥mo se eval√∫an las expresiones l√≥gicas en este contexto. Por ejemplo:\n\n3 == 1:10\n\n [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nAqu√≠, evaluamos si cada elemento del vector 1:10 es igual al n√∫mero 3, indicando TRUE en dicho caso. En cambio, utilizando != obtenemos como resultado lo opuesto:\n\n3 != 1:10\n\n [1]  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nObviamente, los operadores relaciones tambi√©n son v√°lidos:\n\n3 &gt;= 1:10\n\n [1]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nEn el contexto de vectores, es muy √∫til el operador l√≥gico %in%. Este operador devuelve TRUE para cada elemento a la izquierda, s√≥lo si dicho elemento es encontrado en el vector indicado a la derecha del operador. Caso contrario, devuelve FALSE. Por ejemplo:\n\n3 %in% 1:10\n\n[1] TRUE\n\n\nTambi√©n es posible indicar m√°s de un elemento a la izquierda del operador:\n\nc(1, 2, 3) %in% 1:10\n\n[1] TRUE TRUE TRUE\n\n\nPor otro lado, las funciones all() y any() son muy utilizadas a la hora de evaluar vectores l√≥gicos. Anteriormente, vimos que estas funciones sirven para evaluar varias condiciones al mismo tiempo, separadas por una coma. No obstante, tambi√©n es posible indicarle directamente un vector l√≥gico. En el contexto de vectores, la funci√≥n all() devuelve TRUE si todos los elementos del vector l√≥gico son TRUE, caso contrario devuelve FALSE. Por ejemplo\n\ncond &lt;- 11 &gt; 1:10\nall(cond)\n\n[1] TRUE\n\n\nEn cambio, con solo haber un s√≥lo elemento igual a FALSE, la funci√≥n all() devuelve FALSE:\n\ncond &lt;- 10 &gt; 1:10\nall(cond)\n\n[1] FALSE\n\n\nLa funci√≥n any(), devuelve TRUE si al menos un elemento del vector l√≥gico es TRUE:\n\ncond &lt;- 10 &lt;= 1:10\nany(cond)\n\n[1] TRUE\n\n\nCaso contrario, si todos los elementos son iguales a FALSE, any() devuelve FALSE:\n\ncond &lt;- 15 &lt; 1:10\nany(cond)\n\n[1] FALSE\n\n\nFinalmente, es √∫til aclarar que en el contexto de operaciones aritm√©ticas, TRUE equivale a 1 y FALSE equivale a 0. Por ejemplo, sea la siguiente condici√≥n:\n\ncond &lt;- 5 &gt;= 1:10\ncond\n\n [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n\n\nSi sumamos los elementos del vector l√≥gico, obtenemos lo siguiente:\n\nsum(cond)\n\n[1] 5\n\n\n¬øDe qu√© sirve conocer esto? Quiz√°s no le veamos utilidad ahora mismo, pero puede llegar a ser √∫til en el contexto de un trabajo m√°s avanzado (por ejemplo, en el contexto de manipulaci√≥n de tablas).",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#manipulaci√≥n-de-vectores",
    "href": "dia1/3.2_Vectores.html#manipulaci√≥n-de-vectores",
    "title": "Vectores",
    "section": "Manipulaci√≥n de vectores",
    "text": "Manipulaci√≥n de vectores\nUn apartado fundamental para aprender a programar en R es la manipulaci√≥n de vectores. En pocas palabras, nos referimos a generar un nuevo vector a partir de uno creado previamente, de manera tal que sirva para realizar una tarea espec√≠fica. Este tipo de tareas ser√° de gran utilidad a la hora de trabajar con tablas.\nDado un vector, interesa averiguar su contenido, lo cual lo podemos hacer simplemente imprimiendo el vector en la consola, o rescatando uno o m√°s elementos a trav√©s de sus √≠ndices:\n\nvec &lt;- seq(from = -5, to = 5, by = 0.25)\nvec[15]\n\n[1] -1.5\n\nvec[c(1, 5, 10)]\n\n[1] -5.00 -4.00 -2.75\n\nvec[13:18]\n\n[1] -2.00 -1.75 -1.50 -1.25 -1.00 -0.75\n\n\nLos corchetes [] indican que se seleccionar√° un subconjunto de elementos del vector. En la segunda l√≠nea del ejemplo, seleccionamos el elemento de √≠ndice 15. En la tercera l√≠nea de c√≥digo, seleccionamos los elementos de √≠ndice 1, 5 y 10. En la cuarta l√≠nea de c√≥digo, en cambio, seleccionamos los elementos 13 al 18 (i.e.¬†√≠ndices).\nEs posible excluir elementos con el s√≠mbolo -:\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies_sub &lt;- especies[-2]\nespecies_sub\n\n[1] \"Algarrobo\" \"Espinillo\"\n\n\nAdem√°s de la posibilidad de indicar √≠ndices, es posible utilizar un vector l√≥gico. Dicho vector puede generarse definiendo condiciones que los elementos deben cumplir.\n\ncond1 &lt;- vec &gt; -2 & vec &lt; 2\ncond1\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[13] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[25]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[37] FALSE FALSE FALSE FALSE FALSE\n\nvec_sub &lt;- vec[cond1]\n\nAqu√≠, el objeto ‚Äúcond1‚Äù es un vector l√≥gico, indicando TRUE o FALSE para cada elemento del vector ‚Äúvec‚Äù, seg√∫n la condici√≥n expuesta: que el n√∫mero sea mayor a -2 (vec &gt; -2) y (&) menor a 2 (vec &lt; 2). Notar que hay que ser expl√≠cito a la hora de definir la condici√≥n. Es √∫til indicar la condici√≥n directamente, sin necesidad de crear un objeto nuevo:\n\nvec_sub &lt;- vec[vec &gt; -2 & vec &lt; 2]\nvec_sub\n\n [1] -1.75 -1.50 -1.25 -1.00 -0.75 -0.50 -0.25  0.00  0.25  0.50  0.75  1.00\n[13]  1.25  1.50  1.75\n\n\nLa funci√≥n subset() permite hacer la misma operaci√≥n de filtrado, indicando el vector a filtrar, y la condici√≥n:\n\nvec_sub &lt;- subset(vec, vec &gt; -2 & vec &lt; 2)\nvec_sub\n\n [1] -1.75 -1.50 -1.25 -1.00 -0.75 -0.50 -0.25  0.00  0.25  0.50  0.75  1.00\n[13]  1.25  1.50  1.75\n\n\nLa funci√≥n which() devuelve los √≠ndices de los elementos de un vector que cumplen con una condici√≥n dada:\n\nwhich(vec &gt; -2 & vec &lt; 2)\n\n [1] 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28\n\n\nPara pensar: Sin correr la expresi√≥n, ¬øqu√© pasa si la condici√≥n que definimos es !(vec &gt; -2 & vec &lt; 2)?\nUna vez seleccionado el subconjunto de elementos de un vector, es posible asignarle un valor diferente:\n\nvec[vec &lt;= 0] &lt;- 0\n\nAqu√≠, seleccionamos los valores menores o iguales a 0, y les asignamos el valor 0. Notar que en este caso, al ser un √∫nico valor de reemplazo, no es necesario repetir el 0 tantas veces como valores a reemplazar.\nA veces, resulta √∫til reemplazar los valores NA (no dato) por alg√∫n otro valor √∫til, para lo cual podemos utilizar la funci√≥n is.na().\n\nvec &lt;- c(5, 8, 16, NA, 3)\nvec[is.na(vec)] &lt;- 0\nvec\n\n[1]  5  8 16  0  3\n\n\nEn el contexto de valores NA, es √∫til la funci√≥n na.omit(), que remuevo todos los elementos que sean NA:\n\nvec &lt;- c(5, 8, 16, NA, 3, 8, NA)\nvec2 &lt;- na.omit(vec)\nvec2\n\n[1]  5  8 16  3  8\nattr(,\"na.action\")\n[1] 4 7\nattr(,\"class\")\n[1] \"omit\"\n\n\nA la hora de efectuar subconjuntos de vectores, es importante diferenciar el uso del operador == del %in%, que ya introdujimos anteriormente. Al utilizar el operador == nos preguntamos si cada elemento del vector indicado a la izquierda del operador es igual al elemento (o a los elementos) indicado a la derecha; y utilizamos la expresi√≥n l√≥gica resultante para hacer el subset del vector:\n\nespecies &lt;- rep(c(\"Algarrobo\", \"Molle\", \"Quebracho\", \"Piquillin\"), each = 5)\nespecies[especies == \"Quebracho\"]\n\n[1] \"Quebracho\" \"Quebracho\" \"Quebracho\" \"Quebracho\" \"Quebracho\"\n\n\n¬øC√≥mo procedemos si, por ejemplo, quisi√©ramos seleccionar m√°s de una especie? El operador == ya no es √∫til por s√≠ solo. Una opci√≥n es la siguiente:\n\nespecies[especies == \"Molle\" | especies == \"Piquillin\"]\n\n [1] \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Piquillin\"\n [7] \"Piquillin\" \"Piquillin\" \"Piquillin\" \"Piquillin\"\n\n\nOtra forma de hacerlo es utilizar el operador %in%. Recordemos que este operador indica TRUE o FALSE si cada elemento del vector a la izquierda est√° contenido en el vector indicado a la derecha:\n\nespecies[especies %in% c(\"Molle\", \"Piquillin\")]\n\n [1] \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Molle\"     \"Piquillin\"\n [7] \"Piquillin\" \"Piquillin\" \"Piquillin\" \"Piquillin\"\n\n\nComo veremos m√°s adelante, el operador %in% es muy √∫til en el contexto de manipulaci√≥n de tablas.\nEs posible a√±adir elementos a un vector con la funci√≥n c():\n\nespecies &lt;- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies &lt;- c(especies, \"Yuchan\", \"Tusca\")\nespecies\n\n[1] \"Algarrobo\" \"Quebracho\" \"Espinillo\" \"Yuchan\"    \"Tusca\"    \n\n\nPara explorar: La funci√≥n append() es una forma de general de hacer esto. Explore ?append.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#funciones-b√°sicas-para-vectores-num√©ricos",
    "href": "dia1/3.2_Vectores.html#funciones-b√°sicas-para-vectores-num√©ricos",
    "title": "Vectores",
    "section": "Funciones b√°sicas para vectores num√©ricos",
    "text": "Funciones b√°sicas para vectores num√©ricos\nAnteriormente, hemos visto c√≥mo trabajan las funciones round(), ceiling(), floor() and trunc() con n√∫meros sueltos. Sin embargo, estas funciones, al igual que muchas otras funciones nativas de R, son funciones vectorizadas. Esto significa que pueden trabajar sobre un vector, y arrojar un resultado para cada uno de los elementos del vector.\nPor ejemplo:\n\nvec &lt;- c(1.233, 1.924, 0.46)\nround(vec, digits = 1)\n\n[1] 1.2 1.9 0.5\n\n\nR tambi√©n provee de numerosas funciones nativas para obtener medidas de resumen. Podemos mencionar a mean() para calcular el promedio, median() para calcular la mediana y sd() para calcular el desv√≠o est√°ndar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/3.2_Vectores.html#ejercicio-final",
    "href": "dia1/3.2_Vectores.html#ejercicio-final",
    "title": "Vectores",
    "section": "Ejercicio final",
    "text": "Ejercicio final\n\nUtilice las funciones rep() y seq() para generar los siguientes vectores:\n\n\nUna sucesi√≥n de n√∫meros pares de 15 elementos.\nUna sucesi√≥n de n√∫meros decimales, con un incremento de 0.15.\nUn vector tipo character, que indique 4 categor√≠as discretas, repetidas de a 3 cada una.\nUn vector que repita 5 veces el siguiente vector: c(F, T, F, T).\n\n\nDado el vector seq(from = 0, to = 1, by = 0.01), y utilizando los aprendido sobre manipulaci√≥n de vectores y expresiones l√≥gicas, genere nuevos vectores de acuerdo a los siguientes criterios:\n\n\nQue contenga los elementos de √≠ndices 10 a 20.\nQue excluya los elementos 30 a 50. Ayuda: utilice par√©ntesis.\nQue los elementos sean mayores a 0.5.\nQue los elementos sean menores o iguales a 0.3 o mayores a 0.7.\nQue los elementos cumplan con la condici√≥n opuesta a la inmediatamente anterior.\n\n\nGenere un vector de 500 n√∫meros provenientes de una distribuci√≥n normal, de media 15 y desv√≠o est√°ndar 4. Para ello, utilice la funci√≥n rnorm() (explore la ayuda mediante ?rnorm). Seguidamente, verifique los valores de media, mediana y desv√≠o est√°ndar de la muestra. Calcule los cuantiles tradicionales mediante quantile(). Calculo el percentil 5% y el 95%.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Vectores"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html",
    "href": "dia1/2.1_FlujoTrabajo.html",
    "title": "Flujo de Trabajo en R",
    "section": "",
    "text": "Cuando trabajamos con R (pero esto es v√°lido tambi√©n para cualquier otro proyecto de c√≥digo o an√°lisis de datos) debemos intentar ser sumamente organizados. Disponer de un sistema que permita identificar r√°pidamente cuales son las entradas (datos) y las salidas (resultados de an√°lisis, gr√°ficos, etc.), as√≠ como los pasos intermedios, si existieran, nos facilitar√° mucho nuestro trabajo. Ya hemos visto que en RStudio podemos crear Proyectos que nos ayudar√°n a mantener todo m√°s organizado. A continuaci√≥n veremos algunas otras formas de comentar e indexar el c√≥digo en s√≠ mismo para poder lograr una mayor organizaci√≥n y claridad.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ante-todo-orden-y-organizaci√≥n",
    "href": "dia1/2.1_FlujoTrabajo.html#ante-todo-orden-y-organizaci√≥n",
    "title": "Flujo de Trabajo en R",
    "section": "",
    "text": "Cuando trabajamos con R (pero esto es v√°lido tambi√©n para cualquier otro proyecto de c√≥digo o an√°lisis de datos) debemos intentar ser sumamente organizados. Disponer de un sistema que permita identificar r√°pidamente cuales son las entradas (datos) y las salidas (resultados de an√°lisis, gr√°ficos, etc.), as√≠ como los pasos intermedios, si existieran, nos facilitar√° mucho nuestro trabajo. Ya hemos visto que en RStudio podemos crear Proyectos que nos ayudar√°n a mantener todo m√°s organizado. A continuaci√≥n veremos algunas otras formas de comentar e indexar el c√≥digo en s√≠ mismo para poder lograr una mayor organizaci√≥n y claridad.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#comentarios-e-√≠ndices",
    "href": "dia1/2.1_FlujoTrabajo.html#comentarios-e-√≠ndices",
    "title": "Flujo de Trabajo en R",
    "section": "Comentarios e √≠ndices",
    "text": "Comentarios e √≠ndices\nComo hemos visto previamente, cuando estemos trabajando dentro de RStudio la mayor parte del tiempo estaremos editando un archivo de texto con nuestro c√≥digo. A este archivo que contiene todas las instrucciones, desde la carga de paquetes necesarios, la carga de datos, la manipulaci√≥n de los mismos, la ejecuci√≥n de an√°lisis, las instrucciones para realizar gr√°ficos y la exportaci√≥n de los mismos, etc√©tera, lo llamamos script o rutina.\nAdemas del c√≥digo propiamente dicho, ning√∫n script est√° completo si no est√° correctamente anotado, es decir, si no contiene texto humanamente legible que permita seguir qu√© es lo que se est√° haciendo en el mismo. La forma de introducir un comentario en el c√≥digo es anteponer # a la linea en cuesti√≥n. De esta forma, el interprete de c√≥digo evitar√° su ejecuci√≥n.\n\n\n\n\n\n\n\n# Esto es un comentario y no se ejecutar√°\nprint(\"Esto es c√≥digo que s√≠ ser√° ejecutado\")\n\n[1] \"Esto es c√≥digo que s√≠ ser√° ejecutado\"\n\n\nOtra funci√≥n interesante relacionada a los comentarios, es que dentro de RStudio se puede generar √≠ndices de contenido para saltar de una parte a otra del c√≥digo f√°cilmente. Para generarlos, es necesario encerrar la entrada del √≠ndice con caracteres #. El n√∫mero de caracteres # del inicio ir√°n indicando el nivel de la entrada (de 1¬∫ a 6¬∫), mientras que al final siempre debe haber 4 caracteres # para que la l√≠nea sea reconocida como una entrada del √≠ndice. Esto ir√° produciendo un √≠ndice al que podremos acceder desde el men√∫ desplegable  Contenidos, ubicado abajo a la izquierda en el editor de scripts, o desplegando el √≠ndice de contenidos del archivo con el bot√≥n  Outline ubicado en la parte superior derecha del editor.\n\n Click en la imagen para agrandar.\n\nDe igual forma, cada entrada del √≠ndice nos permitir√° plegar o colapsar, las l√≠neas de c√≥digo que contenga. Esto puede ser √∫til para ocultar algunas secciones extremadamente largas o para secciones que, al momento de editar el script, no sean de inter√©s. Esta funcionalidad de colapsar l√≠neas, tambi√©n estar√° disponible para bloques de c√≥digo de control de flujo y para bloques que definan funciones. En el d√≠a 3 veremos espec√≠ficamente como usar estas estructuras de control de flujo y como crear funciones, por el momento, prestemos atenci√≥n en la captura siguiente a los n√∫meros de l√≠nea del editor y a las lineas d√≥nde vemos el bot√≥n , indicando que es un bloque de c√≥digo colapsado.\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-1",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-1",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nCree una rutina dentro de dia1 y cree un √≠ndice que contenga t√≠tulos de 1¬∫, 3¬∫, 5¬∫ y 6¬∫ nivel.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#carga-de-funciones-externas",
    "href": "dia1/2.1_FlujoTrabajo.html#carga-de-funciones-externas",
    "title": "Flujo de Trabajo en R",
    "section": "Carga de funciones externas",
    "text": "Carga de funciones externas\nM√°s adelante veremos en profundidad como se construye una funci√≥n, por el momento solo digamos que una funci√≥n es una forma de personalizar la ejecuci√≥n de c√≥digo para una funci√≥n espec√≠fica que nosotros dise√±amos. Para evitar repetir en todos nuestros scripts estas funciones personalizadas, podemos generar una biblioteca propia de funciones desde donde las cargaremos. As√≠ mismo, puede que alg√∫n/a colega haya dise√±ado una funci√≥n y nos la env√≠e, en cuyo caso tambi√©n podemos cargarla sin necesidad de copiar y pegar la misma en nuestro script.\nPara cargar una funci√≥n externa, por supuesto, primero debemos disponer de una. Para esta demostraci√≥n utilizaremos una funci√≥n muy sencilla que calcula una funci√≥n cuadr√°tica con un solo t√©rmino, es decir, es una funci√≥n de tipo y(x) = x¬≤:\n\n# Funci√≥n cuadr√°tica\nfun_cuad &lt;- function(x) { x^2 }\n\n# Probar la funci√≥n\nfun_cuad(c(1,2,3,4))\n\n[1]  1  4  9 16\n\n\nSi disponemos de una o m√∫ltiples funciones escritas en un archivo, podemos cargarlas directamente con la funci√≥n source().\n\n# Cargar la funci√≥n guardada en el archivo \"mifuncion.R\"\nsource(\"mifuncion.R\")\n\n# Probar la funci√≥n\nfun_cuad(c(1,2,3,4))\n\n[1]  1  4  9 16\n\n\nDe igual forma, tambi√©n podr√≠amos vincular directamente a un archivo online, pas√°ndole a source() la URL al c√≥digo fuente. En este caso ser√≠a:\n\nURL &lt;- \"https://raw.githubusercontent.com/pastornicolas/fundamentos_R/7abf94fd87129b5433c5ac70af1194e822b2afb6/dia1/mifuncion.R\"\nsource(URL)",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-2",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-2",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nDescargue el archivo con la funci√≥n al directorio de trabajo correspondiente a dia1 y c√°rguela utilizando source(). Pruebe su correcto funcionamiento para los valores:\n\n1, 2, 3, 4\n1, 10, 100",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#trabajando-sin-interfaz-gr√°fica",
    "href": "dia1/2.1_FlujoTrabajo.html#trabajando-sin-interfaz-gr√°fica",
    "title": "Flujo de Trabajo en R",
    "section": "Trabajando sin interfaz gr√°fica",
    "text": "Trabajando sin interfaz gr√°fica\nEn algunas ocasiones deberemos usar R de una forma no interactiva, esto es, daremos la instrucci√≥n para que se ejecute un script dado pero ya no vi√©ndolo dentro de RStudio y corriendo l√≠nea por l√≠nea, sino desde alguna herramienta propia del Sistema Operativo. Una situaci√≥n t√≠pica de esto es si alguna vez trabajamos con R dentro de un cluster de c√≥mputo de alto rendimiento, como por ejemplo en el CCAD (Centro de C√≥mputo de Alto Desempe√±o) de la UNC. Otras situaciones puede ser incorporar alg√∫n procesamiento con R dentro un pipeline de an√°lisis que utilice otros lenguajes en combinaci√≥n a R (e.g.¬†BASH, python, etc.)\nExisten m√∫ltiples formas, dependiendo del Sistema Operativo que estemos utilizando, para ejecutar un script de R desde el propio sistema, pero la forma m√°s sencilla es invocar al archivo ejecutable de R llamado Rscript. En sistemas Windows, t√≠picamente se encuentra en ‚ÄúC:\\Program Files\\R\\R-version\\bin\\x64\\‚Äù y debemos ejecutarlo desde el ‚ÄúSimbolo del sistema‚Äù. En sistemas GNU/Linux basta con abrir la terminal de nuestra preferencia y ejecutar:\n\nRscript mi_script.R\n\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-3",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-3",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nDescargue el archivo con el script para graficar la funci√≥n cuadr√°tica al directorio de trabajo correspondiente a dia1. Ejecute el script en su sistema por fuera de RStudio y chequee el correcto funcionamiento (i.e.¬†se deber√≠a ver en la consola los mensajes de salida y se deber√≠a crear un archivo PDF con el gr√°fico en el directorio donde se ejecut√≥).",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#ejercicio-4",
    "href": "dia1/2.1_FlujoTrabajo.html#ejercicio-4",
    "title": "Flujo de Trabajo en R",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nAbra el script que reci√©n ejecut√≥ en el editor de RStudio. Intente interpretar que hace cada l√≠nea, recuerde usar las funci√≥n help() o ? para acceder a las ayudas internas de las funciones. No se preocupe si por el momento no lo entiende completamente, para cuando este curso termine no habr√° ni una sola de esas l√≠neas que no sea capaz de interpretar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia1/2.1_FlujoTrabajo.html#algunas-m√°ximas-para-recordar-a-la-hora-de-programar-en-r",
    "href": "dia1/2.1_FlujoTrabajo.html#algunas-m√°ximas-para-recordar-a-la-hora-de-programar-en-r",
    "title": "Flujo de Trabajo en R",
    "section": "Algunas m√°ximas para recordar a la hora de programar en R",
    "text": "Algunas m√°ximas para recordar a la hora de programar en R\n\nExpl√≠cito es mejor que impl√≠cito. Ante la duda, declaremos expl√≠citamente todo lo que hacemos. Esto puede ser un poco engorroso, pero nos ayudara sobre todo en la etapa de aprendizaje inicial.\nOrden, orden, orden‚Ä¶ Intentar hacer el trabajo de forma sistem√°tica desde el comienzo siempre es m√°s f√°cil que luego intentar ordenar algo ca√≥tico cuando nos toque publicar y compartir nuestro c√≥digo.\nUn breve descanso a tiempo puede significar un ahorro de horas de frustraci√≥n. En ocasiones algo no anda y no podemos encontrar el error f√°cilmente. En esos momentos, cuando ya le√≠mos de arriba a abajo varias veces nuestro c√≥digo y seguimos sin poder encontrar el error, mejor es ir a prepararse un mate, dar una vuelta a la manzana, o lo que fuera. La gran mayor√≠a de estos errores dif√≠ciles se encuentran y resuelven luego de descansar un poco.\nNo estamos solos/as. Si lo anterior no funciona, recordemos que siempre podemos acudir a un foro web, a una IA, o a un/a colega que pueda revisar nuestro c√≥digo. Generalmente el problema que hace d√≠as no podemos solucionar, un par de ojos frescos y sin frustraci√≥n acumulada lo encuentran en cuesti√≥n de minutos, o incluso en un simple golpe de vista.\nRutas, rutas, rutas‚Ä¶ Dicho lo anterior, en general la mayor√≠a de los problemas surgen por no escribir correctamente las rutas a archivos de entrada o salida.\nPar√©ntesis, corchetes y llaves‚Ä¶ Dicho lo anterior, la segunda mayor√≠a de problemas surgen porque no respetamos alg√∫n requisito de la sintaxis, muy probablemente abrimos m√°s par√©ntesis (o corchetes o llaves) de los que cerramos, o insertamos un comentario sin querer en alg√∫n lado interrumpiendo un proceso, etc.\nNada mejor que aprender haciendo. Intentar aprender a programar sin tener un objetivo claro es mucho m√°s dif√≠cil. Si ahora mismo no tenemos algo concreto, desempolvemos esos an√°lisis que hicimos en otro software hace un tiempo e intentemos replicarlos en R, o busquemos el tutorial de alg√∫n paquete espec√≠fico que nos interese y lo estudiemos. Pero no paremos de usar el lenguaje, al menos, hasta que sintamos que tenemos cierta holgura en su uso.\nEn R, y en programaci√≥n en general, existen m√∫ltiples formas de hacer lo mismo. Es imposible conocer todas las formas, y obviamente, cada qui√©n ir√° encontrando aquellas que le resulten mejores (e incluso a lo largo del tiempo ver√°n que ir√°n cambiando). Si el c√≥digo hace lo que supone que tiene que hacer, entonces est√° bien. Siempre habr√° tiempo para perfeccionar la eficiencia y la est√©tica.\nEn ocasiones puede ser muy frustrante que algo no nos salga, evitemos la tentaci√≥n de volver a esa planilla de c√°lculo, o a ese software donde antes nos sal√≠a todo. Todo el tiempo que invirtamos va a dar much√≠simos frutos en el futuro.\nR, o el lenguaje que aprendamos a continuaci√≥n, es una herramienta fant√°stica pero no reemplaza de ninguna manera la formaci√≥n que tenemos. Por m√°s sofisticados que sean nuestros an√°lisis, al fin y al cabo, ser√° nuestro criterio profesional el que decida si el resultado es o no interesante. Nunca nos olvidemos que lo m√°s importante en nuestro trabajo son las preguntas que intentamos responder, no los medios que usamos para hacerlo.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Flujo de Trabajo en R"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html",
    "href": "dia4/6.1_graficos_base.html",
    "title": "Gr√°ficos con R base",
    "section": "",
    "text": "La representaci√≥n gr√°fica de datos y resultados es una parte importante de nuestro quehacer habitual en √°mbitos acad√©micos y cient√≠ficos. Una de las razones de la gran popularidad de R yace en su excelente apartado gr√°fico, con el cual se pueden producir gr√°ficos de buena calidad listos para publicar. De forma general, existen dos m√©todos principales para realizar gr√°ficos en R: el basado en el sistema b√°sico de R base y el basado en el paquete ggplot2. Ambas opciones poseen sus propias ventajas y desventajas y generalmente son usados a la par. Es decir, en algunas ocasiones convendr√° o ser√° m√°s c√≥modo, utilizar uno y, en otras ocasiones, ser√° mejor opci√≥n el otro.\n\n\n\n\n\n\nEn esta clase veremos como construir gr√°ficos con R base. Para empezar, definiremos un concepto relativo al nivel de la funci√≥n utilizada. Cuando grafiquemos podremos utilizaremos funciones de alto nivel, que son aquellas funciones que crean nuevos gr√°ficos, generalmente junto a los principales ejes, etiquetas √≥ t√≠tulos (e.g.¬†plot(), hist(), etc.); y funciones de bajo nivel, que son aquellas con las que podremos a√±adir elementos extras a un gr√°fico ya creado, como puntos, l√≠neas, flechas u otras etiquetas (e.g.¬†points(), text(), etc.). La combinaci√≥n de funciones de alto y bajo nivel nos permite realizar una enorme personalizaci√≥n del gr√°fico, aunque en algunas ocasiones esto puede llevar a que tengamos que definir cada aspecto del mismo. Este compromiso entre el nivel de personalizaci√≥n deseado y la cantidad de l√≠neas de c√≥digo necesarias puede parecer un poco abrumador al comienzo; pero, luego de un tiempo, en general optaremos siempre por una completa personalizaci√≥n. Sumado a esto, con el tiempo acumularemos plantillas propias para ciertos tipos de gr√°ficos que realicemos frecuentemente, y solo nos bastar√° con cambiar los datos y algunos par√°metros menores para obtener un nuevo gr√°fico listo para su publicaci√≥n (o al menos su revisi√≥n üò¨).\nEn cuanto a los tipos de gr√°ficos, las posibilidades que ofrece R son realmente ilimitadas y podr√≠an constituir en s√≠ mismo un curso de representaci√≥n gr√°fica. Por ello, para aprender los fundamentos del funcionamiento del apartado gr√°fico, veremos a continuaci√≥n dos tipos de gr√°ficos:\n\nHistogramas: nos permiten ver la distribuci√≥n de frecuencia en nuestros datos.\nGr√°ficos de dispersi√≥n (scatterplots): nos permiten evaluar la relaci√≥n entre variables cuantitativas.\nGr√°ficos de caja (boxplot): posibilitan comparar, entre categor√≠as, la distribuci√≥n cuantitativa de los datos basada en sus cuartiles y mostrando, adem√°s, intervalos de confianza y valores at√≠picos (outliers).\n\nEn cuanto a la personalizaci√≥n de los gr√°ficos, intentaremos a continuaci√≥n abordarlo desde una perspectiva progresiva, partiendo de los gr√°ficos simples elaborados con funciones de alto nivel, para luego ir sumando par√°metros y funciones de bajo nivel, haciendo m√°s complejo nuestro c√≥digo para definir los principales elementos que componen un gr√°fico.\n\n\n\nEn el primer d√≠a de clases, ya realizamos nuestro primer gr√°fico sencillo. Podemos, con todo lo que sabemos ahora, entender perfectamente como funciona el siguiente c√≥digo:\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n\n\n\n\n\n\n\n\nEmpezando por los datos, ya sabemos que la expresi√≥n 1:3 genera un vector compuesto por 1,2,3, as√≠ mismo rep(1,3) est√° generando una repetici√≥n de 1, tres veces, es decir: 1,1,1. La funci√≥n plot() espera 2 argumentos posicionales correspondientes a las coordenadas x e y, respectivamente. Por ende, lo que estamos haciendo es indicar que las posiciones para el eje x=(1,2,3) y las posiciones para el eje y=(1,1,1). De all√≠ que los 3 puntos graficados se ubiquen en las coordenadas (x,y)=(1,1),(1,2),(1,3).\n\n\nCon estos tres par√°metros b√°sicos de la funci√≥n plot() podemos indicar que tipo de marcador se graficar√° (pch), que colores queremos que estos marcadores tengan y que tama√±o relativo queremos que tengan (cex). Debajo podemos ver un ejemplo, pero nunca esta de m√°s tener a mano una carta de referencia descargada en nuestra PC o un sitio que podamos consultar online. Notar que a los colores podemos indicarlos con un n√∫mero del 1 al 8 (luego comienzan a ciclarse) como se muestra aqu√≠ abajo, o con sus nombres (e.g.¬†‚Äòblack‚Äô, ‚Äòred‚Äô, etc.) como en el ejemplo previo; as√≠ como tambi√©n podemos usar notaci√≥n hexadecimal o RGB.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#el-apartado-gr√°fico-de-r",
    "href": "dia4/6.1_graficos_base.html#el-apartado-gr√°fico-de-r",
    "title": "Gr√°ficos con R base",
    "section": "",
    "text": "La representaci√≥n gr√°fica de datos y resultados es una parte importante de nuestro quehacer habitual en √°mbitos acad√©micos y cient√≠ficos. Una de las razones de la gran popularidad de R yace en su excelente apartado gr√°fico, con el cual se pueden producir gr√°ficos de buena calidad listos para publicar. De forma general, existen dos m√©todos principales para realizar gr√°ficos en R: el basado en el sistema b√°sico de R base y el basado en el paquete ggplot2. Ambas opciones poseen sus propias ventajas y desventajas y generalmente son usados a la par. Es decir, en algunas ocasiones convendr√° o ser√° m√°s c√≥modo, utilizar uno y, en otras ocasiones, ser√° mejor opci√≥n el otro.\n\n\n\n\n\n\nEn esta clase veremos como construir gr√°ficos con R base. Para empezar, definiremos un concepto relativo al nivel de la funci√≥n utilizada. Cuando grafiquemos podremos utilizaremos funciones de alto nivel, que son aquellas funciones que crean nuevos gr√°ficos, generalmente junto a los principales ejes, etiquetas √≥ t√≠tulos (e.g.¬†plot(), hist(), etc.); y funciones de bajo nivel, que son aquellas con las que podremos a√±adir elementos extras a un gr√°fico ya creado, como puntos, l√≠neas, flechas u otras etiquetas (e.g.¬†points(), text(), etc.). La combinaci√≥n de funciones de alto y bajo nivel nos permite realizar una enorme personalizaci√≥n del gr√°fico, aunque en algunas ocasiones esto puede llevar a que tengamos que definir cada aspecto del mismo. Este compromiso entre el nivel de personalizaci√≥n deseado y la cantidad de l√≠neas de c√≥digo necesarias puede parecer un poco abrumador al comienzo; pero, luego de un tiempo, en general optaremos siempre por una completa personalizaci√≥n. Sumado a esto, con el tiempo acumularemos plantillas propias para ciertos tipos de gr√°ficos que realicemos frecuentemente, y solo nos bastar√° con cambiar los datos y algunos par√°metros menores para obtener un nuevo gr√°fico listo para su publicaci√≥n (o al menos su revisi√≥n üò¨).\nEn cuanto a los tipos de gr√°ficos, las posibilidades que ofrece R son realmente ilimitadas y podr√≠an constituir en s√≠ mismo un curso de representaci√≥n gr√°fica. Por ello, para aprender los fundamentos del funcionamiento del apartado gr√°fico, veremos a continuaci√≥n dos tipos de gr√°ficos:\n\nHistogramas: nos permiten ver la distribuci√≥n de frecuencia en nuestros datos.\nGr√°ficos de dispersi√≥n (scatterplots): nos permiten evaluar la relaci√≥n entre variables cuantitativas.\nGr√°ficos de caja (boxplot): posibilitan comparar, entre categor√≠as, la distribuci√≥n cuantitativa de los datos basada en sus cuartiles y mostrando, adem√°s, intervalos de confianza y valores at√≠picos (outliers).\n\nEn cuanto a la personalizaci√≥n de los gr√°ficos, intentaremos a continuaci√≥n abordarlo desde una perspectiva progresiva, partiendo de los gr√°ficos simples elaborados con funciones de alto nivel, para luego ir sumando par√°metros y funciones de bajo nivel, haciendo m√°s complejo nuestro c√≥digo para definir los principales elementos que componen un gr√°fico.\n\n\n\nEn el primer d√≠a de clases, ya realizamos nuestro primer gr√°fico sencillo. Podemos, con todo lo que sabemos ahora, entender perfectamente como funciona el siguiente c√≥digo:\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n\n\n\n\n\n\n\n\nEmpezando por los datos, ya sabemos que la expresi√≥n 1:3 genera un vector compuesto por 1,2,3, as√≠ mismo rep(1,3) est√° generando una repetici√≥n de 1, tres veces, es decir: 1,1,1. La funci√≥n plot() espera 2 argumentos posicionales correspondientes a las coordenadas x e y, respectivamente. Por ende, lo que estamos haciendo es indicar que las posiciones para el eje x=(1,2,3) y las posiciones para el eje y=(1,1,1). De all√≠ que los 3 puntos graficados se ubiquen en las coordenadas (x,y)=(1,1),(1,2),(1,3).\n\n\nCon estos tres par√°metros b√°sicos de la funci√≥n plot() podemos indicar que tipo de marcador se graficar√° (pch), que colores queremos que estos marcadores tengan y que tama√±o relativo queremos que tengan (cex). Debajo podemos ver un ejemplo, pero nunca esta de m√°s tener a mano una carta de referencia descargada en nuestra PC o un sitio que podamos consultar online. Notar que a los colores podemos indicarlos con un n√∫mero del 1 al 8 (luego comienzan a ciclarse) como se muestra aqu√≠ abajo, o con sus nombres (e.g.¬†‚Äòblack‚Äô, ‚Äòred‚Äô, etc.) como en el ejemplo previo; as√≠ como tambi√©n podemos usar notaci√≥n hexadecimal o RGB.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-1",
    "href": "dia4/6.1_graficos_base.html#ejercicio-1",
    "title": "Gr√°ficos con R base",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nUtilizando como molde el c√≥digo del gr√°fico previo, intente realizar uno que posea 3 puntos en las coordenadas (x,y)=(1,3),(2,1),(3,2), que estos puntos sean rombos de color azul, amarillo y rojo, respectivamente, todos con borde negro, y que su tama√±o relativo sea distinto y creciente, como se muestra a continuaci√≥n:\n\n\n\n\n\n\n\n\n\nAyuda: los valores de cex recomendados son 1,2,3. Para las formas con borde y relleno, col solo especifica el color del borde. Busque por sus medios qu√© par√°metro permite indicar el color de relleno.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#histogramas",
    "href": "dia4/6.1_graficos_base.html#histogramas",
    "title": "Gr√°ficos con R base",
    "section": "Histogramas",
    "text": "Histogramas\nLos histogramas son gr√°ficos que nos permiten visualizar la distribuci√≥n de frecuencia de los datos. Son muy utilizados en el an√°lisis exploratorio de los datos. Graficar histogramas en R es sumamente sencillo gracias a la funci√≥n hist(), una funci√≥n de alto nivel que permite realizarlos. Para el siguiente ejemplo, visualizaremos una distribuci√≥n normal de 1.000 observaciones con media = 0 y desviaci√≥n estandar = 0 .\n\nhist(rnorm(1000))\n\n\n\n\n\n\n\n\n\nEditando t√≠tulos y etiquetas de ejes\nComo podemos ver, el gr√°fico muestra una serie de barras con la frecuencia acumulada de los valores por intervalos igualmente espaciados. As√≠ mismo, como se trata de una funci√≥n de alto nivel, ya posee configurado algunas cuestiones, como las etiquetas de los ejes y el t√≠tulo. Para modificar esto √∫ltimo podr√≠amos incluir los par√°metros xlab e ylab, para las etiquetas de los ejes x e y, respectivamente y main para el t√≠tulo:\n\nhist(rnorm(1000),\n     main = \"Histograma de Distribuci√≥n Normal\",\n     xlab = \"Valores observados\",\n     ylab = \"Frecuencias\"\n)",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-2",
    "href": "dia4/6.1_graficos_base.html#ejercicio-2",
    "title": "Gr√°ficos con R base",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nAyud√°ndose con la documentaci√≥n de las funciones hist() y rnorm():\n\nGrafique un histograma correspondiente a un ensayo de medici√≥n de la altura de una poblaci√≥n para los cuales se midieron 350 personas y se obtuvo un valor promedio de 175 cm, con una desviaci√≥n est√°ndar de 5 cm.\nImagine que este ensayo se repiti√≥ en diferentes localidades, y ahora se encuentra con 30.000 observaciones, con media 173,47 cm y desviaci√≥n est√°ndar de 4,03 cm. Le han pedido que realice un nuevo histograma y le han informado que la editorial donde va a ser publicado el informe ha solicitado que el mismo posea t√≠tulo, etiquetas, colores de relleno y borde de las barras del histograma, muy espec√≠ficos. Para tal fin, le han adjuntado el ejemplo que se muestra debajo. Realice el nuevo gr√°fico y gu√°rdelo en la carpeta correspondiente a dia4.\n\n\n\n\n\n\n\n\n\n\n\nPuede que su gr√°fico se vea muy parecido, m√°s no igual al ejemplo. De hecho, cada vez que llama a la funci√≥n gr√°fica observar√° que el gr√°fico cambia, ¬øpor qu√© sucede esto?",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#gr√°fico-de-dispersi√≥n",
    "href": "dia4/6.1_graficos_base.html#gr√°fico-de-dispersi√≥n",
    "title": "Gr√°ficos con R base",
    "section": "Gr√°fico de dispersi√≥n",
    "text": "Gr√°fico de dispersi√≥n\nMuchas veces necesitamos evaluar si existe una relaci√≥n entre 2 variables cuantitativas. Una de las mejores formas de representar gr√°ficamente estas relaciones es mediante gr√°ficos de dispersi√≥n. A continuaci√≥n un ejemplo utilizando el conjunto de datos iris, con el que ya deber√≠a estar muy familiarizado.\n\nwith(iris, plot(Petal.Length, Sepal.Length, \n                pch = 21, col = \"black\", bg = \"forestgreen\", cex = 1,\n                xlim = c(0, 8),\n                ylim = c(0, 8)\n                )\n     )\n\n\n\n\n\n\n\n\n\n\nPara pensar: En el c√≥digo precedente apareci√≥ with(), una funci√≥n que previamente no hab√≠amos utilizado. Analice el c√≥digo y trate de descifrar que ventajas tiene su uso. Por supuesto, siempre puede consultar la ayuda con ?with().\n\nL√≠mites gr√°ficos\nEn el c√≥digo del gr√°fico previo, aparecieron algunas novedades: los par√°metros xlim e ylim. Como puede imaginarse, se trata de los par√°metros para fijar los l√≠mites de los ejes. Ambos par√°metros esperan un vector de largo 2 con los rangos de las coordenadas de x e y, y son muy √∫tiles a la hora de crear una base gr√°fica sin ning√∫n contenido, para luego rellenar con nuestros datos. Esta forma de trabajo es muy extendida al trabajar con gr√°ficos b√°sicos en R, y para ello cuando llamamos a la funci√≥n plot() debemos indicarle que el gr√°fico sea vac√≠o, con el par√°metro typ = \"n\".\nAntes de probar su funcionamiento, prestemos atenci√≥n al origen de coordenadas del gr√°fico (i.e.¬†(x,y)=(0,0)). Si nos fijamos bien, veremos que esa coordenada no coincide exactamente con el √°ngulo inferior izquierdo del gr√°fico. Esto es debido a que, por defecto, R utiliza una funci√≥n interna para extender levemente los ejes (ahora que lo notamos, podemos ver que sucede tambi√©n en los extremos de los ejes). Si no deseamos este comportamiento, podemos utilizar los par√°metros xaxs e yaxs. Estos par√°metros tienen dos configuraciones posibles: \"r\" o \"i\" (de ‚Äúregular‚Äù e ‚Äúinterno‚Äù), veamos como funcionan:\n\nplot(0,0, xlim = c(0, 100), ylim = c(0, 50), typ = \"n\", xaxs = \"r\", yaxs = \"i\")\n\n\n\n\n\n\n\n\n\n\n\n\nA√±adiendo otros elementos a nuestro gr√°fico\nEn el gr√°fico de dispersi√≥n, muchas veces es interesante mostrar el resultado de la correlaci√≥n entre las variables de forma gr√°fica, es decir, la l√≠nea (o curva) resultante del ajuste de un modelo de regresi√≥n entre las variables. Teniendo en cuenta el mismo conjunto de datos con el que venimos trabajando, recordemos primero como podemos obtener la regresi√≥n lineal usando la funci√≥n lm().\n\nlm(Sepal.Length ~ Petal.Length, data = iris)\n\n\nCall:\nlm(formula = Sepal.Length ~ Petal.Length, data = iris)\n\nCoefficients:\n (Intercept)  Petal.Length  \n      4.3066        0.4089  \n\n\nComo podemos ver, la funci√≥n lm() ya nos devuelve el intercepto y la pendiente de la recta que queremos graficar. Con el uso de la funci√≥n abline(), podemos a√±adirla al gr√°fico:\n\n# plot() -&gt; funci√≥n de alto nivel, crea la base del gr√°fico\nwith(iris, plot(Petal.Length, Sepal.Length,\n                pch= 21, col=\"black\", bg=\"forestgreen\", cex=1,\n                xlim=c(0, 8),\n                ylim=c(0,8)))\n# abline() -&gt; funci√≥n de bajo nivel, a√±ade la recta al gr√°fico ya creado\nwith(iris, abline(lm(Sepal.Length ~ Petal.Length)))\n\n\n\n\n\n\n\n\n\n\nAs√≠ como a√±adimos la recta resultante de la regresi√≥n, con abline() podemos a√±adir tantas l√≠neas verticales y horizontales como necesitemos, esto es muy √∫til para separar sectores del gr√°fico, hacer lineas de divisiones menores de los ejes, etc. Adem√°s, podemos llamar a otra funci√≥n de bajo nivel como es text(), para agregar sobre el gr√°fico los valores que componen la ecuaci√≥n de la recta:\n\n# Primero guardemos los resultados de la regresi√≥n en un nuevo objeto\nreg_l &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)\n\n# Gr√°fico base\nwith(iris, plot(Petal.Length, Sepal.Length,\n                pch= 21, col=\"black\", bg=\"forestgreen\", cex=1,\n                xlim=c(0, 8),\n                ylim=c(0,8)))\n# A√±adimos l√≠neas\nabline(v = c(2, 4, 6), h = c(2, 4, 6), col = \"grey\", lwd = 0.5)\nabline(reg_l)\n# A√±adiomos texto\ntext(3.5, 0, paste0(\"La ecuaci√≥n es: y = \",\n                    round(reg_l$coefficients[2],2),\n                    \"x\", \" + \",\n                    round(reg_l$coefficients[1],2)),\n     cex=0.9, adj=0)\n\n\n\n\n\n\n\n\n\n\n\n\nPersonalizando par√°metros seg√∫n los datos\nEn muchas ocasiones, necesitamos que en nuestro gr√°fico los colores o los marcadores se correspondan con alguna variable, ya sea esta cuantitativa o cualitativa. Existen diferentes formas de abordar esta situaci√≥n que depender√°n en gran medida de la complejidad y el tama√±o del conjunto de datos, as√≠ como de la diversidad de par√°metros que debamos modificar.\nUna aproximaci√≥n sencilla es generar en nuestro conjunto de datos una nueva variable que contenga los valores (num√©ricos o de texto) del par√°metro gr√°fico que necesitemos modificar. Otra forma puede ser utilizar un vector con nombres, que relacione las variables de los datos con los valores de los par√°metros gr√°ficos.\n\n# Creando un nuevo data.frame para graficar incluyendo una columna con colores por especie\ntoplot &lt;- iris[,c(1,3,5)]\ntoplot$Spe.Color &lt;- ifelse(toplot$Species == \"setosa\", \"forestgreen\",\n                           ifelse(toplot$Species == \"versicolor\", \"dodgerblue\",\n                                  \"red\")\n                           )\ntoplot[sample(nrow(toplot), 10),]\n\n    Sepal.Length Petal.Length    Species   Spe.Color\n50           5.0          1.4     setosa forestgreen\n22           5.1          1.5     setosa forestgreen\n81           5.5          3.8 versicolor  dodgerblue\n63           6.0          4.0 versicolor  dodgerblue\n31           4.8          1.6     setosa forestgreen\n84           6.0          5.1 versicolor  dodgerblue\n36           5.0          1.2     setosa forestgreen\n26           5.0          1.6     setosa forestgreen\n104          6.3          5.6  virginica         red\n134          6.3          5.1  virginica         red\n\n\n\n# Creando una referencia para los marcadores, seg√∫n la especie\npch_ref &lt;- c(\"setosa\" = 21,\n             \"versicolor\" = 22,\n             \"virginica\" = 23)\n# Creando una referencia para los colores, seg√∫n la especie\ncol_ref &lt;- c(\"setosa\" = \"forestgreen\",\n             \"versicolor\" = \"dodgerblue\",\n             \"virginica\" = \"red\")\n# Llamando al gr√°fico\nwith(toplot, plot(Sepal.Length, Petal.Length,\n                  pch = pch_ref[as.character(Species)],\n                  col = \"black\", bg = Spe.Color, cex = 1.5,\n                  xlim = c(0, 8),\n                  ylim = c(0,8)\n                  )\n)\n# Usando un for para a√±adir lineas de ajuste por especie\nwith(toplot,\n     for (spe in unique(Species)) {\n       abline(lm(Petal.Length ~ Sepal.Length,\n                 data = subset(toplot, Species == spe)),\n              col = col_ref[as.character(spe)], lwd = 3, lty = 3)\n     }\n)\n\n\n\n\n\n\n\n\n\n\n\n\nEditando los ejes del gr√°fico\nEn algunas ocasiones, quisi√©ramos que el gr√°fico no presentar√° el recuadro que lo rodea. Esto podemos lograrlo removiendo los ejes con el par√°metro axes = FALSE.\n\n# Llamando al gr√°fico\nwith(toplot, plot(Sepal.Length, Petal.Length,\n                pch = pch_ref[as.character(Species)],\n                col = \"black\", bg = Spe.Color, cex=1.5,\n                xlim = c(0, 8),\n                ylim = c(0,8),\n                axes=FALSE\n                )\n     )\n\n\n\n\n\n\n\n\n\n\nPor supuesto, ahora debemos a√±adir manualmente los ejes del gr√°fico. Para ello, usaremos otra funci√≥n de bajo nivel llamada axis() (recuerde revisar la documentaci√≥n para ver todas sus opciones) y, si as√≠ queremos, box() para dibujar una secci√≥n espec√≠fica del recuadro que enmarca el gr√°fico.\n\n# Llamando al gr√°fico\nwith(toplot, plot(Sepal.Length, Petal.Length,\n                pch = pch_ref[as.character(Species)],\n                col = \"black\", bg = Spe.Color, cex=1.5,\n                xlim = c(0, 8),\n                ylim = c(0,8),\n                xaxs = \"i\", yaxs = \"i\",\n                axes = FALSE\n                )\n     )\naxis(side = 1, at = c(0,4:8))\naxis(side = 2, at = c(seq(0,8,2)), las = 1, labels = c(\"cero\", \"dos\", 4, \"seis\", 8))\nbox(bty = \"l\")",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#gr√°ficos-de-caja",
    "href": "dia4/6.1_graficos_base.html#gr√°ficos-de-caja",
    "title": "Gr√°ficos con R base",
    "section": "Gr√°ficos de caja",
    "text": "Gr√°ficos de caja\n\nLeyendas y anotaciones\nA continuaci√≥n, cambiaremos el conjunto de datos por ToohGrowth, proveniente de un experimento de crecimiento dental en cobayos, seg√∫n la dosis de dos suplementos dietarios. Este tipo de experimentos es perfecto para poner en pr√°ctica la funci√≥n boxplot(), para crear gr√°ficos de caja. Como en este punto ya conocemos la l√≥gica de construcci√≥n de gr√°ficos, pasemos directamente al c√≥digo:\n\n# Llamado del primer conjunto de cajas (tratamiento = \"VC\")\nwith(subset(ToothGrowth, supp == \"VC\"),\n     boxplot(len ~ dose, axes = FALSE, ylim = c(0, 35),\n             boxwex = 0.15, at = 1:3 - 0.1, \n             col = \"yellow\", main = \"Crecimiento dental\",\n             xlab = \"Dosis de Vitamina C (mg/d√≠a)\", ylab = \"Largo del odontoblasto (¬µm)\",\n             )\n     )\n# Llamado del segundo conjunto de cajas (tratamiento = \"OJ\")\n# Notar el uso de \"add = TRUE\" y \"ann = FALSE\"\nwith(subset(ToothGrowth, supp == \"OJ\"),\n     boxplot(len ~ dose,  axes = FALSE, add = TRUE, ann = FALSE,\n             boxwex = 0.15, at = 1:3 + 0.1,\n             col = \"orange\"\n             )\n     )\n# Creando los ejes y recuadro\naxis(side = 1, at = c(1:3), labels = c(\"0.5\", \"1\", \"2\"))\naxis(side = 2, at = seq(0,35,5))\nbox(bty = \"l\", lwd = 2)\n# Graficando la flecha para se√±alar el outlier\nwith(subset(ToothGrowth, supp == \"VC\" & dose == 1),\n     arrows(x0 = 1.5, x1 = 1.8,\n            y0 = max(len), y1 = max(len),\n            lwd = 2, col = \"red\"\n  )\n)\n# Anadiendo la leyenda\nlegend(\"bottom\", horiz = TRUE, bty = \"n\",\n       legend = c(\"√Åcido asc√≥rbico\", \"Jugo de naranja\"),\n       fill = c(\"yellow\", \"orange\"))",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-3",
    "href": "dia4/6.1_graficos_base.html#ejercicio-3",
    "title": "Gr√°ficos con R base",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\n\nAnalice el c√≥digo precedente sin ejecutarlo, intentando describir que hace cada l√≠nea. Luego, copie el mismo a un script dentro de dia4 y ejec√∫telo por partes para entender el funcionamiento. Recuerde buscar en las ayudas interna de R y juegue con las opciones disponibles.\nRepita el gr√°fico pero con una flecha azul que indique el valor de la mediana para la 0,5 mm/d√≠a del suplemento jugo de naranja. Adem√°s, ubique la leyenda en la posici√≥n (x,y) = (2.5,5).",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#panel-de-m√∫ltiples-gr√°ficos",
    "href": "dia4/6.1_graficos_base.html#panel-de-m√∫ltiples-gr√°ficos",
    "title": "Gr√°ficos con R base",
    "section": "Panel de m√∫ltiples gr√°ficos",
    "text": "Panel de m√∫ltiples gr√°ficos\nEn muchas ocasiones, necesitamos mostrar en un solo panel varios gr√°ficos diferentes. Para ello, debemos utilizar la funci√≥n par(), que permite configurar todos los par√°metros b√°sicos del dispositivo gr√°fico que usa R. Esta funci√≥n tiene un nivel jer√°rquico superior a todas las que vimos previamente, ya que con la misma podemos cambiar el comportamiento por defecto de todos los par√°metros gr√°ficos de forma semi-permanente (i.e.¬†en el contexto de RStudio, durante toda la sesi√≥n en curso; y para dispositivos gr√°ficos externos, hasta que se reinicie el mismo). Por esto, si realizamos un cambio con par() para mostrar dos gr√°ficos en paralelo y, posteriormente, queremos realizar un nuevo gr√°fico solitario, debemos volver a configurar el dispositivo gr√°fico para mostrar un solo gr√°fico.\nA pesar de la gran cantidad de usos que posee la funci√≥n par(), dentro de los mas comunes est√°n la configuraci√≥n de m√°rgenes interiores (mar/mai) y exteriores (oma y omi), as√≠ como la configuraci√≥n del emplazamiento de m√∫ltiples gr√°ficos (mfrow).\nPara ver esto √∫ltimo en acci√≥n, pensemos que queremos realizar una regresi√≥n lineal y evaluar si los supuestos de la misma se cumplen. Para ellos, hagamos primero un modelo de regresi√≥n lineal entre las variables Petal.Length y Sepal.Length, para la especie I. virginica del conjunto de datos iris:\n\n# Creando y viendo el resultado del modelo de regresi√≥n lineal\nregL &lt;- lm(Petal.Length ~ Sepal.Length, data = subset(iris[iris$Species == \"virginica\",]))\nsummary(regL)\n\n\nCall:\nlm(formula = Petal.Length ~ Sepal.Length, data = subset(iris[iris$Species == \n    \"virginica\", ]))\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.68603 -0.21104  0.06399  0.18901  0.66402 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   0.61047    0.41711   1.464     0.15    \nSepal.Length  0.75008    0.06303  11.901  6.3e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2805 on 48 degrees of freedom\nMultiple R-squared:  0.7469,    Adjusted R-squared:  0.7416 \nF-statistic: 141.6 on 1 and 48 DF,  p-value: 6.298e-16\n\n\nHabiendo generado el objeto que contiene el resultado de lm(), podemos pedirle a R que lo grafique con plot(). Este es un ejemplo m√°s de la caracter√≠stica de polimorfismo que vimos en la clase introductoria, ya que plot() puede usarse sobre diferentes tipos de objetos, resultantes de diferentes funciones, y realizar√° diferentes gr√°ficos seg√∫n cada uno.\nComo en nuestro ejemplo la funci√≥n plot()realizar√° 4 gr√°ficos separados, configuraremos con par() la posibilidad de tener un panel de 4 gr√°ficos, con 2 filas y 2 columnas, esto es: mfrow = c(2,2).\n\n# Gr√°ficos de diagn√≥stico del modelo de regresi√≥n lineal\npar(mfrow = c(2,2))\nplot(regL)\n\n\n\n\n\n\n\n\nSi bien el an√°lisis y explicaci√≥n de cada uno de estos gr√°ficos excede este curso, puede encontrar en este v√≠nculo una buena explicaci√≥n con ejemplos. Adem√°s, puede inscribirse en la pr√≥xima edici√≥n del excelente curso dictado por Santiago Benitez-Vieyra: Introducci√≥n al lenguaje R. Modelos lineales y fundamentos de programaci√≥n.\nPara jugar un poco m√°s, repitamos los gr√°ficos pero ahora, pidiendo que los mismos est√©n emplazados en una sola fila de 4 columnas:\n\n# Gr√°ficos de diagn√≥stico del modelo de regresi√≥n lineal\npar(mfrow = c(1,4))\nplot(regL)",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "dia4/6.1_graficos_base.html#ejercicio-final",
    "href": "dia4/6.1_graficos_base.html#ejercicio-final",
    "title": "Gr√°ficos con R base",
    "section": "Ejercicio final",
    "text": "Ejercicio final\nCon el conjuntos de datos provisto, y ayud√°ndose con la documentaci√≥n de las funciones points(), segments() y title(), y buscando como funcionan los par√°metros gr√°ficos para l√≠neas lwd y lty, realice un gr√°fico como el que se muestra a continuaci√≥n.\n\ndata &lt;- data.frame(tipo = c(\"linea solida\",\"linea guiones\",\"linea punteada\", rep(\"punto\",4)),\n                   lposy = c(1,3,5, rep(NA,4)),\n                   lposx0 = c(rep(1,3), rep(NA, 4)),\n                   lposx1 = c(rep(4,3), rep(NA, 4)),\n                   pposx = c(rep(NA,3), 6,6,8,8),\n                   pposy = c(rep(NA,3), 2,4,2,4))\ndata \n\n            tipo lposy lposx0 lposx1 pposx pposy\n1   linea solida     1      1      4    NA    NA\n2  linea guiones     3      1      4    NA    NA\n3 linea punteada     5      1      4    NA    NA\n4          punto    NA     NA     NA     6     2\n5          punto    NA     NA     NA     6     4\n6          punto    NA     NA     NA     8     2\n7          punto    NA     NA     NA     8     4",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con R base"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fundamentos b√°sicos del lenguaje R",
    "section": "",
    "text": "Curso de posgrado | Doctorado en Cs. Biol√≥gicas | FCEFyN - UNC\n\n  Edici√≥n 2024\n\n\n¬°Bienvenid@s al curso!\nBienvenid@s al curso de Fundamentos b√°sicos del lenguaje R, dictado por el Dr.¬†Pablo Yair Huais y el Bi√≥l. Nicol√°s Pastor. El curso fue dise√±ado para proveer a l@s estudiantes con las herramientas necesarias para iniciarse en el uso del lenguaje R, mediante el aprendizaje de su l√≥gica program√°tica, y orientado a resolver problemas espec√≠ficos de sus temas de investigaci√≥n.\nA la izquierda de la pantalla se encuentran disponibles todos los recursos pr√°cticos y te√≥ricos que utilizaremos durante el desarrollo del curso.\n\n\nObjetivos espec√≠ficos\n\nQue l@s estudiantes adquieran conceptos te√≥ricos fundamentales y habilidades pr√°cticas b√°sicas del lenguaje R.\nQue l@s estudiantes desarrollen un pensamiento program√°tico en relaci√≥n al uso del lenguaje R.\nQue l@s estudiantes sean capaces de trasladar las herramientas aprendidas para la resoluci√≥n de problemas metodol√≥gicos espec√≠ficos de sus investigaciones.\n\n\n\nCronograma\n\n \n\n\n\nOtros cursos de inter√©s\nEn el Doctorado de Ciencias Biol√≥gicas (FCEFyN, Universidad Nacional de C√≥rdoba), se dictan con regularidad cursos introductorios y avanzados de modelos estad√≠sticos en R:\n\nIntroducci√≥n al lenguaje R. Modelos lineales y fundamentos de programaci√≥n Dictado por el Dr.¬†Santiago Benitez-Vieyra. Ver curso\nModelos Estad√≠sticos Avanzados Dictado por el Dr.¬†Santiago Benitez-Vieyra. Ver curso\nGr√°ficos para publicaciones en R con √©nfasis en ggplot2 Dictado por el Dr.¬†Andr√©s Blanco. Ver curso\n\n\n\nLicencia\n¬© 2024-2025 Pablo Y. Huais & Nicol√°s Pastor. Bajo licencia Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n \n\n\n\n\n Volver arriba",
    "crumbs": [
      "Inicio"
    ]
  },
  {
    "objectID": "dia3/5.1_control_flujo.html",
    "href": "dia3/5.1_control_flujo.html",
    "title": "Estructuras de control de flujo",
    "section": "",
    "text": "Como hemos visto hasta ahora, cuando escribimos c√≥digo y lo ejecutamos el mismo ser√° interpretando l√≠nea a l√≠nea, hasta que se ejecuta la √∫ltima l√≠nea y el programa termina. Las estructuras de control de flujo permiten alterar este comportamiento para adecuarlo a nuestras necesidades.\nEn general podemos definir dos grandes tipos de estructuras para el control de flujo. Por un lado, aquellas estructuras que evaluan condiciones y ejecutan un c√≥digo subsiguiente en funci√≥n de si el resultado de esa evaluaci√≥n es verdadero o falso, a estas estrucuturas las llamamos condicionales. Por otro lado, tenemos estructuras que repiten iterativamente una porci√≥n de c√≥digo mientras se cumpla alguna condici√≥n dada, a estas estructuras las denominamos bucles.\nNota: Antes de continuar es recomendable repasar los operadores aprendidos en el primer d√≠a de clases.\n\n\n\nEl constructo if ... else es una estructura de tipo condicional. En pocas palabras, if evaluar√° una condici√≥n dada y si la misma se cumple (i.e.¬†el resultado es TRUE), se ejecutar√° el c√≥digo correspondiente. Para definir un bloque de c√≥digo a ejecutarse si no se cumple la condici√≥n previamente establecida, utilizaremos else. Si adem√°s quisi√©ramos definir m√∫ltiples condiciones, en caso de que la primera no se cumpla y que deriven en diferentes ejecuciones, deberemos utilizar else if.\n\nif (TRUE) {\n  print(\"Se ejecutar√° el c√≥digo bajo 'if' ya que la condici√≥n resulta TRUE\")\n}\n\n[1] \"Se ejecutar√° el c√≥digo bajo 'if' ya que la condici√≥n resulta TRUE\"\n\n\n\n# Invertimos el TRUE usando el operador ! para obtener FALSE\nif (!TRUE) {\n  print(\"Se ejecutar√° el c√≥digo bajo 'if' ya que la condici√≥n resulta TRUE\")\n} else {\n  print(\"Se ejecutar√° el c√≥digo bajo 'else' dado que la condici√≥n resulta FALSE\")\n}\n\n[1] \"Se ejecutar√° el c√≥digo bajo 'else' dado que la condici√≥n resulta FALSE\"\n\n\n\n\nEn ocasiones necesitamos establecer m√∫ltiples condiciones. Ejecute el codigo siguiente varias veces, pero cambiando cada vez el valor de a.\n\na &lt;- 25\n\nif (a &gt;= 40) {\n  print(\"a es mayor o igual que 40\")\n} else if (a &gt;= 30) {\n  print(\"a es mayor o igual que 30\")\n} else if (a &gt;= 10) {\n  print(\"a es mayor o igual que 10\")\n} else {\n  print(\"a es menor a 10\")\n}\n\n[1] \"a es mayor o igual que 10\"\n\n\nPara pensar: ¬øQu√© pasa cuando, por ejemplo, a = 35? ¬øCu√°ntas evaluaciones independientes ser√≠an TRUE? ¬øQu√© porci√≥n de c√≥digo se ejecuta y por qu√©?\n\n\n\nEs posible agrupar diferentes evaluaciones utilizando los operadores Y (&) y O (|). Ejecute el siguiente c√≥digo varias veces cambiando los valores de a, b y c.\n\na &lt;- 35\nb &lt;- 12\nc &lt;- 65\n\nif (a &lt; 40 & b &gt; 10 | c &gt; 50) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 √≥ 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condici√≥n\")\n}\n\n[1] \"'a' es menor a 40 y 'b' mayor a 10 √≥ 'c' es mayor a 50\"\n\n\n\n\n\n\nCompare el c√≥digo de la celda precedente con el de aqu√≠ abajo. ¬øQu√© diferencias nota? Ejec√∫telo y explique el resultado con el obtenido usando el c√≥digo previo con los mismos valores para a, b y c.\n\na &lt;- 52\nb &lt;- 8\nc &lt;- 65\n\nif (a &lt; 40 & (b &gt; 10 | c &gt; 50)) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 √≥ 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condici√≥n\")\n}\n\n\n\nReci√©n vimos como combinar varias evaluaciones en una misma expresi√≥n, pero frecuentemente lo que necesitaremos es realizar diferentes evaluaciones de forma secuencial y ejecutar c√≥digo consecuentemente a los resultados obtenidos. Para ello podemos incoporar evaluaciones dentro de una evaluaci√≥n previa, es decir, anidar las evaluaciones.\n\na &lt;- 25\n\nif (a &gt; 10) {\n  print(\"'a' es mayor que 10\")\n  if (a &gt; 20) {\n    print(\"y tambi√©n es mayor que 20\")\n    if (a &gt; 30) {\n      print(\"y tambi√©n es mayor que 30\")\n    } else {\n      print(\"pero no mayor que 30\")\n    }\n  }\n}\n\n[1] \"'a' es mayor que 10\"\n[1] \"y tambi√©n es mayor que 20\"\n[1] \"pero no mayor que 30\"\n\n\nPara pensar: ¬øQu√© sucede si a &lt;= 10? ¬øQu√© podemos aprender de esta situaci√≥n? ¬øC√≥mo podr√≠amos salvar el inconveniente?\n\n\n\n\n\n\n\nAndrea y Ariel fueron a hacer compras, construya con c√≥digo que indique qui√©n gast√≥ m√°s dinero y de cuanto es la diferencia. El mismo c√≥digo debe servir para evaluar los tres escenarios siguientes:\n\nEscenario N¬∫ 1: compra_andrea = 690 / compra_ariel = 730\nEscenario N¬∫ 2: compra_andrea = 745 / compra_ariel = 745\nEscenario N¬∫ 3: compra_andrea = 890 / compra_ariel = 730\n\nAyudita: La salida esperada combina texto y variables, por ejemplo ‚ÄúAriel gasto x pesos m√°s que Andrea‚Äù. Para generar una salida de este tipo, podemos utilizar la funci√≥n paste() de la siguiente manera:\n\nvariable &lt;- 25\nprint(paste(\"La variable vale\", variable))\n\n[1] \"La variable vale 25\"\n\n\nSi no us√°ramos paste() obtendr√≠amos un error:\n\nprint(\"La variable vale\", variable)\n\nError in print.default(\"La variable vale\", variable): invalid printing digits 25\n\n\n\n\n\n\nEl constructo while es una estructura de tipo bucle. En pocas palabras, evaluar√° una condici√≥n y ejecutar√° repetitivamente una porci√≥n de c√≥digo siempre y cuando la misma se cumpla (i.e.¬†el resultado sea TRUE).\n\ni &lt;- 1\nwhile (i &lt; 4) {\n  print(paste(\"Repetici√≥n n¬∫:\", i))\n  i &lt;- i + 1\n}\n\n[1] \"Repetici√≥n n¬∫: 1\"\n[1] \"Repetici√≥n n¬∫: 2\"\n[1] \"Repetici√≥n n¬∫: 3\"\n\n\nAtenci√≥n!!! Si en el bucle precedente omitimos incrementar el contador i, nuestro bucle se ejecutar√° indefinidamente.\n\n\n\n\n\nTeniendo en cuenta lo que aprendimos sobre el acceso a elementos de un vector, podemos utilizar un bucle while para acceder a los mismos. No obstante, existen formas m√°s eficientes de hacer esto y lo veremos posteriormente.\n\ncarreras &lt;- c('Biolog√≠a', 'Bioqu√≠mica', 'Medicina', 'Nutrici√≥n')\ni &lt;- 1\nwhile (i &lt;= length(carreras)) {\n  print(carreras[i])\n  i &lt;- i + 1\n}\n\n[1] \"Biolog√≠a\"\n[1] \"Bioqu√≠mica\"\n[1] \"Medicina\"\n[1] \"Nutrici√≥n\"\n\n\n\n\n\nSi fuera necesario, podemos utilizar la declaraci√≥n break para interrumpir la ejecuci√≥n de un bucle, dada una condici√≥n establecida.\n\ni &lt;- 1\nwhile (i &lt; 12) {\n  print(paste(\"Repetici√≥n n¬∫:\", i))\n  if (i == 5) {\n    break\n  }\n  i &lt;- i + 1\n}\n\n[1] \"Repetici√≥n n¬∫: 1\"\n[1] \"Repetici√≥n n¬∫: 2\"\n[1] \"Repetici√≥n n¬∫: 3\"\n[1] \"Repetici√≥n n¬∫: 4\"\n[1] \"Repetici√≥n n¬∫: 5\"\n\n\n\n\n\nDe forma similar podemos, dada una condici√≥n, saltearnos ciertas ejecuciones dentro de un bucle. Para ello, utilizaremos la declaraci√≥n next.\n\ni &lt;- 0\nwhile (i &lt; 9) {\n  i &lt;- i + 1\n  if (i &gt; 2 & i &lt; 7) {\n    next\n  }\n  else {\n    print(paste(\"Repetici√≥n n¬∫:\", i))\n  }\n}\n\n[1] \"Repetici√≥n n¬∫: 1\"\n[1] \"Repetici√≥n n¬∫: 2\"\n[1] \"Repetici√≥n n¬∫: 7\"\n[1] \"Repetici√≥n n¬∫: 8\"\n[1] \"Repetici√≥n n¬∫: 9\"\n\n\n\n\n\n\nAnalice el siguiente c√≥digo SIN EJECUTARLO e interprete cu√°l es la salida esperada explicando que sucede en cada iteraci√≥n. Luego escriba a mano la salida exacta que dar√° este c√≥digo.\n\ncompras &lt;- c(\"pan\", \"queso\", \"jam√≥n\", \"tomate\", \"lechuga\")\n\ni &lt;- 1\nwhile (i &lt;= length(compras)) {\n  if (i == 1) {\n    print(paste(\"En mis lista de compras hay\", compras[i]))\n  }\n  else if (i == 2) {\n    print(paste(\"y tambi√©n hay\", compras[i]))\n  }\n  else {\n    print(paste(\"y\", compras[i]))\n  }\n  i &lt;- i + 1\n}\n\n\n\n\n\nEl constructo for es otra estructura de tipo bucle que permite iterar sobre una colecci√≥n dada de elementos. En pocas palabras, repetir√° la ejecuci√≥n de un mismo bloque de c√≥digo tantas veces como elementos existan en dicha secuencia. Por ello, es importante recordar que su sintaxis b√°sica es:\nfor (item in colecci√≥n) {c√≥digo a ejecutar}\n\nasistentes &lt;- c(\"Maria Guadalupe\", \"Clarisa\", \"Pablo Alejandro\", \"Andrea\", \"Ra√∫l Andres\", \"Evangelina\",\n                \"Juan Manuel\", \"Mar√≠a Azul\", \"Gala\", \"Lucille\", \"Lucas\", \"Ludmila\", \"Adolfo Emiliano\",\n                \"Ana\", \"Julieta Lourdes\", \"Joaqu√≠n\", \"Agostina\", \"Victoria Lucia\")\nfor (nombre in asistentes) {\n  print(nombre)\n}\n\n[1] \"Maria Guadalupe\"\n[1] \"Clarisa\"\n[1] \"Pablo Alejandro\"\n[1] \"Andrea\"\n[1] \"Ra√∫l Andres\"\n[1] \"Evangelina\"\n[1] \"Juan Manuel\"\n[1] \"Mar√≠a Azul\"\n[1] \"Gala\"\n[1] \"Lucille\"\n[1] \"Lucas\"\n[1] \"Ludmila\"\n[1] \"Adolfo Emiliano\"\n[1] \"Ana\"\n[1] \"Julieta Lourdes\"\n[1] \"Joaqu√≠n\"\n[1] \"Agostina\"\n[1] \"Victoria Lucia\"\n\n\nPara reflexionar: Compare el c√≥digo de la celda precedente con el que usamos para listar las carreras usando un bucle while. ¬øQue diferencias nota? ¬øCuando usar√≠a uno u otro constructo?\n\n\nEl bucle for es ampliamente utilizado para trabajar sobre filas y columnas de un data.frame. Por ejemplo, podemos tomar la tabla iris (cargada por defecto en R) y generar una nueva columna llamada Rel.SepPet.L:\n\niris$Rel.SepPet.L &lt;- NA\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa           NA\n2          4.9         3.0          1.4         0.2  setosa           NA\n3          4.7         3.2          1.3         0.2  setosa           NA\n4          4.6         3.1          1.5         0.2  setosa           NA\n5          5.0         3.6          1.4         0.2  setosa           NA\n6          5.4         3.9          1.7         0.4  setosa           NA\n\n\nGracias a un bucle for, es posible trabajar sobre cada fila para rellenar la nueva columna creada con los valores resultantes de la relaci√≥n (el ratio) entre el largo de los s√©palos y p√©talos:\n\nfor (i in 1:nrow(iris)) {\n  iris$Rel.SepPet.L[i] &lt;- iris$Sepal.Length[i] / iris$Petal.Length[i]\n}\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa     3.642857\n2          4.9         3.0          1.4         0.2  setosa     3.500000\n3          4.7         3.2          1.3         0.2  setosa     3.615385\n4          4.6         3.1          1.5         0.2  setosa     3.066667\n5          5.0         3.6          1.4         0.2  setosa     3.571429\n6          5.4         3.9          1.7         0.4  setosa     3.176471\n\n\nQueda claro que, como hemos visto anteriormente en el pr√°ctico de tablas, esta no es la forma m√°s eficiente de generar la nueva columna (¬øcu√°l ser√≠a la forma m√°s eficiente?). No obstante, este ejemplo sirve para entender como funciona un bucle for con un data.frame.\n\n\n\nCuando trabajamos con bucles, es muy frecuente establecer un rango para definir la iteraci√≥n. All√≠ entra en juego esta √∫til funci√≥n que, como vimos en la clase de Vectores devuelve una secuencia num√©rica y cuya sintaxis es: seq(inicio,fin,paso), recordando que por defecto (es decir, si no explicitamos el valor del argumento), el inicio es ‚Äú1‚Äù y el paso ‚Äú1‚Äù.\n\n# Secuencia de 1 a 3\nfor (n in seq(3)){\n  print(n)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n# Secuencia de 2 a 8, cada 2\nfor (n in seq(2,8,2)){\n  print(n)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n\n\n\n\n\nAl igual que vimos con while, podemos controlar el comportamiento de un bucle for de acuerdo a diferentes condiciones.\n\nfruta &lt;- c(\"banana\", \"manzana\", \"pera\")\n\nfor (f in fruta){\n  print(paste(\"Cortamos el bucle en su primer iteraci√≥n, con la fruta\", f))\n  if (f == \"banana\"){\n    break\n  }\n}\n\n[1] \"Cortamos el bucle en su primer iteraci√≥n, con la fruta banana\"\n\n\n\nfor (i in seq(1, 10)) {\n  if (i %% 2 != 0) {\n    next\n  } else {\n    print(paste(\"Me salteo todos los impares:\", i))\n  }\n}\n\n[1] \"Me salteo todos los impares: 2\"\n[1] \"Me salteo todos los impares: 4\"\n[1] \"Me salteo todos los impares: 6\"\n[1] \"Me salteo todos los impares: 8\"\n[1] \"Me salteo todos los impares: 10\"\n\n\n\n\n\nEn muchas ocasiones, nos encontraremos con la necesidad de operar iterativamente sobre m√°s de un conjunto de elementos, en esos casos podemos anidar los bucles.\n\nletras &lt;- c(\"a\", \"b\", \"c\")\nnumeros &lt;- c(1, 2, 3)\n\nfor (i in letras) {\n  for (j in numeros) {\n    print(paste(i, j))\n  }\n}\n\n[1] \"a 1\"\n[1] \"a 2\"\n[1] \"a 3\"\n[1] \"b 1\"\n[1] \"b 2\"\n[1] \"b 3\"\n[1] \"c 1\"\n[1] \"c 2\"\n[1] \"c 3\"\n\n\n\n\n\n\nall_num &lt;- c(17, 6, -12, 38, -88, 147, 1, -140, -19, 24, 74, -36)\n\nEscriba un c√≥digo que separe los n√∫meros positivos y los negativos del vector proporcionado en diferentes vectores. Imprima dichos vectores identificando su condici√≥n (positivo o negativo) y ordenados de menor a mayor.\nAyuda: ejecute el siguiente c√≥digo previamente y vea que aprende con ello.\n\nej1 &lt;- c(3,1,2)\nprint(paste(\"Ordenados ej1:\", sort(ej1)))\nprint(ej1)\n\nej2 &lt;- c(4,8,6)\ncat(\"Ordenados ej2:\", sort(ej2))\n\n\n\n\nEl uso de for anidados es muy √∫til para trabajar con matrices:\n\nmat &lt;- matrix(sample(1:100, size = 9), ncol = 3)\nmat\n\n     [,1] [,2] [,3]\n[1,]   90   49    2\n[2,]   15   59   99\n[3,]   44   26   11\n\nfor (i in 1:nrow(mat)) {\n  for( j in 1:ncol(mat)) {\n    print(paste(\"El elemento de la fila\", i, \"y columna\", j, \"es igual a\", mat[i, j]))\n  }\n}\n\n[1] \"El elemento de la fila 1 y columna 1 es igual a 90\"\n[1] \"El elemento de la fila 1 y columna 2 es igual a 49\"\n[1] \"El elemento de la fila 1 y columna 3 es igual a 2\"\n[1] \"El elemento de la fila 2 y columna 1 es igual a 15\"\n[1] \"El elemento de la fila 2 y columna 2 es igual a 59\"\n[1] \"El elemento de la fila 2 y columna 3 es igual a 99\"\n[1] \"El elemento de la fila 3 y columna 1 es igual a 44\"\n[1] \"El elemento de la fila 3 y columna 2 es igual a 26\"\n[1] \"El elemento de la fila 3 y columna 3 es igual a 11\"\n\n\n¬øC√≥mo funciona este c√≥digo? La mejor forma de entender un bucle individual, o bucles anidados, es evaluar el primer caso de la serie de repeticiones que el bucle est√° efectuando y evaluar el c√≥digo para el caso. Aqu√≠, el primer caso ser√≠a cuando i = 1 y j = 1.\n\n\n\n\n\nProgramar desde cero puede ser muy frustrante! Esto es, obviamente, la situaci√≥n m√°s com√∫n si nuestra experiencia en lenguajes de programaci√≥n es nula. A continuaci√≥n, presentamos algunos consejos que pueden ayudarnos a programar nuestras primeras rutinas:\n\nPaso a paso. No trates de programar la tarea propuesta entera de una sola vez, mejor descomponer la tarea en tareas m√°s peque√±as concatenadas entre s√≠.\nPseudoc√≥digo. Es √∫til pensar, o incluso escribir, los pasos a seguir mediante pseudoc√≥digo. Es decir, representar con oraciones simples cada tarea a realizar.\nEmpezar por el final. Muchas veces es √∫til pensar cu√°l es el resultado final que necesitamos y, luego, pensar desde all√≠, de atr√°s hacia adelante, que tareas debemos realizar para lograr ese resultado.\nEjemplo de juguete. Ante una tarea compleja, lo mejor es intentar generar la rutina deseada con un ejemplo de juguete o una peque√±a porci√≥n de lo que nos proponemos hacer. Luego, si sali√≥ todo bien, extender la soluci√≥n al problema en su totalidad.\nPrimero lo primero. Al programar un ciclo (for o while), puede ser dif√≠cil desarrollar de un tir√≥n todo el c√≥digo. Lo m√°s indicado es programar las operaciones a realizar sobre el primer caso y, luego de haber obtenido el resultado exitosamente, generalizar el c√≥digo para todos los casos.\nPensar en modo tabla. Si lo que quiero es obtener resultados en forma de tabla, una buena estrategia es generar la tabla con la o las columnas vac√≠as. Luego, utilizamos un ciclo for para ir rellenando cada fila de las columnas creadas. Si lo pensamos as√≠, nuestros ciclos for tendr√°n la siguiente forma general: for (i in 1:nrow(mi_tabla)) {mi c√≥digo a ejecutar}.\nEl error como parte del proceso. Es normal que aparezcan errores todo el tiempo, pero es clave aprender a leer y comprender los mensajes de error. Estos mensajes suelen indicar exactamente qu√© est√° fallando y d√≥nde.\n\n\n\n\n\nTomando de base el conjunto de datos iris, construya el siguiente data.frame:\n\nmodel_outputs &lt;- data.frame(Species = unique(iris$Species),\n                            Estimate = NA,\n                            P.value = NA)\nmodel_outputs\n\n     Species Estimate P.value\n1     setosa       NA      NA\n2 versicolor       NA      NA\n3  virginica       NA      NA\n\n\nLuego, eval√∫e modelos lineales que relacionen a la variable Petal.Length con la variable Sepal.Length en ese orden, para cada especie. Rellene la tabla generada anteriormente con los valores de los coeficientes (llamado Estimate o coeficiente de la variable predictora) y su valor-P (P.value) en cada caso. Para hacer esto, utilice alguna estructura de control de flujo aprendida!\nAyuda: utilice la funci√≥n lm() para construir los modelos lineales. La salida de la funci√≥n summary(), que act√∫a sobre el modelo (salida de lm()), contiene la informaci√≥n sobre los coeficientes que necesitamos.\n\n\n \n\n\n\n\n\nCuando vimos los condicionales, armamos un c√≥digo para evaluar en 3 escenarios diferentes los gastos que realizaron Andrea y Ariel. Ahora que sabe usar bucles, escriba un c√≥digo que evalu√© en una sola ejecuci√≥n todos los escenarios planteados en ese ejercicio y que utilice todos los constructos aprendidos, es decir: if, while y for.\nAyuda: recuerde que los bucles while pueden ejecutarse indefinidamente si no imponemos condiciones para que finalicen.",
    "crumbs": [
      "Inicio",
      "Unidad 3",
      "Estructuras de control de flujo"
    ]
  },
  {
    "objectID": "dia3/5.1_control_flujo.html#condicionales-y-bucles",
    "href": "dia3/5.1_control_flujo.html#condicionales-y-bucles",
    "title": "Estructuras de control de flujo",
    "section": "",
    "text": "Como hemos visto hasta ahora, cuando escribimos c√≥digo y lo ejecutamos el mismo ser√° interpretando l√≠nea a l√≠nea, hasta que se ejecuta la √∫ltima l√≠nea y el programa termina. Las estructuras de control de flujo permiten alterar este comportamiento para adecuarlo a nuestras necesidades.\nEn general podemos definir dos grandes tipos de estructuras para el control de flujo. Por un lado, aquellas estructuras que evaluan condiciones y ejecutan un c√≥digo subsiguiente en funci√≥n de si el resultado de esa evaluaci√≥n es verdadero o falso, a estas estrucuturas las llamamos condicionales. Por otro lado, tenemos estructuras que repiten iterativamente una porci√≥n de c√≥digo mientras se cumpla alguna condici√≥n dada, a estas estructuras las denominamos bucles.\nNota: Antes de continuar es recomendable repasar los operadores aprendidos en el primer d√≠a de clases.\n\n\n\nEl constructo if ... else es una estructura de tipo condicional. En pocas palabras, if evaluar√° una condici√≥n dada y si la misma se cumple (i.e.¬†el resultado es TRUE), se ejecutar√° el c√≥digo correspondiente. Para definir un bloque de c√≥digo a ejecutarse si no se cumple la condici√≥n previamente establecida, utilizaremos else. Si adem√°s quisi√©ramos definir m√∫ltiples condiciones, en caso de que la primera no se cumpla y que deriven en diferentes ejecuciones, deberemos utilizar else if.\n\nif (TRUE) {\n  print(\"Se ejecutar√° el c√≥digo bajo 'if' ya que la condici√≥n resulta TRUE\")\n}\n\n[1] \"Se ejecutar√° el c√≥digo bajo 'if' ya que la condici√≥n resulta TRUE\"\n\n\n\n# Invertimos el TRUE usando el operador ! para obtener FALSE\nif (!TRUE) {\n  print(\"Se ejecutar√° el c√≥digo bajo 'if' ya que la condici√≥n resulta TRUE\")\n} else {\n  print(\"Se ejecutar√° el c√≥digo bajo 'else' dado que la condici√≥n resulta FALSE\")\n}\n\n[1] \"Se ejecutar√° el c√≥digo bajo 'else' dado que la condici√≥n resulta FALSE\"\n\n\n\n\nEn ocasiones necesitamos establecer m√∫ltiples condiciones. Ejecute el codigo siguiente varias veces, pero cambiando cada vez el valor de a.\n\na &lt;- 25\n\nif (a &gt;= 40) {\n  print(\"a es mayor o igual que 40\")\n} else if (a &gt;= 30) {\n  print(\"a es mayor o igual que 30\")\n} else if (a &gt;= 10) {\n  print(\"a es mayor o igual que 10\")\n} else {\n  print(\"a es menor a 10\")\n}\n\n[1] \"a es mayor o igual que 10\"\n\n\nPara pensar: ¬øQu√© pasa cuando, por ejemplo, a = 35? ¬øCu√°ntas evaluaciones independientes ser√≠an TRUE? ¬øQu√© porci√≥n de c√≥digo se ejecuta y por qu√©?\n\n\n\nEs posible agrupar diferentes evaluaciones utilizando los operadores Y (&) y O (|). Ejecute el siguiente c√≥digo varias veces cambiando los valores de a, b y c.\n\na &lt;- 35\nb &lt;- 12\nc &lt;- 65\n\nif (a &lt; 40 & b &gt; 10 | c &gt; 50) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 √≥ 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condici√≥n\")\n}\n\n[1] \"'a' es menor a 40 y 'b' mayor a 10 √≥ 'c' es mayor a 50\"\n\n\n\n\n\n\nCompare el c√≥digo de la celda precedente con el de aqu√≠ abajo. ¬øQu√© diferencias nota? Ejec√∫telo y explique el resultado con el obtenido usando el c√≥digo previo con los mismos valores para a, b y c.\n\na &lt;- 52\nb &lt;- 8\nc &lt;- 65\n\nif (a &lt; 40 & (b &gt; 10 | c &gt; 50)) {\n  print(\"'a' es menor a 40 y 'b' mayor a 10 √≥ 'c' es mayor a 50\")\n} else {\n  print(\"No se cumple ninguna condici√≥n\")\n}\n\n\n\nReci√©n vimos como combinar varias evaluaciones en una misma expresi√≥n, pero frecuentemente lo que necesitaremos es realizar diferentes evaluaciones de forma secuencial y ejecutar c√≥digo consecuentemente a los resultados obtenidos. Para ello podemos incoporar evaluaciones dentro de una evaluaci√≥n previa, es decir, anidar las evaluaciones.\n\na &lt;- 25\n\nif (a &gt; 10) {\n  print(\"'a' es mayor que 10\")\n  if (a &gt; 20) {\n    print(\"y tambi√©n es mayor que 20\")\n    if (a &gt; 30) {\n      print(\"y tambi√©n es mayor que 30\")\n    } else {\n      print(\"pero no mayor que 30\")\n    }\n  }\n}\n\n[1] \"'a' es mayor que 10\"\n[1] \"y tambi√©n es mayor que 20\"\n[1] \"pero no mayor que 30\"\n\n\nPara pensar: ¬øQu√© sucede si a &lt;= 10? ¬øQu√© podemos aprender de esta situaci√≥n? ¬øC√≥mo podr√≠amos salvar el inconveniente?\n\n\n\n\n\n\n\nAndrea y Ariel fueron a hacer compras, construya con c√≥digo que indique qui√©n gast√≥ m√°s dinero y de cuanto es la diferencia. El mismo c√≥digo debe servir para evaluar los tres escenarios siguientes:\n\nEscenario N¬∫ 1: compra_andrea = 690 / compra_ariel = 730\nEscenario N¬∫ 2: compra_andrea = 745 / compra_ariel = 745\nEscenario N¬∫ 3: compra_andrea = 890 / compra_ariel = 730\n\nAyudita: La salida esperada combina texto y variables, por ejemplo ‚ÄúAriel gasto x pesos m√°s que Andrea‚Äù. Para generar una salida de este tipo, podemos utilizar la funci√≥n paste() de la siguiente manera:\n\nvariable &lt;- 25\nprint(paste(\"La variable vale\", variable))\n\n[1] \"La variable vale 25\"\n\n\nSi no us√°ramos paste() obtendr√≠amos un error:\n\nprint(\"La variable vale\", variable)\n\nError in print.default(\"La variable vale\", variable): invalid printing digits 25\n\n\n\n\n\n\nEl constructo while es una estructura de tipo bucle. En pocas palabras, evaluar√° una condici√≥n y ejecutar√° repetitivamente una porci√≥n de c√≥digo siempre y cuando la misma se cumpla (i.e.¬†el resultado sea TRUE).\n\ni &lt;- 1\nwhile (i &lt; 4) {\n  print(paste(\"Repetici√≥n n¬∫:\", i))\n  i &lt;- i + 1\n}\n\n[1] \"Repetici√≥n n¬∫: 1\"\n[1] \"Repetici√≥n n¬∫: 2\"\n[1] \"Repetici√≥n n¬∫: 3\"\n\n\nAtenci√≥n!!! Si en el bucle precedente omitimos incrementar el contador i, nuestro bucle se ejecutar√° indefinidamente.\n\n\n\n\n\nTeniendo en cuenta lo que aprendimos sobre el acceso a elementos de un vector, podemos utilizar un bucle while para acceder a los mismos. No obstante, existen formas m√°s eficientes de hacer esto y lo veremos posteriormente.\n\ncarreras &lt;- c('Biolog√≠a', 'Bioqu√≠mica', 'Medicina', 'Nutrici√≥n')\ni &lt;- 1\nwhile (i &lt;= length(carreras)) {\n  print(carreras[i])\n  i &lt;- i + 1\n}\n\n[1] \"Biolog√≠a\"\n[1] \"Bioqu√≠mica\"\n[1] \"Medicina\"\n[1] \"Nutrici√≥n\"\n\n\n\n\n\nSi fuera necesario, podemos utilizar la declaraci√≥n break para interrumpir la ejecuci√≥n de un bucle, dada una condici√≥n establecida.\n\ni &lt;- 1\nwhile (i &lt; 12) {\n  print(paste(\"Repetici√≥n n¬∫:\", i))\n  if (i == 5) {\n    break\n  }\n  i &lt;- i + 1\n}\n\n[1] \"Repetici√≥n n¬∫: 1\"\n[1] \"Repetici√≥n n¬∫: 2\"\n[1] \"Repetici√≥n n¬∫: 3\"\n[1] \"Repetici√≥n n¬∫: 4\"\n[1] \"Repetici√≥n n¬∫: 5\"\n\n\n\n\n\nDe forma similar podemos, dada una condici√≥n, saltearnos ciertas ejecuciones dentro de un bucle. Para ello, utilizaremos la declaraci√≥n next.\n\ni &lt;- 0\nwhile (i &lt; 9) {\n  i &lt;- i + 1\n  if (i &gt; 2 & i &lt; 7) {\n    next\n  }\n  else {\n    print(paste(\"Repetici√≥n n¬∫:\", i))\n  }\n}\n\n[1] \"Repetici√≥n n¬∫: 1\"\n[1] \"Repetici√≥n n¬∫: 2\"\n[1] \"Repetici√≥n n¬∫: 7\"\n[1] \"Repetici√≥n n¬∫: 8\"\n[1] \"Repetici√≥n n¬∫: 9\"\n\n\n\n\n\n\nAnalice el siguiente c√≥digo SIN EJECUTARLO e interprete cu√°l es la salida esperada explicando que sucede en cada iteraci√≥n. Luego escriba a mano la salida exacta que dar√° este c√≥digo.\n\ncompras &lt;- c(\"pan\", \"queso\", \"jam√≥n\", \"tomate\", \"lechuga\")\n\ni &lt;- 1\nwhile (i &lt;= length(compras)) {\n  if (i == 1) {\n    print(paste(\"En mis lista de compras hay\", compras[i]))\n  }\n  else if (i == 2) {\n    print(paste(\"y tambi√©n hay\", compras[i]))\n  }\n  else {\n    print(paste(\"y\", compras[i]))\n  }\n  i &lt;- i + 1\n}\n\n\n\n\n\nEl constructo for es otra estructura de tipo bucle que permite iterar sobre una colecci√≥n dada de elementos. En pocas palabras, repetir√° la ejecuci√≥n de un mismo bloque de c√≥digo tantas veces como elementos existan en dicha secuencia. Por ello, es importante recordar que su sintaxis b√°sica es:\nfor (item in colecci√≥n) {c√≥digo a ejecutar}\n\nasistentes &lt;- c(\"Maria Guadalupe\", \"Clarisa\", \"Pablo Alejandro\", \"Andrea\", \"Ra√∫l Andres\", \"Evangelina\",\n                \"Juan Manuel\", \"Mar√≠a Azul\", \"Gala\", \"Lucille\", \"Lucas\", \"Ludmila\", \"Adolfo Emiliano\",\n                \"Ana\", \"Julieta Lourdes\", \"Joaqu√≠n\", \"Agostina\", \"Victoria Lucia\")\nfor (nombre in asistentes) {\n  print(nombre)\n}\n\n[1] \"Maria Guadalupe\"\n[1] \"Clarisa\"\n[1] \"Pablo Alejandro\"\n[1] \"Andrea\"\n[1] \"Ra√∫l Andres\"\n[1] \"Evangelina\"\n[1] \"Juan Manuel\"\n[1] \"Mar√≠a Azul\"\n[1] \"Gala\"\n[1] \"Lucille\"\n[1] \"Lucas\"\n[1] \"Ludmila\"\n[1] \"Adolfo Emiliano\"\n[1] \"Ana\"\n[1] \"Julieta Lourdes\"\n[1] \"Joaqu√≠n\"\n[1] \"Agostina\"\n[1] \"Victoria Lucia\"\n\n\nPara reflexionar: Compare el c√≥digo de la celda precedente con el que usamos para listar las carreras usando un bucle while. ¬øQue diferencias nota? ¬øCuando usar√≠a uno u otro constructo?\n\n\nEl bucle for es ampliamente utilizado para trabajar sobre filas y columnas de un data.frame. Por ejemplo, podemos tomar la tabla iris (cargada por defecto en R) y generar una nueva columna llamada Rel.SepPet.L:\n\niris$Rel.SepPet.L &lt;- NA\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa           NA\n2          4.9         3.0          1.4         0.2  setosa           NA\n3          4.7         3.2          1.3         0.2  setosa           NA\n4          4.6         3.1          1.5         0.2  setosa           NA\n5          5.0         3.6          1.4         0.2  setosa           NA\n6          5.4         3.9          1.7         0.4  setosa           NA\n\n\nGracias a un bucle for, es posible trabajar sobre cada fila para rellenar la nueva columna creada con los valores resultantes de la relaci√≥n (el ratio) entre el largo de los s√©palos y p√©talos:\n\nfor (i in 1:nrow(iris)) {\n  iris$Rel.SepPet.L[i] &lt;- iris$Sepal.Length[i] / iris$Petal.Length[i]\n}\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Rel.SepPet.L\n1          5.1         3.5          1.4         0.2  setosa     3.642857\n2          4.9         3.0          1.4         0.2  setosa     3.500000\n3          4.7         3.2          1.3         0.2  setosa     3.615385\n4          4.6         3.1          1.5         0.2  setosa     3.066667\n5          5.0         3.6          1.4         0.2  setosa     3.571429\n6          5.4         3.9          1.7         0.4  setosa     3.176471\n\n\nQueda claro que, como hemos visto anteriormente en el pr√°ctico de tablas, esta no es la forma m√°s eficiente de generar la nueva columna (¬øcu√°l ser√≠a la forma m√°s eficiente?). No obstante, este ejemplo sirve para entender como funciona un bucle for con un data.frame.\n\n\n\nCuando trabajamos con bucles, es muy frecuente establecer un rango para definir la iteraci√≥n. All√≠ entra en juego esta √∫til funci√≥n que, como vimos en la clase de Vectores devuelve una secuencia num√©rica y cuya sintaxis es: seq(inicio,fin,paso), recordando que por defecto (es decir, si no explicitamos el valor del argumento), el inicio es ‚Äú1‚Äù y el paso ‚Äú1‚Äù.\n\n# Secuencia de 1 a 3\nfor (n in seq(3)){\n  print(n)\n}\n\n[1] 1\n[1] 2\n[1] 3\n\n# Secuencia de 2 a 8, cada 2\nfor (n in seq(2,8,2)){\n  print(n)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n\n\n\n\n\nAl igual que vimos con while, podemos controlar el comportamiento de un bucle for de acuerdo a diferentes condiciones.\n\nfruta &lt;- c(\"banana\", \"manzana\", \"pera\")\n\nfor (f in fruta){\n  print(paste(\"Cortamos el bucle en su primer iteraci√≥n, con la fruta\", f))\n  if (f == \"banana\"){\n    break\n  }\n}\n\n[1] \"Cortamos el bucle en su primer iteraci√≥n, con la fruta banana\"\n\n\n\nfor (i in seq(1, 10)) {\n  if (i %% 2 != 0) {\n    next\n  } else {\n    print(paste(\"Me salteo todos los impares:\", i))\n  }\n}\n\n[1] \"Me salteo todos los impares: 2\"\n[1] \"Me salteo todos los impares: 4\"\n[1] \"Me salteo todos los impares: 6\"\n[1] \"Me salteo todos los impares: 8\"\n[1] \"Me salteo todos los impares: 10\"\n\n\n\n\n\nEn muchas ocasiones, nos encontraremos con la necesidad de operar iterativamente sobre m√°s de un conjunto de elementos, en esos casos podemos anidar los bucles.\n\nletras &lt;- c(\"a\", \"b\", \"c\")\nnumeros &lt;- c(1, 2, 3)\n\nfor (i in letras) {\n  for (j in numeros) {\n    print(paste(i, j))\n  }\n}\n\n[1] \"a 1\"\n[1] \"a 2\"\n[1] \"a 3\"\n[1] \"b 1\"\n[1] \"b 2\"\n[1] \"b 3\"\n[1] \"c 1\"\n[1] \"c 2\"\n[1] \"c 3\"\n\n\n\n\n\n\nall_num &lt;- c(17, 6, -12, 38, -88, 147, 1, -140, -19, 24, 74, -36)\n\nEscriba un c√≥digo que separe los n√∫meros positivos y los negativos del vector proporcionado en diferentes vectores. Imprima dichos vectores identificando su condici√≥n (positivo o negativo) y ordenados de menor a mayor.\nAyuda: ejecute el siguiente c√≥digo previamente y vea que aprende con ello.\n\nej1 &lt;- c(3,1,2)\nprint(paste(\"Ordenados ej1:\", sort(ej1)))\nprint(ej1)\n\nej2 &lt;- c(4,8,6)\ncat(\"Ordenados ej2:\", sort(ej2))\n\n\n\n\nEl uso de for anidados es muy √∫til para trabajar con matrices:\n\nmat &lt;- matrix(sample(1:100, size = 9), ncol = 3)\nmat\n\n     [,1] [,2] [,3]\n[1,]   90   49    2\n[2,]   15   59   99\n[3,]   44   26   11\n\nfor (i in 1:nrow(mat)) {\n  for( j in 1:ncol(mat)) {\n    print(paste(\"El elemento de la fila\", i, \"y columna\", j, \"es igual a\", mat[i, j]))\n  }\n}\n\n[1] \"El elemento de la fila 1 y columna 1 es igual a 90\"\n[1] \"El elemento de la fila 1 y columna 2 es igual a 49\"\n[1] \"El elemento de la fila 1 y columna 3 es igual a 2\"\n[1] \"El elemento de la fila 2 y columna 1 es igual a 15\"\n[1] \"El elemento de la fila 2 y columna 2 es igual a 59\"\n[1] \"El elemento de la fila 2 y columna 3 es igual a 99\"\n[1] \"El elemento de la fila 3 y columna 1 es igual a 44\"\n[1] \"El elemento de la fila 3 y columna 2 es igual a 26\"\n[1] \"El elemento de la fila 3 y columna 3 es igual a 11\"\n\n\n¬øC√≥mo funciona este c√≥digo? La mejor forma de entender un bucle individual, o bucles anidados, es evaluar el primer caso de la serie de repeticiones que el bucle est√° efectuando y evaluar el c√≥digo para el caso. Aqu√≠, el primer caso ser√≠a cuando i = 1 y j = 1.\n\n\n\n\n\nProgramar desde cero puede ser muy frustrante! Esto es, obviamente, la situaci√≥n m√°s com√∫n si nuestra experiencia en lenguajes de programaci√≥n es nula. A continuaci√≥n, presentamos algunos consejos que pueden ayudarnos a programar nuestras primeras rutinas:\n\nPaso a paso. No trates de programar la tarea propuesta entera de una sola vez, mejor descomponer la tarea en tareas m√°s peque√±as concatenadas entre s√≠.\nPseudoc√≥digo. Es √∫til pensar, o incluso escribir, los pasos a seguir mediante pseudoc√≥digo. Es decir, representar con oraciones simples cada tarea a realizar.\nEmpezar por el final. Muchas veces es √∫til pensar cu√°l es el resultado final que necesitamos y, luego, pensar desde all√≠, de atr√°s hacia adelante, que tareas debemos realizar para lograr ese resultado.\nEjemplo de juguete. Ante una tarea compleja, lo mejor es intentar generar la rutina deseada con un ejemplo de juguete o una peque√±a porci√≥n de lo que nos proponemos hacer. Luego, si sali√≥ todo bien, extender la soluci√≥n al problema en su totalidad.\nPrimero lo primero. Al programar un ciclo (for o while), puede ser dif√≠cil desarrollar de un tir√≥n todo el c√≥digo. Lo m√°s indicado es programar las operaciones a realizar sobre el primer caso y, luego de haber obtenido el resultado exitosamente, generalizar el c√≥digo para todos los casos.\nPensar en modo tabla. Si lo que quiero es obtener resultados en forma de tabla, una buena estrategia es generar la tabla con la o las columnas vac√≠as. Luego, utilizamos un ciclo for para ir rellenando cada fila de las columnas creadas. Si lo pensamos as√≠, nuestros ciclos for tendr√°n la siguiente forma general: for (i in 1:nrow(mi_tabla)) {mi c√≥digo a ejecutar}.\nEl error como parte del proceso. Es normal que aparezcan errores todo el tiempo, pero es clave aprender a leer y comprender los mensajes de error. Estos mensajes suelen indicar exactamente qu√© est√° fallando y d√≥nde.\n\n\n\n\n\nTomando de base el conjunto de datos iris, construya el siguiente data.frame:\n\nmodel_outputs &lt;- data.frame(Species = unique(iris$Species),\n                            Estimate = NA,\n                            P.value = NA)\nmodel_outputs\n\n     Species Estimate P.value\n1     setosa       NA      NA\n2 versicolor       NA      NA\n3  virginica       NA      NA\n\n\nLuego, eval√∫e modelos lineales que relacionen a la variable Petal.Length con la variable Sepal.Length en ese orden, para cada especie. Rellene la tabla generada anteriormente con los valores de los coeficientes (llamado Estimate o coeficiente de la variable predictora) y su valor-P (P.value) en cada caso. Para hacer esto, utilice alguna estructura de control de flujo aprendida!\nAyuda: utilice la funci√≥n lm() para construir los modelos lineales. La salida de la funci√≥n summary(), que act√∫a sobre el modelo (salida de lm()), contiene la informaci√≥n sobre los coeficientes que necesitamos.\n\n\n \n\n\n\n\n\nCuando vimos los condicionales, armamos un c√≥digo para evaluar en 3 escenarios diferentes los gastos que realizaron Andrea y Ariel. Ahora que sabe usar bucles, escriba un c√≥digo que evalu√© en una sola ejecuci√≥n todos los escenarios planteados en ese ejercicio y que utilice todos los constructos aprendidos, es decir: if, while y for.\nAyuda: recuerde que los bucles while pueden ejecutarse indefinidamente si no imponemos condiciones para que finalicen.",
    "crumbs": [
      "Inicio",
      "Unidad 3",
      "Estructuras de control de flujo"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html",
    "href": "dia5/7.1_Funciones.html",
    "title": "Funciones",
    "section": "",
    "text": "Las funciones en R son las herramientas que nos permiten realizar una gran diversidad de an√°lisis. Para ello, R provee de una numerosa y potente biblioteca de ellas, las cuales vienen instalada por defecto. Adem√°s, como hemos desarrollado al principio del curso, existe una abanico mega-diverso de paquetes de R desarrollados por los propios usuarios, especialmente desarrollados para la realizaci√≥n de tareas espec√≠ficas.\nNo obstante, es usual que en un flujo de trabajo de intermedio a avanzado necesitemos desarrollar nuestras propias funciones. La raz√≥n para ello radica en la ejecuci√≥n de una tarea muy espec√≠fica como parte de nuestros an√°lisis, pero que al mismo tiempo debe realizarse m√∫ltiples veces para que amerite su desarrollo en forma de funci√≥n.\nLas funciones en R se asignan a objetos, cuyo nombre ser√° el nombre de la funci√≥n, con la expresi√≥n function(). Dentro de los par√©ntesis debemos indicar los argumentos de la funci√≥n. Estos ser√°n los objetos con los que la funci√≥n trabajar√° de alguna manera, y devolver√° alguna salida determinada. La sintaxis general es la siguiente:\n\nmi_funcion &lt;- function(argumento1, argumento2, argumento3){\n  # Inserte aqui el codigo que trabajara con los objetos definidos en los argumentos,\n  # junto con la salida que se propone para la nueva funcion\n}\n\nPor ejemplo:\n\nblabla &lt;- function(nombre = \"- inserte aqu√≠ su nombre -\"){\n  print(paste(\"Mi nombre es\", nombre, \"y me encanta el curso de Fundamentos b√°sicos del lenguaje R.\"))\n}\n\nAl correr el bloque de c√≥digo anterior, simplemente estamos creando la funci√≥n, y no corriendo el c√≥digo programado. Esta se carga como un objeto propio en el entorno, quedando disponible para su uso futuro.\nEn este ejemplo, el argumento nombre se encuentra asignado a una l√≠nea de texto. De esta manera, la funci√≥n entiende que el valor indicado es el valor por defecto, para los casos los que el usuario no define un valor particular para dicho argumento. La definici√≥n de valores por defecto no es obligatoria, pero puede ser √∫til en muchos casos. Si corremos dicha funci√≥n suelta, sin definir nada en espec√≠fico, podemos observar el resultado:\n\nblabla()\n\n[1] \"Mi nombre es - inserte aqu√≠ su nombre - y me encanta el curso de Fundamentos b√°sicos del lenguaje R.\"\n\n\nEn cambio, podemos asignarle un valor al argumento nombre:\n\nblabla(nombre = \"Lionel Scaloni\")\n\n[1] \"Mi nombre es Lionel Scaloni y me encanta el curso de Fundamentos b√°sicos del lenguaje R.\"\n\n\n\n\nUna cuesti√≥n a considerar en el contexto de creaci√≥n de funciones es el uso que las mismas hacen de los entornos. Podemos definir a un entorno como al espacio en donde se guardan nuestros objetos. Cuando creamos un objeto, sea una tabla, un vector, una funci√≥n o cualquier otro, estos se guardan en el entorno global, y de hecho aparecen visibles en el panel correspondiente de la interfaz de RStudio. Cuando creamos una funci√≥n, se crea un sub-entorno contenido dentro de la funci√≥n. ¬øPor qu√© es esto relevante? Porque los entornos son los lugares en donde se guardan los objetos de los que haremos uso para nuestras funciones, y una funci√≥n buscar√° primero en el entorno de la funci√≥n, luego en el entorno que se encuentra un nivel por encima de este.\nVe√°moslo con un ejemplo. La siguiente funci√≥n toma un n√∫mero y le suma 5:\n\nfff &lt;- function(x){\n  y &lt;- x + 5\n  y\n}\n\nPor ejemplo:\n\nfff(x = 3)\n\n[1] 8\n\n\nEsta funci√≥n guarda el resultado en un objeto llamado y. Sin embargo, podemos ver que este objeto no se guarda en el entorno global, lo cual se evidencia cuando intentamos leer dicho objeto:\n\ny\n\nError: objeto 'y' no encontrado\n\n\nLa raz√≥n es que y se cre√≥ en el entorno de la funci√≥n fff(), se guarda all√≠ dentro, se utiliza para la ejecuci√≥n de la funci√≥n, y finalmente se descarta.\nVeamos ahora la siguiente variante de la funci√≥n:\n\nfff &lt;- function(){\n  y &lt;- x + 5\n  y\n}\n\nLa diferencia es que esta funci√≥n no tiene argumentos. Veamos lo que sucede al correrla:\n\nfff()\n\nError in fff(): objeto 'x' no encontrado\n\n\nEl error se debe a que x no est√° definido. Pero miremos lo que pasa si definimos a x por fuera de la funci√≥n:\n\nx &lt;- 9\nfff()\n\n[1] 14\n\n\n¬øQue pas√≥? La funci√≥n busc√≥ al objeto x dentro del entorno de la funci√≥n, no lo encontr√≥, pero luego busc√≥ en el entorno un nivel por encima, que es el entorno global. Encontr√≥ un objeto con dicho nombre, y lo utiliz√≥ para su ejecuci√≥n.\nPara testear: ¬øQu√© suceder√≠a si x est√° definido por fuera de la funci√≥n pero tambi√©n dentro de la misma?",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#c√≥mo-creo-una-funci√≥n",
    "href": "dia5/7.1_Funciones.html#c√≥mo-creo-una-funci√≥n",
    "title": "Funciones",
    "section": "",
    "text": "Las funciones en R son las herramientas que nos permiten realizar una gran diversidad de an√°lisis. Para ello, R provee de una numerosa y potente biblioteca de ellas, las cuales vienen instalada por defecto. Adem√°s, como hemos desarrollado al principio del curso, existe una abanico mega-diverso de paquetes de R desarrollados por los propios usuarios, especialmente desarrollados para la realizaci√≥n de tareas espec√≠ficas.\nNo obstante, es usual que en un flujo de trabajo de intermedio a avanzado necesitemos desarrollar nuestras propias funciones. La raz√≥n para ello radica en la ejecuci√≥n de una tarea muy espec√≠fica como parte de nuestros an√°lisis, pero que al mismo tiempo debe realizarse m√∫ltiples veces para que amerite su desarrollo en forma de funci√≥n.\nLas funciones en R se asignan a objetos, cuyo nombre ser√° el nombre de la funci√≥n, con la expresi√≥n function(). Dentro de los par√©ntesis debemos indicar los argumentos de la funci√≥n. Estos ser√°n los objetos con los que la funci√≥n trabajar√° de alguna manera, y devolver√° alguna salida determinada. La sintaxis general es la siguiente:\n\nmi_funcion &lt;- function(argumento1, argumento2, argumento3){\n  # Inserte aqui el codigo que trabajara con los objetos definidos en los argumentos,\n  # junto con la salida que se propone para la nueva funcion\n}\n\nPor ejemplo:\n\nblabla &lt;- function(nombre = \"- inserte aqu√≠ su nombre -\"){\n  print(paste(\"Mi nombre es\", nombre, \"y me encanta el curso de Fundamentos b√°sicos del lenguaje R.\"))\n}\n\nAl correr el bloque de c√≥digo anterior, simplemente estamos creando la funci√≥n, y no corriendo el c√≥digo programado. Esta se carga como un objeto propio en el entorno, quedando disponible para su uso futuro.\nEn este ejemplo, el argumento nombre se encuentra asignado a una l√≠nea de texto. De esta manera, la funci√≥n entiende que el valor indicado es el valor por defecto, para los casos los que el usuario no define un valor particular para dicho argumento. La definici√≥n de valores por defecto no es obligatoria, pero puede ser √∫til en muchos casos. Si corremos dicha funci√≥n suelta, sin definir nada en espec√≠fico, podemos observar el resultado:\n\nblabla()\n\n[1] \"Mi nombre es - inserte aqu√≠ su nombre - y me encanta el curso de Fundamentos b√°sicos del lenguaje R.\"\n\n\nEn cambio, podemos asignarle un valor al argumento nombre:\n\nblabla(nombre = \"Lionel Scaloni\")\n\n[1] \"Mi nombre es Lionel Scaloni y me encanta el curso de Fundamentos b√°sicos del lenguaje R.\"\n\n\n\n\nUna cuesti√≥n a considerar en el contexto de creaci√≥n de funciones es el uso que las mismas hacen de los entornos. Podemos definir a un entorno como al espacio en donde se guardan nuestros objetos. Cuando creamos un objeto, sea una tabla, un vector, una funci√≥n o cualquier otro, estos se guardan en el entorno global, y de hecho aparecen visibles en el panel correspondiente de la interfaz de RStudio. Cuando creamos una funci√≥n, se crea un sub-entorno contenido dentro de la funci√≥n. ¬øPor qu√© es esto relevante? Porque los entornos son los lugares en donde se guardan los objetos de los que haremos uso para nuestras funciones, y una funci√≥n buscar√° primero en el entorno de la funci√≥n, luego en el entorno que se encuentra un nivel por encima de este.\nVe√°moslo con un ejemplo. La siguiente funci√≥n toma un n√∫mero y le suma 5:\n\nfff &lt;- function(x){\n  y &lt;- x + 5\n  y\n}\n\nPor ejemplo:\n\nfff(x = 3)\n\n[1] 8\n\n\nEsta funci√≥n guarda el resultado en un objeto llamado y. Sin embargo, podemos ver que este objeto no se guarda en el entorno global, lo cual se evidencia cuando intentamos leer dicho objeto:\n\ny\n\nError: objeto 'y' no encontrado\n\n\nLa raz√≥n es que y se cre√≥ en el entorno de la funci√≥n fff(), se guarda all√≠ dentro, se utiliza para la ejecuci√≥n de la funci√≥n, y finalmente se descarta.\nVeamos ahora la siguiente variante de la funci√≥n:\n\nfff &lt;- function(){\n  y &lt;- x + 5\n  y\n}\n\nLa diferencia es que esta funci√≥n no tiene argumentos. Veamos lo que sucede al correrla:\n\nfff()\n\nError in fff(): objeto 'x' no encontrado\n\n\nEl error se debe a que x no est√° definido. Pero miremos lo que pasa si definimos a x por fuera de la funci√≥n:\n\nx &lt;- 9\nfff()\n\n[1] 14\n\n\n¬øQue pas√≥? La funci√≥n busc√≥ al objeto x dentro del entorno de la funci√≥n, no lo encontr√≥, pero luego busc√≥ en el entorno un nivel por encima, que es el entorno global. Encontr√≥ un objeto con dicho nombre, y lo utiliz√≥ para su ejecuci√≥n.\nPara testear: ¬øQu√© suceder√≠a si x est√° definido por fuera de la funci√≥n pero tambi√©n dentro de la misma?",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#uso-de-return",
    "href": "dia5/7.1_Funciones.html#uso-de-return",
    "title": "Funciones",
    "section": "Uso de return()",
    "text": "Uso de return()\nDesarrollemos una funci√≥n un poco m√°s compleja. Por ejemplo, imaginemos una funci√≥n que calcula el valor promedio de un conjunto de n√∫meros (tarea que, ya sabemos, ejecuta mean()). Una forma de hacerlo es la siguiente:\n\nvalor_promedio &lt;- function(x){\n  # Sumo todos los valores del vector x con un ciclo for\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i]\n  }\n  \n  # Divido la suma por la cantidad de elementos\n  promedio &lt;- sum/length(x)\n  \n  return(promedio)\n}\n\nNotar que el contenido de la funci√≥n es casi id√©ntico a como programar√≠amos por fuera del contexto de una funci√≥n. La √∫nica diferencia es que la funci√≥n permite realizar la tarea propuesta para cualquier caso, y no para solo uno en particular. Aqu√≠, podemos definir cualquier vector num√©rico que quisi√©ramos, y calcular el promedio a partir del vector indicado.\nOtra diferencia que vemos aqu√≠ respecto de la funci√≥n del ejemplo anterior (blabla()) es el uso de la funci√≥n return(). Esta expresi√≥n indica el valor a devolver por la funci√≥n, y su llamado termina la ejecuci√≥n de la funci√≥n en esa l√≠nea. Es decir, toda l√≠nea de c√≥digo por debajo de un return() no se ejecutar√°. ¬øDe qu√© servir√≠a esto? Por ejemplo, la funci√≥n podr√≠a ejecutar un bloque de c√≥digo si se cumple una condici√≥n, y otro bloque si no se cumple, justificando la presencia de m√°s de un return().\nLa siguiente l√≠nea calcula el valor promedio para el vector 1:30:\n\nvalor_promedio(1:30)\n\n[1] 15.5\n\n\nNotar que no es necesario aclarar expl√≠citamente el nombre del argumento x, basta con que sea el primero.\nUna versi√≥n un poquito m√°s compleja que la anterior posee un segundo argumento que le otorga un peso a cada elemento de la muestra. Por lo tanto, estaremos calculando un promedio ponderado. Se espera un vector num√©rico de longitud igual a x, indicando el peso otorgado a cada elemento. Por defecto, definimos un vector num√©rico de unos, otorgando as√≠ el mismo peso a cada elemento:\n\nvalor_promedio &lt;- function(x, pesos = rep(1, length(x))){\n  # Sumo todos los valores del vector x\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i] * pesos[i]\n  }\n  \n  promedio &lt;- sum/length(x)\n  return(promedio)\n}\n\nPor ejemplo, para el mismo conjunto de n√∫meros anterior:\n\npesos_aleatorios &lt;- sample(c(0.5, 0.75, 1), length(1:30), replace = TRUE)\nvalor_promedio(x = 1:30, pesos = pesos_aleatorios)\n\n[1] 11.10833",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#uso-de-stop-y-warning",
    "href": "dia5/7.1_Funciones.html#uso-de-stop-y-warning",
    "title": "Funciones",
    "section": "Uso de stop() y warning()",
    "text": "Uso de stop() y warning()\nAdem√°s de return(), las funciones stop() y warning() ser√°n de utilidad cuando creemos nuestras propias funciones. Por ejemplo, imaginemos que el usuario indica para el argumento x un vector de tipo character(). Obviamente, el promedio no puede calcularse, y obtenemos un error. Este error, sin embargo, no es muy informativo:\n\nvalor_promedio(x = LETTERS[1:10])\n\nError in x[i] * pesos[i]: argumento no-num√©rico para operador binario\n\n\nPodemos agregar una condici√≥n que eval√∫e si el vector es num√©rico, caso contrario utilizamos stop().\n\nvalor_promedio &lt;- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser num√©rico.\")\n  }\n  \n  # Sumo todos los valores del vector x\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i] * pesos[i]\n  }\n  \n  promedio &lt;- sum/length(x)\n  return(promedio)\n}\n\nCon el uso de stop() la ejecuci√≥n de la funci√≥n se termina, y se imprime un mensaje informativo en la consola:\n\nvalor_promedio(x = LETTERS[1:10])\n\nError in valor_promedio(x = LETTERS[1:10]): El vector indicado en 'x' debe ser num√©rico.\n\n\nLa funci√≥n warning() imprime una advertencia, pero contin√∫a con la ejecuci√≥n. Por ejemplo, imaginemos que el usuario indica un vector de pesos de diferente longitud a la longitud del vector indicado en x. Una opci√≥n para contemplar este escenario ser√≠a la siguiente:\n\nvalor_promedio &lt;- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser num√©rico.\")\n  }\n  \n  # Evalua si la longitud del vector en 'pesos' es igual a la de 'x'\n  if(length(x) != length(pesos)){\n    warning(\"El argumento 'pesos' debe ser un vector num√©rico de la misma longitud que el vector en 'x'. Se tom√≥ el valor por defecto.\")\n    pesos &lt;- rep(1, length(x))\n  }\n  \n  # Sumo todos los valores del vector x\n  sum &lt;- 0\n  for (i in 1:length(x)){\n    sum &lt;- sum + x[i] * pesos[i]\n  }\n  \n  promedio &lt;- sum/length(x)\n  return(promedio)\n}\n\nNotar que se eval√∫a la condici√≥n planteada para el argumento pesos. Si no se cumple que la longitud del vector indicado es igual a la longitud del vector en x, la funci√≥n imprime una advertencia. Adem√°s, para que la funci√≥n siga ejecut√°ndose correctamente, definimos pesos &lt;- rep(1, length(x)), es decir, el valor por defecto. Este √∫ltimo paso es fundamental, de lo contrario la salida de la funci√≥n ser√≠a impredecible.\n\nvalor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75))\n\nWarning in valor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75)): El argumento\n'pesos' debe ser un vector num√©rico de la misma longitud que el vector en 'x'.\nSe tom√≥ el valor por defecto.\n\n\n[1] 15.5\n\n\nVemos que el promedio es calculado correctamente (con pesos = rep(1, length(x))), pero adem√°s se imprime una advertencia.\nEl uso de las funciones stop() y warning() en el contexto de funciones no es fundamental, pero adquieren relevancia para funciones que usar√°n otras personas. Uno nunca sabe con absoluta seguridad el tipo de entrada que un usuario externo usar√≠a en una de nuestras funciones, y uno debe prevenir distintos escenarios. Sin embargo, si a las funciones las usaremos s√≥lo nosotros, contemplar estos escenarios no ser√° vital, por lo que no ser√≠a absolutamente necesario el uso de stop() o warning().",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#funciones-del-tipo-apply",
    "href": "dia5/7.1_Funciones.html#funciones-del-tipo-apply",
    "title": "Funciones",
    "section": "Funciones del tipo apply",
    "text": "Funciones del tipo apply\nLas funciones de la familia apply se utilizan para aplicar una funci√≥n determinada a una lista o a un vector. Es √∫til para realizar un mismo c√°lculo a un conjunto de elementos dado, evitando utilizar, por ejemplo, un ciclo for.\nPor ejemplo, imaginemos una lista de 3 elementos, cada elemento un vector num√©rico:\n\nlista_numeros &lt;- list(sample(1:1000, size = 50),\n                      sample(1:1000, size = 50),\n                      sample(1:1000, size = 50))\nlista_numeros\n\n[[1]]\n [1] 708  62 723 393 285 212 944 489  38 576 106 265 200 898 878 104 338 485 941\n[20] 658 416  61 768 366 131 765 871 473 113  25  59 803 641 888 135 442 512 315\n[39]  89 372 932 102 284 546 340 897 627 682 578 604\n\n[[2]]\n [1] 938 383 884 139 549 702 870 305 151 236 221 993 266 239   6 605 319 829 573\n[20] 786 517 634 165 519 342 323 853 102 684 643 138 348 466 584 930 353 941 371\n[39] 253 677  14 729 290 110 751 116 631 133 231  89\n\n[[3]]\n [1] 933 873 869 555 579  37 817 587 691 318 118 838 241 169 760 900 899 495 664\n[20] 876 513  51 147 151 995 577 865 970 290 506 330  30 912  81 801 897 570 416\n[39] 413 305 389 757 563 635 945 123 308 923 154 629\n\n\nLa funci√≥n sapply() aplica una funci√≥n dada a un objeto de tipo list(), y devuelve un vector. En este ejemplo, utilizaremos la funci√≥n recientemente creada (valor_promedio()), para calcular el promedio de cada conjunto de n√∫meros de la lista (indicados en el primer argumento):\n\npromedios &lt;- sapply(lista_numeros, FUN = valor_promedio)\npromedios\n\n[1] 462.80 458.62 549.30\n\n\nNotar que para el argumento FUN indicamos el nombre de la funci√≥n sin los par√©ntesis, la cual debe existir en el entorno (cargada por el usuario o por defecto en R).\nSi quisi√©ramos indicar otros argumentos para la funci√≥n valor_promedio(), estos pueden definirse luego del argumento FUN:\n\npesos_aleatorios &lt;- sample(c(0.5, 0.75, 1), size = 50, replace = TRUE)\npromedios &lt;- sapply(lista_numeros, FUN = valor_promedio, pesos = pesos_aleatorios)\npromedios\n\n[1] 350.735 357.310 443.125\n\n\nPara pensar: tal cual como est√° programada, la funci√≥n valor_promedio() no es √∫til para ser utilizada con la funci√≥n sapply(), especialmente en cuanto al argumento pesos. ¬øPor qu√©?\nExisten otras variantes a la funci√≥n sapply(), como por ejemplo lapply(), que funciona de manera id√©ntica pero devuelve una lista en vez de un vector.",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia5/7.1_Funciones.html#ejercicios",
    "href": "dia5/7.1_Funciones.html#ejercicios",
    "title": "Funciones",
    "section": "Ejercicios",
    "text": "Ejercicios\n\nCree una funci√≥n que calcule el √°rea de un tri√°ngulo a partir de su base y altura. Contemple el escenario en el que el usuario indique valores no num√©ricos para los argumentos.\nCree una funci√≥n que calcule el error est√°ndar de un conjunto de n√∫meros. El error est√°ndar se calcula realizando el cociente entre el desv√≠o est√°ndar de la muestra y la ra√≠z cuadrada de la cantidad de n√∫meros evaluados.\nA partir de la funci√≥n que calcula el error est√°ndar, utilice la funci√≥n sapply() para calcular el error est√°ndar del conjunto de n√∫meros seq(1, 50, 20), c(501, 920, 759, 233) y -14:28.",
    "crumbs": [
      "Inicio",
      "Unidad 5",
      "Funciones"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html",
    "href": "dia4/6.2_ggplot2.html",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "",
    "text": "El paquete ggplot2 ofrece una nutrida biblioteca de funciones para la creaci√≥n de gr√°ficos de diversos tipos en R. La diversidad de gr√°ficos y formas de personalizaci√≥n es enorme -es un curso en s√≠ mismo- y aqu√≠ simplemente desarrollaremos los fundamentos b√°sicos para su comprensi√≥n. Existen varias p√°ginas web √∫tiles para aprender sobre el desarrollo de gr√°ficos con ggplot2, incluyendo a The R Graph Gallery y R Charts. En esta p√°gina se muestra una tabla de colores junto con su nombre a utilizar dentro del entorno R.\nA diferencia de otros paquetes de graficaci√≥n, incluyendo a las funciones nativas de R que ya hemos visto, la creaci√≥n de gr√°ficos con ggplot2 sigue una l√≥gica diferente. Se trabaja mediante la apilaci√≥n de ‚Äúcapas gr√°ficas‚Äù a trav√©s de un lenguaje propio del paquete. Si traduj√©ramos el c√≥digo en palabras, ser√≠a algo as√≠:\ncreo espacio de graficaci√≥n ‚Üí ¬†¬†a√±ado capa gr√°fica n¬∫1 (e.g.¬†puntos) ‚Üí ¬†¬†a√±ado capa gr√°fica n¬∫2 (e.g.¬†l√≠neas) ‚Üí ¬†¬†configuro eje x ‚Üí ¬†¬†configuro eje y ‚Üí ¬†¬†configuro par√°metros generales del gr√°fico\nMejor que explicarlo, es mostrarlo!\nAntes que nada, es necesario cargar el paquete al entorno de R:\n\nlibrary(ggplot2)\n\n\n\nPara crear un nuevo gr√°fico, por ejemplo un simple gr√°fico de puntos, lo hacemos con el siguiente bloque de c√≥digo:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\nLa primera l√≠nea llama a la funci√≥n ggplot(). Esta funci√≥n ser√° el inicio de todos nuestros gr√°ficos con ggplot2. All√≠, indicamos el conjunto de datos que se utilizar√° para obtener los datos de graficaci√≥n, t√≠picamente un data.frame, en el argumento llamado data. El argumento mapping debe definirse a trav√©s de la funci√≥n aes(), dentro de la cual definimos las variables a graficar y su asociaci√≥n a las columnas del data.frame indicado. Aqu√≠ indicamos que la variable x ser√° ‚ÄúSepal.Length‚Äù y la variable y ‚ÄúPetal.Length‚Äù. Ambas son columnas del dataset iris indicado en el argumento data.\nSeguidamente a la primera l√≠nea observamos un +, y esta es la gran diferencia de la l√≥gica de ggplot2 respecto de otros paquetes. El operador + indica que seguido a √©l se a√±adir√° una nueva capa al gr√°fico. Aqu√≠, en la segunda l√≠nea (y est√° en la segunda l√≠nea por simple prolijidad, pero podr√≠a ir seguido en la primera l√≠nea), la funci√≥n geom_point() indica que se a√±adir√° un gr√°fico de nube de puntos (o scatterplot). En general, todas las funciones que comienzan congeom_ refieren a tipos de gr√°ficos particulares, entre ellas:\n\ngeom_point(): puntos.\ngeom_line(): l√≠neas.\ngeom_bar() y geom_col(): barras.\ngeom_boxplot(): cajas (boxplots),\n\nPara probar: Escriba en la consola geom_, y espera a observar las sugerencias de funciones disponibles para la generaci√≥n de distintos tipos de gr√°ficos en ggplot2.\n\n\n\n\n\n\nEl grado de personalizaci√≥n de los gr√°ficos con ggplot2 es inmenso. Por ejemplo, podemos cambiar el color, tama√±o, forma y transparencia:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7)\n\n\n\n\n\n\n\n\nSi comparamos los argumentos utilizados en ggplot2 con los de los gr√°ficos base de R, size es equivalente a cex, col vale para ambos enfoques, fill es equivalente a bg y shape es equivalente a pch.\nEl operador + permite agregar nuevas capas de informaci√≥n y personalizaci√≥n:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7) +\n  geom_hline(yintercept = mean(iris$Petal.Length), lty = \"dashed\") +\n  ggtitle(\"Scatterplot de ejemplo\")\n\n\n\n\n\n\n\n\nLa funci√≥n geom_hline() agrega una l√≠nea horizontal: el argumento yintercept indica el valor para y por donde pasar√° la l√≠nea, aqu√≠ indicado por el valor promedio de la variable y; el argumento lty permite elegir un estilo para la l√≠nea. La funci√≥n ggtitle() a√±ade un t√≠tulo.\n\n\n\nLas funciones del tipo scale_ son muy importantes, ya que permiten personalizar aspectos relacionados a las variables indicadas dentro de la funci√≥n aes(). Aqu√≠, con scale_x_continuous() indicamos un nombre para el eje x en el argumento name, los l√≠mites num√©ricos del eje con el argumento limits (vector de dos elementos, con valor m√≠nimo y m√°ximo) y los cortes del eje con el argumento breaks (vector num√©rico indicando d√≥nde se ubicaran los cortes).\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\", limits = c(5, 7), breaks = seq(5, 7, 0.5)) +\n  scale_y_continuous(name = \"Longitud del p√©talo\")\n\nWarning: Removed 34 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nNotar la advertencia generada. ¬øQu√© significa?\nAhora bien, el gr√°fico que venimos haciendo incluye a las variables florales de las tres especies de Iris provistas dentro del conjunto de datos. ¬øC√≥mo hacemos para diferenciarlas en el gr√°fico? Debemos indicar una nueva variable dentro de aes(), asociada a un par√°metro gr√°fico apropiado. En este contexto, lo mejor ser√≠a que los puntos tengan diferentes colores por especie:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\")\n\n\n\n\n\n\n\n\nNotar el agregado de la variable color asignada a la columna ‚ÄúSpecies‚Äù de nuestra tabla, as√≠ tambi√©n como la no definici√≥n de un color fijo dentro de la funci√≥n geom_point() (porque la idea es que haya un color distinto para cada especie). Aqu√≠, bien podr√≠amos haber definido otro par√°metro gr√°fico a modificar seg√∫n las distintas especies, tales como la forma (shape) o el tama√±o (size). Volviendo a nuestro c√≥digo anterior, ¬øc√≥mo definimos colores espec√≠ficos para cada nivel? La funci√≥n scale_color_manual() es la indicada:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n\n\n\n\n\n\n\nLos colores se encuentran definidos en el argumento values. Los argumentos name y labels permiten modificar el nombre asignado para la leyenda, y las etiquetas para cada especie.\nPor otro lado, la funci√≥n geom_smooth() a√±ade l√≠neas o curvas de tendencia para los datos. Aqu√≠, el argumento method = \"lm\" indica que la l√≠nea a aproximar en la nube de puntos se calcular√° mediante una regresi√≥n lineal (‚Äúlinear model‚Äù):\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\nVeamos ahora un gr√°fico de cajas, con la funci√≥n geom_boxplot():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nDentro de aes() definimos para x la variable discreta ‚ÄúSpecies‚Äù y para y la variable continua ‚ÄúPetal.Length‚Äù. La incorporaci√≥n del argumento fill indica colores distintos para cada especie.\nPara jugar: Cambie fill por col y observe los resultados.\nPara configurar aspectos del eje x de un boxplot, scale_x_continuos() no servir√°, porque la variable definida para x no es continua (son especies). La funci√≥n adecuada es scale_x_discrete():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nPara observar: Vea tambi√©n los otros cambios incorporados al gr√°fico y asocie esos cambios con cada l√≠nea de c√≥digo.\nLa funci√≥n geom_jitter() permite agregar una nube de puntos, las observaciones, pero dispuestas de manera aleatoria a lo largo de uno o ambos ejes:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3, outliers = FALSE) +\n  geom_jitter(shape = 21, height = 0, width = 0.3, alpha = 0.4) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nAl indicar height = 0, los puntos mantendr√°n la ubicaci√≥n original para la variable y. En cambio, width = 0.3 reubica aleatoriamente cada punto a lo largo del eje x. El valor 0.3 simplemente indica el nivel de ruido, en este caso horizontal, que tendr√° cada punto.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#otra-l√≥gica-de-programaci√≥n",
    "href": "dia4/6.2_ggplot2.html#otra-l√≥gica-de-programaci√≥n",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "",
    "text": "El paquete ggplot2 ofrece una nutrida biblioteca de funciones para la creaci√≥n de gr√°ficos de diversos tipos en R. La diversidad de gr√°ficos y formas de personalizaci√≥n es enorme -es un curso en s√≠ mismo- y aqu√≠ simplemente desarrollaremos los fundamentos b√°sicos para su comprensi√≥n. Existen varias p√°ginas web √∫tiles para aprender sobre el desarrollo de gr√°ficos con ggplot2, incluyendo a The R Graph Gallery y R Charts. En esta p√°gina se muestra una tabla de colores junto con su nombre a utilizar dentro del entorno R.\nA diferencia de otros paquetes de graficaci√≥n, incluyendo a las funciones nativas de R que ya hemos visto, la creaci√≥n de gr√°ficos con ggplot2 sigue una l√≥gica diferente. Se trabaja mediante la apilaci√≥n de ‚Äúcapas gr√°ficas‚Äù a trav√©s de un lenguaje propio del paquete. Si traduj√©ramos el c√≥digo en palabras, ser√≠a algo as√≠:\ncreo espacio de graficaci√≥n ‚Üí ¬†¬†a√±ado capa gr√°fica n¬∫1 (e.g.¬†puntos) ‚Üí ¬†¬†a√±ado capa gr√°fica n¬∫2 (e.g.¬†l√≠neas) ‚Üí ¬†¬†configuro eje x ‚Üí ¬†¬†configuro eje y ‚Üí ¬†¬†configuro par√°metros generales del gr√°fico\nMejor que explicarlo, es mostrarlo!\nAntes que nada, es necesario cargar el paquete al entorno de R:\n\nlibrary(ggplot2)\n\n\n\nPara crear un nuevo gr√°fico, por ejemplo un simple gr√°fico de puntos, lo hacemos con el siguiente bloque de c√≥digo:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\nLa primera l√≠nea llama a la funci√≥n ggplot(). Esta funci√≥n ser√° el inicio de todos nuestros gr√°ficos con ggplot2. All√≠, indicamos el conjunto de datos que se utilizar√° para obtener los datos de graficaci√≥n, t√≠picamente un data.frame, en el argumento llamado data. El argumento mapping debe definirse a trav√©s de la funci√≥n aes(), dentro de la cual definimos las variables a graficar y su asociaci√≥n a las columnas del data.frame indicado. Aqu√≠ indicamos que la variable x ser√° ‚ÄúSepal.Length‚Äù y la variable y ‚ÄúPetal.Length‚Äù. Ambas son columnas del dataset iris indicado en el argumento data.\nSeguidamente a la primera l√≠nea observamos un +, y esta es la gran diferencia de la l√≥gica de ggplot2 respecto de otros paquetes. El operador + indica que seguido a √©l se a√±adir√° una nueva capa al gr√°fico. Aqu√≠, en la segunda l√≠nea (y est√° en la segunda l√≠nea por simple prolijidad, pero podr√≠a ir seguido en la primera l√≠nea), la funci√≥n geom_point() indica que se a√±adir√° un gr√°fico de nube de puntos (o scatterplot). En general, todas las funciones que comienzan congeom_ refieren a tipos de gr√°ficos particulares, entre ellas:\n\ngeom_point(): puntos.\ngeom_line(): l√≠neas.\ngeom_bar() y geom_col(): barras.\ngeom_boxplot(): cajas (boxplots),\n\nPara probar: Escriba en la consola geom_, y espera a observar las sugerencias de funciones disponibles para la generaci√≥n de distintos tipos de gr√°ficos en ggplot2.\n\n\n\n\n\n\nEl grado de personalizaci√≥n de los gr√°ficos con ggplot2 es inmenso. Por ejemplo, podemos cambiar el color, tama√±o, forma y transparencia:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7)\n\n\n\n\n\n\n\n\nSi comparamos los argumentos utilizados en ggplot2 con los de los gr√°ficos base de R, size es equivalente a cex, col vale para ambos enfoques, fill es equivalente a bg y shape es equivalente a pch.\nEl operador + permite agregar nuevas capas de informaci√≥n y personalizaci√≥n:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7) +\n  geom_hline(yintercept = mean(iris$Petal.Length), lty = \"dashed\") +\n  ggtitle(\"Scatterplot de ejemplo\")\n\n\n\n\n\n\n\n\nLa funci√≥n geom_hline() agrega una l√≠nea horizontal: el argumento yintercept indica el valor para y por donde pasar√° la l√≠nea, aqu√≠ indicado por el valor promedio de la variable y; el argumento lty permite elegir un estilo para la l√≠nea. La funci√≥n ggtitle() a√±ade un t√≠tulo.\n\n\n\nLas funciones del tipo scale_ son muy importantes, ya que permiten personalizar aspectos relacionados a las variables indicadas dentro de la funci√≥n aes(). Aqu√≠, con scale_x_continuous() indicamos un nombre para el eje x en el argumento name, los l√≠mites num√©ricos del eje con el argumento limits (vector de dos elementos, con valor m√≠nimo y m√°ximo) y los cortes del eje con el argumento breaks (vector num√©rico indicando d√≥nde se ubicaran los cortes).\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\", limits = c(5, 7), breaks = seq(5, 7, 0.5)) +\n  scale_y_continuous(name = \"Longitud del p√©talo\")\n\nWarning: Removed 34 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nNotar la advertencia generada. ¬øQu√© significa?\nAhora bien, el gr√°fico que venimos haciendo incluye a las variables florales de las tres especies de Iris provistas dentro del conjunto de datos. ¬øC√≥mo hacemos para diferenciarlas en el gr√°fico? Debemos indicar una nueva variable dentro de aes(), asociada a un par√°metro gr√°fico apropiado. En este contexto, lo mejor ser√≠a que los puntos tengan diferentes colores por especie:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\")\n\n\n\n\n\n\n\n\nNotar el agregado de la variable color asignada a la columna ‚ÄúSpecies‚Äù de nuestra tabla, as√≠ tambi√©n como la no definici√≥n de un color fijo dentro de la funci√≥n geom_point() (porque la idea es que haya un color distinto para cada especie). Aqu√≠, bien podr√≠amos haber definido otro par√°metro gr√°fico a modificar seg√∫n las distintas especies, tales como la forma (shape) o el tama√±o (size). Volviendo a nuestro c√≥digo anterior, ¬øc√≥mo definimos colores espec√≠ficos para cada nivel? La funci√≥n scale_color_manual() es la indicada:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n\n\n\n\n\n\n\nLos colores se encuentran definidos en el argumento values. Los argumentos name y labels permiten modificar el nombre asignado para la leyenda, y las etiquetas para cada especie.\nPor otro lado, la funci√≥n geom_smooth() a√±ade l√≠neas o curvas de tendencia para los datos. Aqu√≠, el argumento method = \"lm\" indica que la l√≠nea a aproximar en la nube de puntos se calcular√° mediante una regresi√≥n lineal (‚Äúlinear model‚Äù):\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\nVeamos ahora un gr√°fico de cajas, con la funci√≥n geom_boxplot():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\nDentro de aes() definimos para x la variable discreta ‚ÄúSpecies‚Äù y para y la variable continua ‚ÄúPetal.Length‚Äù. La incorporaci√≥n del argumento fill indica colores distintos para cada especie.\nPara jugar: Cambie fill por col y observe los resultados.\nPara configurar aspectos del eje x de un boxplot, scale_x_continuos() no servir√°, porque la variable definida para x no es continua (son especies). La funci√≥n adecuada es scale_x_discrete():\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nPara observar: Vea tambi√©n los otros cambios incorporados al gr√°fico y asocie esos cambios con cada l√≠nea de c√≥digo.\nLa funci√≥n geom_jitter() permite agregar una nube de puntos, las observaciones, pero dispuestas de manera aleatoria a lo largo de uno o ambos ejes:\n\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3, outliers = FALSE) +\n  geom_jitter(shape = 21, height = 0, width = 0.3, alpha = 0.4) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n\n\n\n\n\n\n\n\nAl indicar height = 0, los puntos mantendr√°n la ubicaci√≥n original para la variable y. En cambio, width = 0.3 reubica aleatoriamente cada punto a lo largo del eje x. El valor 0.3 simplemente indica el nivel de ruido, en este caso horizontal, que tendr√° cada punto.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#ejercicio-1",
    "href": "dia4/6.2_ggplot2.html#ejercicio-1",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nGenere un gr√°fico id√©ntico al √∫ltimo expuesto, pero con un orden distinto para los niveles del eje x. El orden debe ser, de izquierda a derecha, I. virginica, I. versicolor e I. setosa. Para ello, debe redefinir la variable ‚ÄúSpecies‚Äù de la tabla como un factor con niveles en el orden indicado. Si no se acuerda como hacerlo, vuelva a la clase de Vectores.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#funciones-de-tipo-theme",
    "href": "dia4/6.2_ggplot2.html#funciones-de-tipo-theme",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "Funciones de tipo theme",
    "text": "Funciones de tipo theme\nLas funciones que inician con theme permiten la personalizaci√≥n general del gr√°fico. Por un lado, contamos con funciones como theme_light(), las cuales vienen asociadas con configuraciones gr√°ficas preestablecidas. Por otro lado, la funci√≥n theme() permite un grado de personalizaci√≥n del gr√°fico muy alta. Por ejemplo:\n\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  scale_color_manual(name = NULL, \n                     labels = c(expression(italic(\"I. setosa\")), \n                                expression(italic(\"I. versicolor\")), \n                                expression(italic(\"I. virginica\"))), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  annotate(\"text\", x = 4, y = 6.5, label = \"p &lt; 0.05\", hjust = 0) +\n  theme_light() +\n  theme(aspect.ratio = 9/16, legend.position = \"bottom\")\n\n\n\n\n\n\n\n\nUn primer aspecto a considerar es el orden de las nuevas capas a√±adidas. Notar que primero se agreg√≥ theme_light(), luego theme(). Esto es importante porque, de haberlo hecho al rev√©s, las personalizaciones hechas en theme() hubieran sido reemplazadas por la configuraci√≥n preestablecida de theme_light().\nDentro de theme(), es posible indicar una gran cantidad de argumentos (ver ?theme). Entre ellos, el argumento aspect.ratio es muy √∫til, ya que permite establecer la relaci√≥n de aspecto de la figura. Asimismo, con legend.position = \"bottom\" se indica que la leyenda se ubique en la parte baja de la figura.\nVale la pena mencionar la nueva capa a√±adida mediante annotate(), la cual sirve para a√±adir informaci√≥n al gr√°fico de manera directa (sin necesidad de referencias a un dataset). En el ejemplo, se utiliz√≥ para agregar texto, pero tambi√©n sirve para agregar l√≠neas o segmentos, entre otros.\nPara observar: Adem√°s de lo ya explicado, ¬øqu√© otras cosas cambiaron en el √∫ltimo gr√°fico respecto del anterior? ¬øQu√© l√≠neas de c√≥digo son las responsables de ello?\nPara jugar: Cambie theme_light() por otras funciones del tipo con otras configuraciones preestablecida y observe los distintos resultados.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#ejemplo-de-caso-t√≠pico-gr√°ficos-de-barras-con-error",
    "href": "dia4/6.2_ggplot2.html#ejemplo-de-caso-t√≠pico-gr√°ficos-de-barras-con-error",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "Ejemplo de caso t√≠pico: gr√°ficos de barras con error",
    "text": "Ejemplo de caso t√≠pico: gr√°ficos de barras con error\nUn gr√°fico muy popular es el gr√°fico de barras con error asociado. Usualmente, la barra indica un valor promedio y la barra de error el error est√°ndar o la desviaci√≥n est√°ndar. ¬øC√≥mo har√≠amos este gr√°fico en ggplot2? Primero, es necesario generar un data.frame con los valores promedio y de error asociados (en este ejemplo, la desviaci√≥n est√°ndar). Lo haremos para cada especie del g√©nero Iris:\n\niris_agg1 &lt;- aggregate(Petal.Width ~ Species, data = iris, mean)\ncolnames(iris_agg1)[2] &lt;- \"Petal.Width.mean\"\niris_agg2 &lt;- aggregate(Petal.Width ~ Species, data = iris, sd)\ncolnames(iris_agg2)[2] &lt;- \"Petal.Width.sd\"\niris_agg_3 &lt;- merge(iris_agg1, iris_agg2, by = \"Species\")\niris_agg_3\n\n     Species Petal.Width.mean Petal.Width.sd\n1     setosa            0.246      0.1053856\n2 versicolor            1.326      0.1977527\n3  virginica            2.026      0.2746501\n\n\nLuego, la funci√≥n adecuada para generar la barra es geom_col(), mientras que para la barra de error utilizamos geom_errorbar:\n\nggplot(data = iris_agg_3, aes(x = Species)) +\n  geom_col(aes(y = Petal.Width.mean)) +\n  geom_errorbar(aes(ymin = Petal.Width.mean - Petal.Width.sd, \n                    ymax = Petal.Width.mean + Petal.Width.sd), \n                width = 0.3)\n\n\n\n\n\n\n\n\nEste ejemplo tambi√©n sirve para mostrar c√≥mo podemos distribuir variables indicadas en aes(), no s√≥lamente en el inicio del gr√°fico con la funci√≥n ggplot(), sino tambi√©n en particular sobre las nuevas capas gr√°ficas a√±adidas. En este ejemplo, la variable x es la misma para todas las capas (la barra y la barra de error), por lo que se la indica en la funci√≥n principal, y dicha variable vale para todos las capas subsiguientes del gr√°fico. Luego, para geom_col(), indicamos la variable y asociada al promedio calculado. Finalmente, definimos m√°ximos y m√≠nimos de la barra de error dentro de aes() de geom_errorbar(), con los argumentos espec√≠ficos ymin y ymax.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#asignaci√≥n-de-gr√°ficos-a-objetos",
    "href": "dia4/6.2_ggplot2.html#asignaci√≥n-de-gr√°ficos-a-objetos",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "Asignaci√≥n de gr√°ficos a objetos",
    "text": "Asignaci√≥n de gr√°ficos a objetos\nLos gr√°ficos de ggplot2 pueden asignarse a objetos. La ventaja de ello es que el nuevo objeto creado queda guardado en el entorno, y el gr√°fico puede personalizarse en el futuro haciendo referencia al objeto creado.\n\nplot1 &lt;- ggplot(iris, aes(x = Petal.Width))\n\nAqu√≠, al objeto plot1 le es asignado a un gr√°fico que a√∫n no posee capas gr√°ficas, pero s√≠ posee una tabla asociada y una variable x asociada a una columna de esa tabla. Podemos hacer uso del nuevo objeto y el operador + para a√±adir nuevas capas y personalizaciones al gr√°fico:\n\nplot1 &lt;- plot1 + \n  geom_histogram() +\n  theme_bw()\n\nEl gr√°fico puede ser mostrado en el panel simplemente llamando al objeto:\n\nplot1\n\n\n\n\n\n\n\n\nEn ggplot2, los histogramas son generados mediante la funci√≥n geom_histogram().\nUna de las ventajas de asignar gr√°ficos a objetos es que, una vez creado el objeto, es posible trabajar en otras tareas asociadas para obtener alguna informaci√≥n relevante, que ser√° luego utilizada para continuar personalizando el gr√°fico.\nUna situaci√≥n com√∫n del flujo de trabajo de nuestras investigaciones consiste en generar un panel de gr√°ficos de manera autom√°tica, sin recurrir a software externos a R. Por ejemplo, adem√°s del objeto plot1, creemos otros tres gr√°ficos similares pero con otras variables:\n\nplot2 &lt;- ggplot(iris, aes(x = Petal.Length)) +\n  geom_histogram() +\n  theme_bw()\n\nplot3 &lt;- ggplot(iris, aes(x = Sepal.Width)) +\n  geom_histogram() +\n  theme_bw()\n\nplot4 &lt;- ggplot(iris, aes(x = Sepal.Length)) +\n  geom_histogram() +\n  theme_bw()\n\nPara crear un panel con ggplot2, la funci√≥n par() utilizada para gr√°ficos nativos de R no nos servir√°. Existen otras funciones asociadas que permiten hacerlo, entre ellas, la funci√≥n ggarrange() del paquete egg:\n\nlibrary(egg)\nggarrange(plot1, plot2, plot3, plot4, ncol = 2, nrow = 2)\n\n\n\n\n\n\n\n\nSimplemente se indican los objetos asociados a los gr√°ficos, junto con la cantidad de columnas y filas, como si fuera una matriz con espacios vac√≠os a ser rellenados por cada gr√°fico (aqu√≠, una matriz de 2x2).\nLa funci√≥n ggarrange() del paquete egg es una de muchas formas de generar paneles con gr√°ficos de ggplot2. Tambi√©n podemos mencionar a la funci√≥n plot_grid() del paquete cowplot y a grid.arrange() del paquete gridExtra.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#exportaci√≥n-de-gr√°ficos",
    "href": "dia4/6.2_ggplot2.html#exportaci√≥n-de-gr√°ficos",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "Exportaci√≥n de gr√°ficos",
    "text": "Exportaci√≥n de gr√°ficos\nExisten varias formas de exportar los gr√°ficos de ggplot2. Una de ellas es a trav√©s de la interfaz gr√°fica de RStudio, en el panel de gr√°ficos. Otra opci√≥n es encerrar el bloque de c√≥digo de la siguiente manera, y correr todo el bloque a la vez, bloque de c√≥digo que tambi√©n es v√°lido para gr√°ficos en R base:\n\npng(filename = \"dia4/scatterplot.png\", width = 1200, height = 1000, res = 300)\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\ndev.off()\n\nComo podemos observar, entre otros argumentos, es posible indicar el ancho, largo y la resoluci√≥n (en ppi). Otras alternativas a png() son jpeg() y tiff().\nOtra alternativa es utilizar la funci√≥n ggsave(), por ejemplo:\n\nggsave(filename = \"dia4/scatterplot.png\", dpi = 600, units = \"px\")\n\nAl no especificar qu√© gr√°fico exportar, se exporta el √∫ltimo gr√°fico devuelto en el panel de gr√°ficos. De lo contrario, es posible indicar expl√≠citamente qu√© gr√°fico exportar:\n\nplot5 &lt;- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del s√©palo\") +\n  scale_y_continuous(name = \"Longitud del p√©talo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  theme(aspect.ratio = 3/4)\n\nggsave(filename = \"scatterplot.png\", plot = plot5, dpi = 600, units = \"px\")",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia4/6.2_ggplot2.html#ejercicios",
    "href": "dia4/6.2_ggplot2.html#ejercicios",
    "title": "Introducci√≥n a gr√°ficos con ggplot2",
    "section": "Ejercicios",
    "text": "Ejercicios\nEl dataset Indometh contiene los datos de concentraci√≥n en sangre de una droga en funci√≥n del tiempo para 6 sujetos (para mayor informaci√≥n sobre el dataset, explore la ayuda con ?Indometh). Antes que nada, explore el dataset, su estructura y tipo de dato.\n\nGenere un gr√°fico de l√≠neas que relacione la concentraci√≥n de la droga en sangre en funci√≥n del tiempo, pero diferencie las tendencias entre sujetos con colores diferentes de l√≠neas. Incremente el grosor de cada l√≠nea lo que considere suficiente. Indique el t√≠tulo ‚Äú(a)‚Äù para el gr√°fico. Coloque nombres, en espa√±ol, a los ejes y a la leyenda. Inserte una l√≠nea vertical discontinua pasando por el valor x = 1. Establezca la relaci√≥n de aspecto en 9/16.\n\nLos niveles de la columna ‚ÄúSubject‚Äù est√°n desordenados. ¬øPor qu√©? Arreglar eso!\n\nGenere un gr√°fico relacionando las mismas variables que el anterior, pero haciendo un zoom a una regi√≥n particular del gr√°fico. Para ello, el c√≥digo ser√° casi id√©ntico al gr√°fico anterior, pero adem√°s deber√° utilizar la funci√≥n coord_fixed(), en donde deber√° indicar la regi√≥n del gr√°fico de inter√©s (explore ?coord_fixed sobre c√≥mo hacer esto). La regi√≥n donde har√° zoom ser√° la de mayor variaci√≥n de cambio entre la concentraci√≥n de la droga en sangre y el tiempo. Indique el t√≠tulo ‚Äú(b)‚Äù para el gr√°fico.\nGenere un panel con los gr√°ficos anteriores, a la izquierda el gr√°fico del punto 1 y a la derecha el del punto 2. El panel, al estar compuesto por gr√°ficos individuales, posiblemente contenga informaci√≥n redundante: el nombre para el eje vertical y la leyenda (est√° repetida). No es necesario repetir la informaci√≥n. Arreglar eso!\nExporte el panel gr√°fico con una resoluci√≥n de 300 ppi dentro de la carpeta ‚Äúdia4‚Äù del proyecto del curso. Para ello, explore ?png.",
    "crumbs": [
      "Inicio",
      "Unidad 4",
      "Gr√°ficos con *ggplot2*"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html",
    "href": "dia1/3.1_Operadores.html",
    "title": "Objetos y operadores",
    "section": "",
    "text": "Como ya vimos anteriormente, R es un lenguaje orientado a objetos y existe una gran variedad de ‚Äúcosas‚Äù que estos objetos pueden contener/almacenar. En general, los objetos que presentamos a continuaci√≥n permiten realizar la mayor√≠a de las tareas cotidianas en R.\n\n\n\n\n\n\n\nObjeto\nDescripci√≥n\n\n\n\n\nvector\nColecci√≥n de objetos de un mismo tipo (n√∫meros enteros, n√∫meros reales, texto, etc.). Los vectores son los objetos b√°sicos a partir de los cuales pueden crearse gran parte del resto de los objetos m√°s relevantes en R.\n\n\ndata.frame\nTabla que contiene datos, conformada por una serie de columnas como vectores. Las columnas de un data.frame pueden ser vectores de distinto tipo. Generalmente, estos objetos son cargados por el usuario a partir de un archivo, pero tambi√©n pueden ser creados con la funci√≥n data.frame().\n\n\nmatrix\nColecci√≥n de vectores organizado en filas y columnas. A diferencia de un data.frame, es un objeto que permite operaciones matem√°ticas propias de las matrices (e.g., suma o producto de matrices).\n\n\nlist\nEs una coleccion de objetos de cualquier tipo, sean vectores, tablas, matrices, otras listas y m√°s. Gran parte de las salidas de las funciones de R son listas, por ejemplo, la salida de un modelo lineal con la funcion lm().",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html#objetos-comunes-en-r",
    "href": "dia1/3.1_Operadores.html#objetos-comunes-en-r",
    "title": "Objetos y operadores",
    "section": "",
    "text": "Como ya vimos anteriormente, R es un lenguaje orientado a objetos y existe una gran variedad de ‚Äúcosas‚Äù que estos objetos pueden contener/almacenar. En general, los objetos que presentamos a continuaci√≥n permiten realizar la mayor√≠a de las tareas cotidianas en R.\n\n\n\n\n\n\n\nObjeto\nDescripci√≥n\n\n\n\n\nvector\nColecci√≥n de objetos de un mismo tipo (n√∫meros enteros, n√∫meros reales, texto, etc.). Los vectores son los objetos b√°sicos a partir de los cuales pueden crearse gran parte del resto de los objetos m√°s relevantes en R.\n\n\ndata.frame\nTabla que contiene datos, conformada por una serie de columnas como vectores. Las columnas de un data.frame pueden ser vectores de distinto tipo. Generalmente, estos objetos son cargados por el usuario a partir de un archivo, pero tambi√©n pueden ser creados con la funci√≥n data.frame().\n\n\nmatrix\nColecci√≥n de vectores organizado en filas y columnas. A diferencia de un data.frame, es un objeto que permite operaciones matem√°ticas propias de las matrices (e.g., suma o producto de matrices).\n\n\nlist\nEs una coleccion de objetos de cualquier tipo, sean vectores, tablas, matrices, otras listas y m√°s. Gran parte de las salidas de las funciones de R son listas, por ejemplo, la salida de un modelo lineal con la funcion lm().",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html#operadores",
    "href": "dia1/3.1_Operadores.html#operadores",
    "title": "Objetos y operadores",
    "section": "Operadores",
    "text": "Operadores\nUn operador es una expresi√≥n, compuesta por uno o m√°s s√≠mbolos, que realiza una operaci√≥n espec√≠fica sobre uno o m√°s valores para producir un resultado.\n\nOperadores aritm√©ticos\nRelacionan dos n√∫meros para generar un resultado.\n\n\n\nS√≠mbolo\nOperaci√≥n\n\n\n\n\n+\nSuma\n\n\n-\nResta\n\n\n*\nMultiplicaci√≥n\n\n\n/\nDivisi√≥n\n\n\n^\nPotenciaci√≥n\n\n\n%/%\nDivisi√≥n entera\n\n\n%%\nResto de la divisi√≥n\n\n\n\nPor ejemplo:\n\n5 + 7\n\n[1] 12\n\n\n\n3^4\n\n[1] 81\n\n\nEl uso de par√©ntesis muchas veces es necesario:\n\n3^(4+3)\n\n[1] 2187\n\n\n\n10 %/% 3\n\n[1] 3\n\n\n\n10 %% 3\n\n[1] 1\n\n\n\n\nOperadores relacionales\nRelacionan un valor con otro y devuelven una constante l√≥gica (TRUE o FALSE).\n\n\n\nS√≠mbolo\nOperaci√≥n\n\n\n\n\n&lt;\nMenor a‚Ä¶\n\n\n&lt;=\nMenor o igual a..\n\n\n&gt;\nMayor a‚Ä¶\n\n\n&gt;=\nMayor o igual a‚Ä¶\n\n\n==\nIgual a‚Ä¶\n\n\n!=\nDistinto de‚Ä¶\n\n\n\nPor ejemplo:\n\n8 &gt; 9\n\n[1] FALSE\n\n\n\n8 &gt;= 9\n\n[1] FALSE\n\n\n\n5 == 5\n\n[1] TRUE\n\n\n\n12 != 12\n\n[1] FALSE\n\n\n\n\nOperadores l√≥gicos o booleanos\n\n\nEstos operadores devuelven una constante l√≥gica (TRUE o FALSE).\n\n\n\nS√≠mbolo\nOperaci√≥n\n\n\n\n\n!\nNegaci√≥n\n\n\n&\nY\n\n\n&&\nY secuencial\n\n\n|\nO\n\n\n||\nO secuencial\n\n\nxor\nUni√≥n excluyente\n\n\n\n\n\n\n\nGeorge Boole, matem√°tico ingl√©s. En su honor, los operadores\nl√≥gicos tambi√©n se llaman ‚Äúbooleanos‚Äù.\n\n\n\n\nPara entender c√≥mo funcionan estos operadores las tablas de verdad son √∫tiles. Aqu√≠, aprenderemos el comportamiento de estos operadores mediante ejemplos.\nEl operador ! devuelve el resultado opuesto de una expresi√≥n l√≥gica dada:\n\n!(10 &gt; 5)\n\n[1] FALSE\n\n\nEl operador & (Y) combina dos o m√°s expresiones, y devuelve TRUE s√≥lo si todas las expresiones l√≥gicas son verdaderas:\n\n(10 &gt; 5) & (30 &gt; 20)\n\n[1] TRUE\n\n\nEn cambio, devuelve FALSE si alguna de ellas no es verdadera:\n\n(10 &gt; 5) & (30 &gt; 40)\n\n[1] FALSE\n\n\nEl operador | (O) combina dos o m√°s expresiones, y devuelve TRUE si al menos una de las expresiones l√≥gicas son verdaderas:\n\n(10 &gt; 5) | (30 &gt; 40)\n\n[1] TRUE\n\n\nEn cambio, devuelve FALSE si ninguna de las expresiones son verdaderas:\n\n(10 &gt; 15) | (30 &gt; 40)\n\n[1] FALSE\n\n\nEl operador xor es en realidad una funci√≥n con dos argumentos. S√≥lo devuelve TRUE cuando una condici√≥n es verdadera y la otra es falsa:\n\nxor(10 &gt; 5, 30 &gt; 40)\n\n[1] TRUE\n\n\nEn cambio, devuelve FALSE cuando ambas expresiones son verdaderas:\n\nxor(10 &gt; 5, 30 &gt; 20)\n\n[1] FALSE\n\n\nO ambas son falsas:\n\nxor(10 &gt; 15, 30 &gt; 40)\n\n[1] FALSE\n\n\nLos operadores && y || trabajan secuencialmente, s√≥lo eval√∫an la segunda condici√≥n si la primera es TRUE. Si la primera condici√≥n ya es FALSE, no se eval√∫a la segunda condici√≥n. Adquieren mayor sentido cuando el segundo elemento de la comparaci√≥n no est√° definido, y suele utilizarse en contextos de programaci√≥n m√°s avanzada. Por ejemplo:\n\na &lt;- 5\na &lt; 3 && b &gt; 10\n\n[1] FALSE\n\n\nAqu√≠ vemos que el objeto b no existe en el ambiente de R. Sin embargo, el resultado es FALSE porque la primera condici√≥n ya es falsa. Si hici√©ramos la misma comparaci√≥n con &, R devuelve un error:\n\na &lt;- 5\na &lt; 3 & b &gt; 10\n\nError: objeto 'b' no encontrado\n\n\nVeamos un ejemplo similar con el operador ||:\n\na &lt;- 5\na &gt; 3 || b &gt; 10\n\n[1] TRUE\n\n\nEl resultado es TRUE, porque la primera condici√≥n ya es verdadera. El mismo c√≥digo con | arroja un error:\n\na &lt;- 5\na &gt; 3 | b &gt; 10\n\nError: objeto 'b' no encontrado\n\n\nLas funciones all() y any() permiten evaluar m√°s de una condici√≥n simult√°neamente. La funci√≥n all() devuelve TRUE si todas las condiciones indicadas son verdaderas, caso contrario devuelve FALSE. Su comportamiento es an√°logo al operador & utilizado secuencialmente. Las condiciones se escriben de a una y separadas por coma. Por ejemplo:\n\na &lt;- 5\nb &lt;- 10\nc &lt;- 15\nall(a &gt; 3, b &gt; 8, c &gt; 11)\n\n[1] TRUE\n\n\nTodas las condiciones son verdaderas, por lo que devuelve TRUE. Si en cambio al menos una es falsa, obtenemos FALSE:\n\nall(a &gt; 3, b &gt; 8, c &gt; 21)\n\n[1] FALSE\n\n\nLa funci√≥n any() devuelve TRUE si al menos una condici√≥n es verdadera. Su comportamiento es an√°logo al operador | utilizado de manera secuencial. Por ejemplo:\n\nany(a &gt; 7, b &gt; 12, c &gt; 13)\n\n[1] TRUE\n\n\nEn cambio, si todas las condiciones son falsas, any() devuelve FALSE:\n\nany(a &gt; 7, b &gt; 12, c &gt; 23)\n\n[1] FALSE",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/3.1_Operadores.html#ejercicios",
    "href": "dia1/3.1_Operadores.html#ejercicios",
    "title": "Objetos y operadores",
    "section": "Ejercicios",
    "text": "Ejercicios\n\nLa variable y puede calcularse mediante la siguiente f√≥rmula:\n\n\\[ \\hspace{-9cm} y = a + b\\sqrt{x+2} + cx^2 \\]\nSiendo a = 5.3, b = 3.2 y c = 1.7, calcule el valor de y cuando x = 20.\n\nSin correr las siguientes l√≠neas, ¬øcu√°l es el resultado de cada expresi√≥n?\n\n\nx &lt;- 10\ny &lt;- 90\n\n(x &lt;= 10) & (y &gt; 40)\n(x == 10) | (y == 89)\n((x &gt; 5) & (y != 70)) & (x*y &gt; 1000)\n\n\n¬øQu√© hacen las funciones round(), floor(), ceiling() y trunc()?\n\n\nround(x = 6.756)\nround(6.756, digits = 2)\ntrunc(6.756)\nceiling(6.356)\nfloor(x = 6.756)",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Objetos y operadores"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html",
    "href": "dia1/1.2_UsandoR.html",
    "title": "Primeros pasos con R y RStudio",
    "section": "",
    "text": "R puede ser utilizado de forma interactiva inici√°ndolo directamente de cualquier terminal de BASH (en sistemas UNIX-like), o desde el ‚ÄúSimbolo del sistema‚Äù o haciendo doble click en el ejecutable t√≠picamente localizado en ‚ÄúC:\\Program Files\\R\\R-version\\bin\\x64\\‚Äù (en sistemas Windows). Por ejemplo en cualquier distribuci√≥n GNU/Linux, bastar√° con abrir la terminal e ingresar el comando ‚ÄúR‚Äù.\n\n Click en la imagen para agrandar.\n\nCuando R es iniciado de esa forma, veremos un texto con una peque√±a presentaci√≥n de R, incluyendo la versi√≥n que se est√° ejecutando y algunas ayudas b√°sicas. Luego de este texto, vemos una linea vac√≠a comenzada por el car√°cter &gt;. Este √∫ltimo car√°cter se conoce como prompt y nos indica que R est√° listo para recibir √≥rdenes. As√≠ pues, podr√≠amos pedir que nos imprima una bienvenida al curso utilizando la funci√≥n print(), haciendo por ejemplo:\n\nprint(\"Bienvenides al curso!!!\")\n\n\n Click en la imagen para agrandar.\n\nA√∫n funcionando desde un CLI, sin una interfaz gr√°fica, debido a que R est√° pensado para funcionar en sistemas de ventanas, es posible realizar gr√°ficos y estos se mostraran en una nueva ventana exclusivamente creada para tal fin. Podr√≠amos por ejemplo graficar 3 puntos de diferentes colores, ubicados en las coordenadas (x,y)=(1,1 ; 2,1 ; 3,1):\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n Click en la imagen para agrandar.\n\nComo al usar R de esta forma solo podremos ir ejecutando de a una orden a la vez, puede ser conveniente disponer de alg√∫n editor de texto plano para poder ir guardando nuestro c√≥digo a medida que lo vamos escribiendo y ejecutando. Para ello podemos utilizar cualquier editor de texto plano (e.g., en GNU/Linux podemos usar ‚Äúgedit‚Äù o el editor que traiga nuestra distribuci√≥n; en Windows podemos utilizar ‚ÄúBloc de Notas‚Äù, ‚ÄúNotepad++‚Äù, etc). Aprovechando el espacio del escritorio de nuestra PC podr√≠amos entonces hacer una disposici√≥n con las ventanas abiertas de nuestra terminal donde ejecutamos R, la ventana gr√°fica donde se mostrar√°n nuestros gr√°ficos, el archivo de texto plano con nuestro c√≥digo y podr√≠amos sumar tambi√©n una ventana con las carpetas donde estamos guardando el trabajo y desde donde leeremos los datos que cargaremos a R. Algo parecido a lo siguiente:\n\n Click en la imagen para agrandar.\n\nFinalmente, si deseamos salir de la sesi√≥n de R activa, podemos utilizar la funci√≥n quit() (o su forma abreviada q()), a lo que R responder√° preguntando si queremos guardar una imagen del espacio de trabajo, a lo que responderemos que NO ingresando n. Esto cerrara cualquier ventana gr√°fica que hubiera abierta, as√≠ como en nuestra terminal veremos que el prompt vuelve a ser el de nuestro sistema.\n\n\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#c√≥mo-se-usa-r",
    "href": "dia1/1.2_UsandoR.html#c√≥mo-se-usa-r",
    "title": "Primeros pasos con R y RStudio",
    "section": "",
    "text": "R puede ser utilizado de forma interactiva inici√°ndolo directamente de cualquier terminal de BASH (en sistemas UNIX-like), o desde el ‚ÄúSimbolo del sistema‚Äù o haciendo doble click en el ejecutable t√≠picamente localizado en ‚ÄúC:\\Program Files\\R\\R-version\\bin\\x64\\‚Äù (en sistemas Windows). Por ejemplo en cualquier distribuci√≥n GNU/Linux, bastar√° con abrir la terminal e ingresar el comando ‚ÄúR‚Äù.\n\n Click en la imagen para agrandar.\n\nCuando R es iniciado de esa forma, veremos un texto con una peque√±a presentaci√≥n de R, incluyendo la versi√≥n que se est√° ejecutando y algunas ayudas b√°sicas. Luego de este texto, vemos una linea vac√≠a comenzada por el car√°cter &gt;. Este √∫ltimo car√°cter se conoce como prompt y nos indica que R est√° listo para recibir √≥rdenes. As√≠ pues, podr√≠amos pedir que nos imprima una bienvenida al curso utilizando la funci√≥n print(), haciendo por ejemplo:\n\nprint(\"Bienvenides al curso!!!\")\n\n\n Click en la imagen para agrandar.\n\nA√∫n funcionando desde un CLI, sin una interfaz gr√°fica, debido a que R est√° pensado para funcionar en sistemas de ventanas, es posible realizar gr√°ficos y estos se mostraran en una nueva ventana exclusivamente creada para tal fin. Podr√≠amos por ejemplo graficar 3 puntos de diferentes colores, ubicados en las coordenadas (x,y)=(1,1 ; 2,1 ; 3,1):\n\nplot(1:3, rep(1,3), pch=16, col=c(\"blue\",\"red\",\"black\"), cex=5)\n\n\n Click en la imagen para agrandar.\n\nComo al usar R de esta forma solo podremos ir ejecutando de a una orden a la vez, puede ser conveniente disponer de alg√∫n editor de texto plano para poder ir guardando nuestro c√≥digo a medida que lo vamos escribiendo y ejecutando. Para ello podemos utilizar cualquier editor de texto plano (e.g., en GNU/Linux podemos usar ‚Äúgedit‚Äù o el editor que traiga nuestra distribuci√≥n; en Windows podemos utilizar ‚ÄúBloc de Notas‚Äù, ‚ÄúNotepad++‚Äù, etc). Aprovechando el espacio del escritorio de nuestra PC podr√≠amos entonces hacer una disposici√≥n con las ventanas abiertas de nuestra terminal donde ejecutamos R, la ventana gr√°fica donde se mostrar√°n nuestros gr√°ficos, el archivo de texto plano con nuestro c√≥digo y podr√≠amos sumar tambi√©n una ventana con las carpetas donde estamos guardando el trabajo y desde donde leeremos los datos que cargaremos a R. Algo parecido a lo siguiente:\n\n Click en la imagen para agrandar.\n\nFinalmente, si deseamos salir de la sesi√≥n de R activa, podemos utilizar la funci√≥n quit() (o su forma abreviada q()), a lo que R responder√° preguntando si queremos guardar una imagen del espacio de trabajo, a lo que responderemos que NO ingresando n. Esto cerrara cualquier ventana gr√°fica que hubiera abierta, as√≠ como en nuestra terminal veremos que el prompt vuelve a ser el de nuestro sistema.\n\n\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-1",
    "href": "dia1/1.2_UsandoR.html#ejercicio-1",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nAbra R desde una terminal de su sistema operativo e intente replicar las l√≠neas de c√≥digo mostradas en la parte previa, de paso, sabremos que su sistema tiene correctamente instalado R.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#presentando-a-rstudio",
    "href": "dia1/1.2_UsandoR.html#presentando-a-rstudio",
    "title": "Primeros pasos con R y RStudio",
    "section": "Presentando a RStudio",
    "text": "Presentando a RStudio\nA pesar de lo sencillo que resulta usar R nativamente en cualquier sistema, para ahorrarnos tener que usar m√∫ltiples programas en simult√°neo, as√≠ como para sumar toda una gran colecci√≥n de funcionalidades y herramientas que nos facilitar√°n mucho el trabajo, es recomendable utilizar R en conjunto con alguna IDE. En este curso, utilizaremos RStudio.\n\n Click en la imagen para agrandar.\n\nEn la figura precedente podemos identificar r√°pidamente las principales √°reas de trabajo con diferentes funcionalidades que nos ofrece el programa (estos paneles pueden maximizarse, minimizarse o redimensionarse a gusto con el puntero del mouse, as√≠ como personalizarse en ‚ÄúTools &gt; Global Options &gt; Pane Layout‚Äù):\n\n\nConsola: una consola de R equivalente a la que iniciamos previamente y con la misma funcionalidad.\n\n\nFuente: equivalente al editor de texto plano (este panel puede no abrirse por defecto si todav√≠a no creamos ninguna rutina, para ello hacer ‚ÄúFile &gt; New File &gt; R Script‚Äù o click en el bot√≥n  [a])\n\n\nEntorno: muestra todos los objetos creados ordenados por tipo, permite la carga de dataset gr√°ficamente y la gesti√≥n de la memoria en uso.\n\n\nArchivos, Gr√°ficos, Paquetes, Ayuda: esta es una √°rea de mucho uso ya que permite ver y manipular el sistema de archivos d√≥nde estamos trabajando [b], as√≠ como gestionar los paquetes de R gr√°ficamente [c]. Adem√°s, cambiar√° autom√°ticamente al √°rea gr√°fica cuando realicemos un gr√°fico [d] y cambiar√° a las ayudas internas disponibles en caso de solicitarlo [e].\n\n\nCuando tengamos una rutina (i.e.¬†un script) creada, podremos ejecutar directamente desde la misma el c√≥digo sin necesidad de ‚Äúcopiar y pegar‚Äù en la consola de R. Para ello, con el cursor de texto sobre la linea de c√≥digo podemos utilizar el bot√≥n  Run ubicado en el sector superior derecho del panel Fuente, o utilizar el atajo de teclado Ctrl + Enter. Esto mismo podemos hacerlo sobre varias l√≠neas, seleccionando con el cursor todas aquellas l√≠neas que querramos ejecutar.\nPara prestar atenci√≥n: un script no es m√°s que una serie ordenada de √≥rdenes que se ejecutan una tras otra. Por defecto, siempre que ejecutemos un script completo, no importa si lo hacemos l√≠nea a l√≠nea o seleccionado todo el conjunto, la ejecuci√≥n subyacente es secuencial. Para romper este comportamiento existen estructuras especiales conocidas como ‚ÄúEstructuras de control de flujo‚Äù, que estudiaremos m√°s adelante.\nPara pensar: en el ejemplo de la figura previa existen l√≠neas que comienzan con un car√°cter # (llamado de muchas formas: numeral, almohadilla, hashtag). Si presta atenci√≥n, esas l√≠neas est√°n coloreadas de forma homog√©nea en el editor y, adem√°s, aparentan tener mensajes que explican el c√≥digo. ¬øQu√© imagina que sucede cuando se ejecutan? ¬øC√≥mo se llama y qu√© funci√≥n cumplen esas l√≠neas? M√°s adelante veremos otra forma adicional de utilizarlas para organizar nuestro c√≥digo en RStudio.\n\nProyectos en RStudio\nUna de las primeras nociones sobre las buenas pr√°cticas de trabajo es intentar mantener una organizaci√≥n coherente de nuestro c√≥digo, as√≠ como de los archivos de entrada (i.e.¬†los datos) y salida (i.e.¬†resultados, gr√°ficos, etc). Aunque estrictamente no existe una forma √∫nica ni correcta de organizaci√≥n y cada persona debe encontrar lo que le resulta m√°s pr√°ctico, siempre debemos considerar que existen potenciales receptores de nuestro c√≥digo que idealmente tendr√≠an que interpretar con el menor esfuerzo posible la organizaci√≥n seguida. Incluso podemos ser nosotros mismos quienes en un futuro revisitemos algo que hicimos hace un tiempo y le estaremos enormemente agradecidos a nuestra versi√≥n del pasado por haber mantenido una organizaci√≥n coherente.\nCuando trabajamos con RStudio, esto √∫ltimo puede ser muy sencillo de realizar utilizando los proyectos, que no son otra cosa m√°s que una forma de mantener nuestro trabajo en un contexto dado, con su propio directorio de trabajo, historial, rutinas, entradas, salidas, etc. De esta forma, pensemos por ejemplo en una organizaci√≥n con una estructura hipot√©tica similar a la siguiente:\n\n\nAnalisisTesis\n  |\n  |-- CapII\n  |     |\n  |     |-- datos\n  |     |     |-- muestreoEne-Mar.csv\n  |     |     |-- muestreoAgo-Oct.csv\n  |     |      \n  |     |--resultados\n  |     |     |-- diversidad.txt\n  |     |     |-- composicion.txt\n  |     |     |-- graficos\n  |     |            |-- fig_div_estacion.pdf\n  |     |            |-- fig_NMDS.pdf\n  |     |\n  |     |-- analisis\n  |           |-- exploratorios.R\n  |           |-- anova.R\n  |           |-- NMDS.R\n  |-- CapIII\n  |     |\n  |    ...\n ...\nEn este caso, podr√≠amos entonces pensar en crear un proyecto para todo el conjunto de ‚ÄúAnalisisTesis‚Äù o podemos subdividir y crear un proyecto por cada cap√≠tulo que requiera realizar algun tipo de an√°lisis. De nuevo, no hay una manera √∫nica, todo depender√° del contexto y lo que resulte -o parezca resultar- √≥ptimo en cada situaci√≥n.\nExisten m√∫ltiples formas de crear un nuevo proyecto. Podemos hacer ‚ÄúFile &gt; New Project‚Ä¶‚Äù; podemos usar el bot√≥n  en la esquina superior izquierda; o utilizar el men√∫ de proyectos  Project: (None), situado en la esquina superior derecha. A la hora de crear un nuevo proyecto, podemos elegir partir de un directorio nuevo o de uno previamente creado. As√≠ mismo, podemos elegir un tipo espec√≠fico de proyecto seg√∫n si estemos haciendo un proyecto general, un proyecto para un nuevo paquete de R, una aplicaci√≥n Shiny, etc. Todo esto se realiza mediante una serie de men√∫s gr√°ficos que se nos ir√°n presentado y que son sumamente intuitivos de seguir.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-2",
    "href": "dia1/1.2_UsandoR.html#ejercicio-2",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nLuego de ver la demostraci√≥n del docente sobre la creaci√≥n de proyectos en RStudio, abra una sesi√≥n propia de RStudio y cree un proyecto para este curso. La organizaci√≥n sugerida es la siguiente:\nfundamentosR\n  |\n  |-- fundamentosR.Rproj\n  |-- dia1\n  |     |-- mi_rutinaR.R\n  |\n  |--dia2\n  |--dia3\n ...\nA medida que el curso avance, iremos completando estos directorios con datos, rutinas, etc.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-3",
    "href": "dia1/1.2_UsandoR.html#ejercicio-3",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nCree una rutina dentro de dia1, como se muestra en la estructura precedente, que contenga el c√≥digo ejecutado en el Ejercicio 1 para el mensaje de bienvenida y el gr√°fico. Corra esas l√≠neas y explore las funciones del panel gr√°fico. Finalmente, guarde el mismo como un archivo PNG dentro del directorio dia1.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#el-directorio-de-trabajo",
    "href": "dia1/1.2_UsandoR.html#el-directorio-de-trabajo",
    "title": "Primeros pasos con R y RStudio",
    "section": "El directorio de trabajo",
    "text": "El directorio de trabajo\nCuando trabajamos con R, impl√≠citamente lo estamos haciendo en alguna ubicaci√≥n de nuestro sistema de archivos. Los proyectos de RStudio facilitan esta cuesti√≥n haciendo que el directorio de trabajo sea aquel en el cual creamos el proyecto. Para conocer en donde estamos trabajando, podemos utilizar la funci√≥n getwd(). Por ejemplo, mientras escribo esta gu√≠a puedo ver en qu√© ubicaci√≥n se encuentra el proyecto en la cual la estoy realizando (S√≠! R es tan vers√°til, que hasta podemos crear p√°ginas web y cualquier otro tipo de documento con su propio formato, im√°genes embebidas, v√≠nculos de internet, etc.):\n\ngetwd()\n\n[1] \"/home/usuario/cursoR/repos/fundamentos_R/dia1\"\n\n\nSi por algun motivo deseara cambiar el directorio de trabajo, puedo hacerlo desde el men√∫ ‚ÄúSession &gt; Set Working Directory &gt; Choose Directory‚Äù o, de forma m√°s sencilla, utilizar la funci√≥n setwd():\n\n# setwd(\"/home/usuario/R/mi_proyecto_de_R\") # ejecuci√≥n sin salida en consola\n# getwd() # muestra el nuevo working directory\n# setwd(\"/home/usuario/cursoR/clases/1_2_usandoR/\") # regreso al original\n# getwd() # muestra el nuevo working directory\n\n\nRutas relativas y absolutas\nUna ruta (en ingl√©s path) en R o en cualquier otro sistema inform√°tico es la ‚Äúdirecci√≥n‚Äù de cada archivo que existe en el sistema de archivos. De forma general, existen dos formas de representar a cualquier ruta:\n\nLas rutas absolutas son aquellas en las que expl√≠citamente se indica todo el trayecto realizado desde la r√°iz del sistema hasta la ubicaci√≥n en cuesti√≥n. En los sistemas GNU/Linux, la ra√≠z del sistema es / (llamado root); mientras que en los sistemas Windows ser√° el origen del disco que este utiliz√°ndose, t√≠picamente C:\\. Teniendo esto en cuenta, la ruta anterior al directorio de trabajo es una ruta absoluta, ya que en la misma se explicita toda la ruta desde la ra√≠z hasta el archivo.\nLas rutas relativas por su parte, nos muestran la ubicaci√≥n de un archivo o directorio en sentido relativo al directorio de trabajo activo. Generalmente, las mismas empiezan con uno o dos caracteres de punto ‚Äú.‚Äù, teniendo la expresi√≥n ./ el significado literal de ‚Äúen este directorio‚Äù, es decir, en el directorio actual; mientras que la expresi√≥n ../ indica el directorio superior en la jerarqu√≠a del directorio actual. Tener en cuenta que en sistemas Windows, el caracter que separa directorios es la ‚Äúbarra inversa‚Äù, por lo que en esos sistemas ser√°: .\\ y ..\\.\n\nComo ejemplo, tomando como referencia la estructura sugerida para el proyecto de los analisis de la tesis, si el directorio de trabajo activo fuera analisis dentro de CapII, la ruta relativa a CapIII seria ../../CapIII",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-4",
    "href": "dia1/1.2_UsandoR.html#ejercicio-4",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 4",
    "text": "Ejercicio 4\nImagine que dentro del directorio /home/usuario/Documentos, posee la siguiente estructura de directorios:\ncarpeta0/\n‚îú‚îÄ‚îÄ archivo0_a\n‚îú‚îÄ‚îÄ archivo0_b\n‚îú‚îÄ‚îÄ carpeta1\n‚îÇ  ‚îú‚îÄ‚îÄ archivo1_a\n‚îÇ  ‚îú‚îÄ‚îÄ archivo1_b\n‚îÇ  ‚îî‚îÄ‚îÄ archivo1_c\n‚îî‚îÄ‚îÄ carpeta2\n    ‚îú‚îÄ‚îÄ archivo2_a\n    ‚îú‚îÄ‚îÄ archivo2_b\n    ‚îî‚îÄ‚îÄ carpeta2a\n        ‚îú‚îÄ‚îÄ archivo2a_a\n        ‚îî‚îÄ‚îÄ carpeta2b\n            ‚îî‚îÄ‚îÄ archivo2b_a     \n\n¬øCu√°l ser√≠a la ruta absoluta al archivo ‚Äúarchivo1_c‚Äù?\n\n\nSu respuesta:  OK\n\n\n\n\n\n¬øC√≥mo ser√≠a la ruta relativa desde el directorio ‚Äúcarpeta2b‚Äù hacia el archivo ‚Äúarchivo1_c‚Äù?\n\n\nSu respuesta:  OK",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#las-rutas-en-los-proyectos-de-rstudio",
    "href": "dia1/1.2_UsandoR.html#las-rutas-en-los-proyectos-de-rstudio",
    "title": "Primeros pasos con R y RStudio",
    "section": "Las rutas en los proyectos de RStudio",
    "text": "Las rutas en los proyectos de RStudio\nCuando trabajamos dentro de un proyecto de RStudio, todas las rutas son relativas a la ra√≠z del proyecto. Esto tiene algunas ventajas, como por ejemplo si compartimos nuestro proyecto con colaboradores, estos no necesitar√°n configurar las rutas para su sistema, ya que las rutas se mantienen relativas al proyecto. Por otro lado, no es necesario que anonimicemos nuestras rutas, ya que si trabajamos exclusivamente dentro de la carpeta ra√≠z del proyecto, no deber√≠a aparecer ninguna ruta absoluta. Las razones por las que quisi√©ramos mantener nuestras otras carpetas internas privadas son muchas, y variar√°n en cada caso, pero para un ejemplo interesante podemos considerar el siguiente caso:\n\n Click en la imagen para agrandar.\n\nPor cierto, Alexandra es, ni m√°s ni menos, la creadora del sitio Sci-Hub y esa captura corresponde a una gu√≠a b√°sica para voluntarias/os de Anna‚Äôs Archive.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#buscando-ayuda-en-r",
    "href": "dia1/1.2_UsandoR.html#buscando-ayuda-en-r",
    "title": "Primeros pasos con R y RStudio",
    "section": "Buscando ayuda en R",
    "text": "Buscando ayuda en R\nUna de las cosas que m√°s intimidan a quienes intentan aprender un lenguaje de programaci√≥n suele ser intentar recordar el nombre de todas las funciones disponibles y c√≥mo se usa exactamente cada una. Pero lo cierto es que esto rara vez preocupa a quienes llevan un tiempo inmersos en alg√∫n lenguaje. Esto es as√≠, ya que como el resto de los lenguajes m√°s populares, R posee un compendio de documentaci√≥n interna que explica detalladamente cada una de sus funciones. Esta ayuda se encuentra disponible desde la instalaci√≥n de R, as√≠ como de cada uno de los paquetes oficiales, y puede ser consultada incluso fuera de l√≠nea (i.e.¬†sin conexi√≥n a internet).\nExisten m√∫ltiples formas de consultar esta documentaci√≥n. Si nos encontramos trabajando directamente desde una consola de R, podremos invocar la ayuda con la funci√≥n help(funcion), donde funcion es el nombre de la funci√≥n o el objeto sobre el que estamos requiriendo la documentaci√≥n. Por ejemplo, con la formula help(help) podemos obtener la ayuda de la funci√≥n de ayuda:\n\n Click en la imagen para agrandar.\n\nAs√≠ mismo, disponemos de una versi√≥n corta de la funci√≥n previa, que es la funci√≥n ?funcion y en caso de que queramos buscar con una palabra clave, ya que no recordamos siquiera el nombre de la funci√≥n o paquete, podemos utilizar ??palabraclave.\nEn RStudio, como ya mencionamos antes, disponemos de un √°rea espec√≠fica para mostrar la ayuda. Est√° √°rea se activar√° autom√°ticamente al solicitar alguna ayuda, e incluso disponemos de una funci√≥n de autocompletado con ayudas en ventanas emergentes. Para activarla, solo debemos comenzar a escribir el nombre de la funci√≥n y apretar la tecla Tab ‚Üπ. En la siguiente figura, podemos ver que sucede al comenzar a escribir ‚Äúme + Tab ‚Üπ‚Äù:\n\n Click en la imagen para agrandar.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-5",
    "href": "dia1/1.2_UsandoR.html#ejercicio-5",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\nEn RStudio corra las siguientes l√≠neas de a una y observe que salidas le brinda el programa. An√≠mese a explorar, no hay nada que pueda romper, haga click aqu√≠ y all√°, vaya y vuelva. De igual forma, intente utilizar el autocompletado y las ayudas emergentes, fomente su creatividad buscando lo que se le ocurra, o intente averiguar como se usa esa funci√≥n que hace 2 o 3 semanas que no logra ejecutar sin error. En clase discutiremos que partes componen la ayuda y como interpretarla.\n\nhelp(help)\n?help\n??distance\n?plot\n\n\nForos y bit√°coras de la comunidad\nAdem√°s de estas √∫tiles ayudas offline, si contamos con una conexi√≥n a internet, por supuesto no dudaremos en hacer uso extensivo de buscadores. Muchas veces, m√°s que saber c√≥mo opera una funci√≥n en particular, queremos conocer como realizar una acci√≥n dada, con el m√©todo que sea. Aprender a buscar es en s√≠ mismo un arte. La cantidad de sitios con informaci√≥n sobre R es inabarcable y muchas veces podemos perdernos en el af√°n de encontrar lo que buscamos, por ello a continuaci√≥n veremos algunas recomendaciones.\n\nEl idioma en que buscamos importa. Como para cualquier otra b√∫squeda, no encontraremos los mismos recursos si buscamos en espa√±ol que si buscamos en ingl√©s.\n\n\n Click en la imagen para agrandar.\n\n\nExisten m√∫ltiples foros que incluyen hilos espec√≠ficos para R, buscar en ellos muchas veces es una forma segura de aprender como hacer algo. La √∫nica recomendaci√≥n en este sentido, aunque no podemos enfatizarla lo suficiente, es que nunca debemos ejecutar c√≥digo que no comprendamos. Si creemos que cierto fragmento de c√≥digo nos puede ser √∫til, primero intentemos entenderlo con un ejemplo de juguete, en una sesi√≥n nueva, lejos de nuestros scripts de los an√°lisis en curso. Cuando pensemos que hemos podido entender como funciona, entonces ya estamos listos para trasladar ese c√≥digo a nuestro script. Si no encontramos la respuesta al problema espec√≠fico que tenemos, en estos foros tambi√©n podemos realizar una pregunta y nos responder√°n bastante r√°pido. La clave es poder expresar concretamente el problema, el resultado esperado y, en la medida de lo posible, brindar un conjunto de datos m√≠nimo que sirva de ejemplo al que realmente queremos procesar. A continuaci√≥n un ejemplo de Stack Overflow\n\n\n Click en la imagen para agrandar.\n\n\nAdemas de los foros, existe una cantidad inmensa de art√≠culos en sitios webs dedicados a R, as√≠ como en blogs personales. Muchas personas, que de hecho investigan en problemas similares a los nuestros, dedican mucho tiempo a publicar m√©todos de an√°lisis en R, incluyendo muchas veces apartados con explicaciones te√≥ricas sobre ciertos t√≥picos. Nunca est√° de m√°s tomarse el tiempo para ver que encontramos. Debajo un ejemplo correspondiente a los materiales de un sitio sobre Analisis en ecologia de comunidades en R.\n\n\n Click en la imagen para agrandar.\n\n\n\nLos errores como una oportunidad de aprendizaje\nMuy frecuentemente nos encontraremos con errores en la ejecuci√≥n de alguna l√≠nea. Lejos de desanimarnos y/o frustrarnos, debemos pensar que los errores son una oportunidad de aprendizaje. Los errores puede ir desde peque√±os errores de tipeo, hasta la falta de memoria de c√≥mputo para la acci√≥n requerida, pasando por operaciones imposibles de realizar o falta de argumentos obligatorios en las funciones. En cualquier caso, lo primero que debemos hacer es mantener la calma e intentar interpretar el mensaje de error. Si no logramos solucionarlo por nuestra cuenta, siempre podemos copiar el mensaje y ver que ayuda obtenemos en l√≠nea.\n\ndata(iris)\niris[iris$Sepal.Length &gt; 3]\n\nError in `[.data.frame`(iris, iris$Sepal.Length &gt; 3): columnas no definidas seleccionadas\n\n\n\n Click en la imagen para agrandar.\n\nSobre los warnings: ocasionalmente R no producir√° un mensaje de error, sino una advertencia. En estos casos, tambi√©n es importante que intentemos entender que est√° ocasionando este mensaje para saber si es algo cr√≠tico o no, sobre todo en cuanto a resultados de an√°lisis se refiere.\n\n\nUso de IA\nOtra fuente de ayuda en los tiempos modernos, es recurrir al chatbot de inteligencia artificial de su preferencia. Una vez m√°s, lo importante es intentar interpretar el c√≥digo previo a su ejecuci√≥n. En sentido estricto, podr√≠amos darle nuestros datos a un chatbot y pedirle todos los an√°lisis necesarios y, si supimos desmenuzar e indicar nuestra pregunta correctamente, incluso es posible que la salida sea correcta. Dicho esto, estamos aqu√≠ para aprender a hacerlo nosotros mismos, por ende, si bien es una fuente m√°s de ayuda, el objetivo es que aunque el c√≥digo lo produzca la IA, seamos capaces de entender completamente lo que est√° sucediendo.\nFuera de estas consideraciones, podemos preguntar directamente como hacer algo, como en el ejemplo que sigue:\n\n Click en la imagen para agrandar.\n\nO incluso podemos darle alg√∫n fragmento de c√≥digo que falla, y pedirle que intente encontrar el error y explicarnos que es lo que lo esta generando:\n\n Click en la imagen para agrandar.\n\nPara pensar: m√°s adelante aprenderemos efectivamente a filtrar una tabla basados en una condici√≥n. Recuerde la respuesta brindada por la IA en este ejemplo y veremos luego si es una ‚Äúbuena‚Äù respuesta.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#instalaci√≥n-y-carga-de-paquetes",
    "href": "dia1/1.2_UsandoR.html#instalaci√≥n-y-carga-de-paquetes",
    "title": "Primeros pasos con R y RStudio",
    "section": "Instalaci√≥n y carga de paquetes",
    "text": "Instalaci√≥n y carga de paquetes\nA medida que usemos R nos surgir√° la necesidad de instalar paquetes por fuera de la versi√≥n b√°sica, para a√±adir funcionalidades extras a R. Esto se puede realizar sencillamente desde RStudio, ya sea utilizando la interfaz gr√°fica o con funciones especificas para la instalaci√≥n; as√≠ como podemos realizar la instalaci√≥n desde CRAN o desde repositorios externos (e.g.¬†GitHub).\n\nInstalaci√≥n desde CRAN\nLa forma m√°s sencilla de instalar paquetes es usando la funci√≥n install.packages(), indicando en el argumento de la funci√≥n el nombre del paquete. Si no recordamos exactamente el nombre, podemos hacer uso de la funci√≥n de autocompletado (con la tecla Tab ‚Üπ). Tambi√©n podemos utilizar el bot√≥n  para instalar paquetes, en el √°rea correspondiente de RStudio. Si usamos esta √∫ltima forma, se abrir√° una ventana de di√°logo, donde podemos indicar el nombre del paquete a instalar.\n\n\n\n\n Click en la imagen para agrandar.\n\nEs importante recordar que cuando realicemos la instalaci√≥n, muchas veces ser√° necesario instalar otros paquetes que son requeridos para que funcione correctamente el paquete que queremos usar. Estos paquetes necesarios se conocen como dependencias y por defecto R instalar√° todas las dependencias necesarias. En la siguiente imagen se muestra la descripci√≥n de vegan, un paquete muy popular para Ecolog√≠a de Comunidades, d√≥nde podemos ver que depende de los paquetes permutey lattice, en sus versiones m√≠nimas 0.9 y 4.1 respectivamente, as√≠ como ‚Äúimporta‚Äù los paquetes MASS, cluster y mgcv.\n\n Click en la imagen para agrandar.\n\nDentro de los errores comunes que podemos encontrar tenemos:\n\nNo indicamos entre comillas el nombre del paquete. Recordar que la sintaxis correcta es install.packages(\"paquete\") y no install.packages(paquete).\nQueremos instalar m√∫ltiples paquetes sin indicar correctamente la lista de paquetes a instalar. Recordar que en ese caso ser√≠a install.packages(c(\"paquete1\", \"paquete2\", \"paquete3\")) utilizando la nomenclatura de un vector (m√°s adelante esto tendr√° sentido, no se preocupe si ahora no lo entiende).\nAlguna dependencia se encuentra en una versi√≥n anterior a la necesaria y no puede actualizarse. Esto normalmente se debe a que otro paquete la tiene fijada en una versi√≥n anterior. Se soluciona, generalmente, reiniciando la sesi√≥n de R, actualizando independientemente el paquete en cuesti√≥n y luego re-intentando la instalaci√≥n del paquete objetivo. Atenci√≥n: si un paquete tiende a fijar alguna dependencia en una versi√≥n dada, es posible que ese paquete sea viejo y ya no se est√© manteniendo; en cuyo caso debemos evaluar si tiene sentido seguir us√°ndolo, principalmente porque al actualizar su dependencia se generar√° un conflicto y ya no funcionar√°.\n\n\n\n\n\n\n\n\nAlguna dependencia no puede ser instalada y por ende falla la instalaci√≥n del paquete objetivo. Esto puede deberse a un problema de compatibilidad entre versiones de las dependencias o de alg√∫n conflicto entre la dependencia necesaria y otra que exista (o falte) en nuestro Sistema Operativo. Muchas veces este problema se debe a que faltan los compiladores (gcc, gfortran, g++, etc) necesarios para compilar el nuevo paquete. Resolver estos conflictos puede requerir un poco de tiempo, en tanto necesitamos identificar cu√°l es la librer√≠a que esta generando el conflicto, pero suelen resolverse simplemente luego de haber instalado la dependencia correcta en nuestro Sistema Operativo.\n\n\n\nCargando paquetes\nPor defecto, cuando abrimos una nueva sesi√≥n de R o apenas luego de que instalamos un nuevo paquete, estos no se encuentran disponibles en la memoria de trabajo. Para que un paquete particular (y todas las funciones que este contiene), se carguen en la memoria de trabajo, debemos llamarlo usando la funci√≥n library(). As√≠ mismo, si lo deseamos podemos ‚Äúdescargar‚Äù un paquete a fin de liberar memoria, utilizando la funci√≥n detach().\n\n# Carga de paquetes\nlibrary(\"remotes\")\n# Descarga de paquetes\ndetach(\"package:remotes\", unload = TRUE)\n\nTodo esto en RStudio tambi√©n puede ser realizado simplemente tildando o destildando el paquete correspondiente en la lista de paquetes.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-6",
    "href": "dia1/1.2_UsandoR.html#ejercicio-6",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\nInstale con el medio que le sea conveniente el paquete remotes, tal como se muestra en la imagen previa. Luego use la funci√≥n library() para cargarlo. Utilizando las ayudas internas de R responda: ¬øpara qu√© sirve este paquete?\n\n\nLlamando funciones de paquetes espec√≠ficos\nEn ocasiones, algunas funciones puede tener igual nombre en diferentes paquetes. Por defecto, cuando llamamos a una funci√≥n R intentar√° utilizar la funci√≥n del paquete que m√°s recientemente se haya cargado. Si deseamos referirnos a una funci√≥n de un paquete espec√≠fico podemos hacerlo utilizando la expresi√≥n paquete::funcion(). Por ejemplo:\n\ncar::Anova(lm(hp ~ as.factor(cyl), data = mtcars))\n\nAnova Table (Type II tests)\n\nResponse: hp\n               Sum Sq Df F value    Pr(&gt;F)    \nas.factor(cyl) 104031  2  36.177 1.319e-08 ***\nResiduals       41696 29                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nboxplot(hp ~ cyl, data = mtcars, main = \"Relaci√≥n entre caballos de fuerza (hp) y n¬∫ de cilindros (cyl)\")\n\n\n\n\n\n\n\n\n\n\nInstalaci√≥n desde otros repositorios\nAs√≠ como instalamos paquetes desde CRAN, tambi√©n podemos instalar paquetes directamente desde los repositorios de c√≥digo en los que se encuentran. Existen m√∫ltiples paquetes que permiten interactuar con diferentes repositorios, uno de ellos es el paquete remotes que instalamos en el ejercicio previo. Si por ejemplo queremos instalar el paquete multilandr que se encuentra en este repositorio, podemos hacer:\n\n# URL al repositorio: https://github.com/phuais/multilandr\ninstall_github(repo = \"phuais/multilandr\")\nlibrary(multilandr)",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia1/1.2_UsandoR.html#ejercicio-final",
    "href": "dia1/1.2_UsandoR.html#ejercicio-final",
    "title": "Primeros pasos con R y RStudio",
    "section": "Ejercicio Final",
    "text": "Ejercicio Final\nInstale el paquete ggplot2. Una vez instalado, c√°rguelo y realice alg√∫n gr√°fico de los ejemplos disponibles en su vignette. Finalmente, guarde el gr√°fico en el directorio de trabajo.",
    "crumbs": [
      "Inicio",
      "Unidad 1",
      "Primeros pasos con R y RStudio"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html",
    "href": "dia2/4.1_Tablas.html",
    "title": "Tablas",
    "section": "",
    "text": "La tabla ser√° posiblemente el objeto de R m√°s utilizado en el contexto de nuestro trabajo cient√≠fico. Consiste en una estructura de datos que organiza la informaci√≥n en filas y columnas. Desde un punto de vista program√°tico es √∫til considerar a las tablas como una colecci√≥n de vectores. Consideradas de esta manera, veremos que la manipulaci√≥n de las filas y columnas de una tabla es an√°loga a la manipulaci√≥n de vectores individuales. En una tabla, cada columna es un vector, pudiendo haber vectores de distintos tipos en una misma tabla (por ejemplo, vectores num√©ricos y de texto).\nPara crear una tabla desde cero, en R utilizamos la clase data.frame, y una funci√≥n con el mismo nombre para generarla:\n\n\n\n\n\n\n\ndf &lt;- data.frame(Especie = c(\"Algarrobo\", \"Piquillin\", \"Molle\"),\n                 Individuos = c(15, 17, 9))\n\nAqu√≠, generamos un objeto de tipo data.frame, definiendo el nombre de cada columna e igualando cada columna a un contenido en forma de vector. Existen algunas buenas pr√°cticas a la hora de definir los nombres de las columnas, tanto si la generamos en R o con alg√∫n software externo (Excel, Calc, Google Sheets, etc.), que nos ahorrar√°n dolores de cabeza en el futuro:\n\nLos nombres de las columnas no pueden comenzar con un n√∫mero.\nUtilizar caracteres alfanum√©ricos simples. Evitar la √± u otras letras espec√≠ficas de otros idiomas.\nEvitar s√≠mbolos extra√±os reservados para el uso del lenguaje, tales como: !?¬ø$%&()@*+-&gt;&lt;{}\nEvitar el uso de tildes, comas y puntos y coma.\nEvitar el uso de espacios, y reemplazarlos por punto, gui√≥n medio o gui√≥n bajo.\n\nAl crear o cargar una tabla, veremos la tabla en el panel de entorno. Desplegando la flechita azul podemos obtener informaci√≥n sobre las columnas de la tabla. Adem√°s, haciendo click sobre el nombre del objeto, podemos visualizar la tabla entera en otra pesta√±a.\nNormalmente, las tablas se generan fuera del entorno R para ser luego importadas a R. La creaci√≥n de tablas desde cero adquiere mayor relevancia para tareas mas posteriores del flujo de an√°lisis, como veremos m√°s adelante.\nAntes que nada, descargue el archivo zip con los datos necesarios para realizar el pr√°ctico, y extraiga los archivos dentro de una carpeta llamada ‚Äúdata‚Äù en el directorio ‚Äúdia2‚Äù del proyecto del curso.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#creaci√≥n-de-tablas-desde-cero",
    "href": "dia2/4.1_Tablas.html#creaci√≥n-de-tablas-desde-cero",
    "title": "Tablas",
    "section": "",
    "text": "La tabla ser√° posiblemente el objeto de R m√°s utilizado en el contexto de nuestro trabajo cient√≠fico. Consiste en una estructura de datos que organiza la informaci√≥n en filas y columnas. Desde un punto de vista program√°tico es √∫til considerar a las tablas como una colecci√≥n de vectores. Consideradas de esta manera, veremos que la manipulaci√≥n de las filas y columnas de una tabla es an√°loga a la manipulaci√≥n de vectores individuales. En una tabla, cada columna es un vector, pudiendo haber vectores de distintos tipos en una misma tabla (por ejemplo, vectores num√©ricos y de texto).\nPara crear una tabla desde cero, en R utilizamos la clase data.frame, y una funci√≥n con el mismo nombre para generarla:\n\n\n\n\n\n\n\ndf &lt;- data.frame(Especie = c(\"Algarrobo\", \"Piquillin\", \"Molle\"),\n                 Individuos = c(15, 17, 9))\n\nAqu√≠, generamos un objeto de tipo data.frame, definiendo el nombre de cada columna e igualando cada columna a un contenido en forma de vector. Existen algunas buenas pr√°cticas a la hora de definir los nombres de las columnas, tanto si la generamos en R o con alg√∫n software externo (Excel, Calc, Google Sheets, etc.), que nos ahorrar√°n dolores de cabeza en el futuro:\n\nLos nombres de las columnas no pueden comenzar con un n√∫mero.\nUtilizar caracteres alfanum√©ricos simples. Evitar la √± u otras letras espec√≠ficas de otros idiomas.\nEvitar s√≠mbolos extra√±os reservados para el uso del lenguaje, tales como: !?¬ø$%&()@*+-&gt;&lt;{}\nEvitar el uso de tildes, comas y puntos y coma.\nEvitar el uso de espacios, y reemplazarlos por punto, gui√≥n medio o gui√≥n bajo.\n\nAl crear o cargar una tabla, veremos la tabla en el panel de entorno. Desplegando la flechita azul podemos obtener informaci√≥n sobre las columnas de la tabla. Adem√°s, haciendo click sobre el nombre del objeto, podemos visualizar la tabla entera en otra pesta√±a.\nNormalmente, las tablas se generan fuera del entorno R para ser luego importadas a R. La creaci√≥n de tablas desde cero adquiere mayor relevancia para tareas mas posteriores del flujo de an√°lisis, como veremos m√°s adelante.\nAntes que nada, descargue el archivo zip con los datos necesarios para realizar el pr√°ctico, y extraiga los archivos dentro de una carpeta llamada ‚Äúdata‚Äù en el directorio ‚Äúdia2‚Äù del proyecto del curso.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#importaci√≥n-y-exploraci√≥n-de-tablas",
    "href": "dia2/4.1_Tablas.html#importaci√≥n-y-exploraci√≥n-de-tablas",
    "title": "Tablas",
    "section": "Importaci√≥n y exploraci√≥n de tablas",
    "text": "Importaci√≥n y exploraci√≥n de tablas\nExisten muchas formas de importar tablas al ambiente de R. Quiz√°s la forma m√°s f√°cil es hacerlo desde la interfaz gr√°fica de RStudio: en el panel de entorno, clickeando en el √≠cono de importaci√≥n.\nPara hacerlo desde la consola, read.table() es la funci√≥n gen√©rica, indicando la direcci√≥n y nombre del archivo a importar:\n\niris &lt;- read.table(file = \"data/iris.csv\")\n\nEn realidad, el dataset iris viene instalado por defecto con R, pero para ejemplificar lo hacemos visible en el panel de entorno mediante su importaci√≥n. Esta tabla contiene el valor de distintas variables para 50 flores de 3 especies del g√©nero Iris.\nOtras funciones similares son read.csv() y read.csv2(), cuyo funcionamiento es id√©ntico a read.table() pero sus argumentos poseen otras especificaciones por defecto.\nExisten algunas funciones √∫tiles para obtener informaci√≥n sobre su contenido o estructura. Simplemente llamando a la tabla por su nombre en la consola, R imprime todo el contenido de la tabla. Generalmente no es √∫til ver una tabla de esta forma, sobre todo si tiene muchas filas y columnas. Podemos visualizar las primeras filas con la funci√≥n head():\n\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n\nLa cual imprime las primeras 6 filas de la tabla. Podemos cambiar este n√∫mero con el segundo argumento de la funci√≥n (n):\n\nhead(iris, n = 10)\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1           5.1         3.5          1.4         0.2  setosa\n2           4.9         3.0          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n4           4.6         3.1          1.5         0.2  setosa\n5           5.0         3.6          1.4         0.2  setosa\n6           5.4         3.9          1.7         0.4  setosa\n7           4.6         3.4          1.4         0.3  setosa\n8           5.0         3.4          1.5         0.2  setosa\n9           4.4         2.9          1.4         0.2  setosa\n10          4.9         3.1          1.5         0.1  setosa\n\n\nLa funci√≥n tail() imprime las √∫ltimas filas de la tabla.\n\ntail(iris)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n145          6.7         3.3          5.7         2.5 virginica\n146          6.7         3.0          5.2         2.3 virginica\n147          6.3         2.5          5.0         1.9 virginica\n148          6.5         3.0          5.2         2.0 virginica\n149          6.2         3.4          5.4         2.3 virginica\n150          5.9         3.0          5.1         1.8 virginica\n\n\nLa funci√≥n str() devuelve informaci√≥n b√°sica sobre las columnas, similar a lo que se detalla en el panel de entorno.\n\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : chr  \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n\n\nLa funci√≥n dim() imprime las dimensiones de la tabla (n√∫mero de filas y de columnas, respectivamente).\n\ndim(iris)\n\n[1] 150   5\n\n\nLa funciones nrow() y ncol() devuelven dichos valores individualmente.\nLa funci√≥n colnames() devuelve los nombres de las columnas en un vector de texto:\n\ncolnames(iris)\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n\nLa funci√≥n rownames() funciona de manera id√©ntica, pero para las filas.\nAl importar un dataset, una buena pr√°ctica es realizar una exploraci√≥n inicial de la estructura de la tabla, especialmente sus columnas y nombres. La importaci√≥n incorrecta de datasets es una fuente de error muy frecuente.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#manipulaci√≥n-de-tablas",
    "href": "dia2/4.1_Tablas.html#manipulaci√≥n-de-tablas",
    "title": "Tablas",
    "section": "Manipulaci√≥n de tablas",
    "text": "Manipulaci√≥n de tablas\nUna tarea usual consiste en, una vez cargada una tabla, realizar modificaciones a la misma. Esto incluye, por ejemplo, obtener una nueva tabla de acuerdo a ciertas condiciones, eliminar ciertas filas o agregar nuevas columnas.\n\nIndexaci√≥n y filtrado\nLos corchetes son muy vers√°tiles para manipular y extraer datos de un data.frame. La sintaxis general es data[filas, columnas], siendo posible indicar √≠ndices, expresiones l√≥gicas o nombres de columnas para obtener un subconjunto de datos (i.e.¬†un subset).\n\niris_sub &lt;- iris[1:5, ]\n\nAqu√≠, generamos un nuevo dataset con s√≥lo las 5 primeras filas de la tabla iris. Notar que al mismo tiempo que se realiza el filtrado, lo asigno a un nuevo objeto. Si la asignaci√≥n no se realiza, el objeto no queda guardado en el entorno, pero es √∫til si queremos probar r√°pidamente alguna l√≠nea de c√≥digo, sin necesidad de generar un nuevo objeto.\nAhora, generamos un nuevo dataset que contiene s√≥lo las columnas \"Species\" y \"Sepal.Length\".\n\niris_sub2 &lt;- iris[, c(\"Species\", \"Sepal.Length\")]\nhead(iris_sub2)\n\n  Species Sepal.Length\n1  setosa          5.1\n2  setosa          4.9\n3  setosa          4.7\n4  setosa          4.6\n5  setosa          5.0\n6  setosa          5.4\n\n\nNotar que la nueva tabla mantiene la identidad pero tambi√©n el orden de las columnas indicadas en la sintaxis. Por lo tanto, esta sintaxis tambi√©n puede utilizarse para cambiar el orden de las columnas, pudiendo indicar el nombre (como en el ejemplo) o los √≠ndices (para este ejemplo ser√≠a c(5, 1)).\nLa funci√≥n order() permite ordenar una tabla de acuerdo a los valores de una columna o m√°s columnas:\n\niris &lt;- iris[order(iris$Sepal.Length), ]\nhead(iris, 10)\n\n   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n14          4.3         3.0          1.1         0.1  setosa\n9           4.4         2.9          1.4         0.2  setosa\n39          4.4         3.0          1.3         0.2  setosa\n43          4.4         3.2          1.3         0.2  setosa\n42          4.5         2.3          1.3         0.3  setosa\n4           4.6         3.1          1.5         0.2  setosa\n7           4.6         3.4          1.4         0.3  setosa\n23          4.6         3.6          1.0         0.2  setosa\n48          4.6         3.2          1.4         0.2  setosa\n3           4.7         3.2          1.3         0.2  setosa\n\n\nPara seleccionar una columna de una table utilizamos la sintaxis tabla$columna.\nEn esto contexto, la expresi√≥n order(iris$Sepal.Length) genera nuevos √≠ndices para cada fila, indicando que nueva posici√≥n deber√≠an ocupar para que la tabla quede ordenada. Por defecto, order() ordena de manera creciente. Indicando decreasing = TRUE se ordena la tabla de manera decreciente.\nEs posible indicar una ordenaci√≥n por m√°s de una columna:\n\niris &lt;- iris[order(iris$Species, iris$Sepal.Length, decreasing = TRUE), ]\nhead(iris, 10)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n132          7.9         3.8          6.4         2.0 virginica\n118          7.7         3.8          6.7         2.2 virginica\n119          7.7         2.6          6.9         2.3 virginica\n123          7.7         2.8          6.7         2.0 virginica\n136          7.7         3.0          6.1         2.3 virginica\n106          7.6         3.0          6.6         2.1 virginica\n131          7.4         2.8          6.1         1.9 virginica\n108          7.3         2.9          6.3         1.8 virginica\n110          7.2         3.6          6.1         2.5 virginica\n126          7.2         3.2          6.0         1.8 virginica\n\n\nEs posible obtener subconjuntos de datos que cumplan con ciertas condiciones. Las condiciones, en general, ser√°n sobre los datos contenidos en las filas.\n\niris_sub3 &lt;- iris[iris$Sepal.Length &gt; 5, ]\nhead(iris_sub3)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n132          7.9         3.8          6.4         2.0 virginica\n118          7.7         3.8          6.7         2.2 virginica\n119          7.7         2.6          6.9         2.3 virginica\n123          7.7         2.8          6.7         2.0 virginica\n136          7.7         3.0          6.1         2.3 virginica\n106          7.6         3.0          6.6         2.1 virginica\n\n\nAqu√≠ estamos seleccionando aquellas filas para los cuales Sepal.Length es mayor a 5. ¬øPor qu√© esta sint√°xis tan rara? En realidad, lo que estamos haciendo es indicar una expresi√≥n l√≥gica para las filas, especificando el nombre de la tabla y la columna (es un vector!) mediante el operador $:\n\niris$Sepal.Length &gt; 5\n\n  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [13]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [25]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [37]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [49]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [61]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [73]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [85]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n [97]  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[109]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n[121]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE\n\n\nEs posible, entonces, indicar cualquier expresi√≥n l√≥gica referida a una o m√°s columnas de la tabla. El mismo filtrado puede realizarse mediante la funci√≥n subset(), siendo este m√©todo un poco menos ‚Äúengorroso‚Äù:\n\niris_sub3 &lt;- subset(iris, Sepal.Length &gt; 5)\nhead(iris_sub3)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n132          7.9         3.8          6.4         2.0 virginica\n118          7.7         3.8          6.7         2.2 virginica\n119          7.7         2.6          6.9         2.3 virginica\n123          7.7         2.8          6.7         2.0 virginica\n136          7.7         3.0          6.1         2.3 virginica\n106          7.6         3.0          6.6         2.1 virginica\n\n\nEl primer argumento indica el conjunto de datos a utilizar, y el segundo argumento la expresi√≥n a aplicar para filtrar dicho conjunto de datos. Notar que no es necesario aclarar la sintaxis iris$Sepal.Length. Esto es hace m√°s f√°cil la escritura cuando haya que indicar m√∫ltiples condiciones l√≥gicas.\nEl argumento select permite adem√°s seleccionar una o m√°s columnas a dejar luego del filtro:\n\niris_sub4 &lt;- subset(iris, Sepal.Length &gt; 5, select = c(\"Species\", \"Sepal.Width\"))\nhead(iris_sub4)\n\n      Species Sepal.Width\n132 virginica         3.8\n118 virginica         3.8\n119 virginica         2.6\n123 virginica         2.8\n136 virginica         3.0\n106 virginica         3.0\n\n\n¬øC√≥mo modificamos el contenido de una tabla? Para ello, debemos primero seleccionar qu√© campos queremos modificar, y luego asignarle el nuevo contenido. Por ejemplo, si quisi√©ramos cambiar el nombre de una de las especies por un sin√≥nimo:\n\niris$Species[iris$Species == \"setosa\"] &lt;- \"arctica\"\n\nAnalicemos con cuidado esta expresi√≥n. La primera parte, iris$Species, indica la columna Species. Es decir, selecciono dicho el vector-columna. Entre corchetes indico una expresi√≥n l√≥gica para seleccionar todos aquellos elementos del vector en donde dicha expresi√≥n sea verdadera. En este caso, donde el vector iris$Species sea igual (==) a \"setosa\". Finalmente, le asignamos el valor \"arctica\". Dado que queremos un √∫nico valor para todos los campos, no es necesario asignar un vector con elementos repetidos para \"arctica\".\nPara pensar: ¬øPor qu√© no hay coma en la sintaxis de filtrado anterior?\nPodemos corroborar que se ha modificado la tabla con la funci√≥n unique(), que devuelve los valores √∫nicos para un objeto dado:\n\nunique(iris$Species)\n\n[1] \"virginica\"  \"versicolor\" \"arctica\"",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-1",
    "href": "dia2/4.1_Tablas.html#ejercicio-1",
    "title": "Tablas",
    "section": "Ejercicio 1",
    "text": "Ejercicio 1\nGenere nuevas tablas a partir de la tabla iris (utilizar nombres nuevos para cada tabla), para:\n\nLa especie ‚Äúsetosa‚Äù, y las columnas ‚ÄúSpecies‚Äù y ‚ÄúPetal.Width‚Äù.\nLas especies ‚Äúsetosa‚Äù y ‚Äúversicolor‚Äù. Deber√° utilizar el operador %in% en vez del == (record√° de qu√© estamos hablando en Vectores).\nFlores en donde ‚ÄúPetal.Length‚Äù es mayor o igual a 4.\nFlores en donde ‚ÄúSepal.Width‚Äù es mayor a 3 o ‚ÄúSepal.Length‚Äù &lt; 4.\n\n\nCreaci√≥n de nuevas columnas\nPara agregar una nueva columna utilizamos la sintaxis data$nueva_columna. La columna debe asociarse a un contenido, las filas, mediante el operador de asignaci√≥n. Lo que hacemos es agregar un nuevo vector-columna a la colecci√≥n de vectores-columnas que es el data.frame:\n\niris$Seed.set &lt;- NA\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n\n\nVemos que se ha generado una nueva columna con campos igual a NA (no dato). Crear una columna con datos vac√≠os de esta manera puede llegar a ser √∫til para luego ir rellenando cada fila de acuerdo al contenido de otras columnas. Spoiler: el control de flujo podr√≠a ser √∫til para esta tarea.\nLa siguiente l√≠nea genera una nueva columna a partir del cociente de otras dos:\n\niris$Sepal.Petal.ratio &lt;- iris$Sepal.Length/iris$Petal.Length\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio\n1          3.642857\n2          3.500000\n3          3.615385\n4          3.066667\n5          3.571429\n6          3.176471\n\n\nLa funci√≥n ifelse() es √∫til para generar nuevas columnas basadas en la informaci√≥n de columnas ya existentes. Funciona de manera similar a un ‚ÄúSI()‚Äù de Excel/Calc. El primer argumento establece la condici√≥n, el segundo el valor devuelto si la condici√≥n es verdadera, y el tercero si es falsa:\n\niris$Sepal.width.cat &lt;- ifelse(iris$Sepal.Width &lt; 3, \"Corto\", \"Largo\")\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio Sepal.width.cat\n1          3.642857           Largo\n2          3.500000           Largo\n3          3.615385           Largo\n4          3.066667           Largo\n5          3.571429           Largo\n6          3.176471           Largo\n\n\nEs posible anidar la funci√≥n ifelse() para obtener m√°s categor√≠as:\n\niris$Sepal.width.cat2 &lt;- ifelse(iris$Sepal.Width &lt; 2.8, \"Corto\",\n                               ifelse(iris$Sepal.Width &gt;= 2.8 & iris$Sepal.Width &lt; 3.3, \"Mediano\", \"Largo\"))\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio Sepal.width.cat Sepal.width.cat2\n1          3.642857           Largo            Largo\n2          3.500000           Largo          Mediano\n3          3.615385           Largo          Mediano\n4          3.066667           Largo          Mediano\n5          3.571429           Largo            Largo\n6          3.176471           Largo            Largo\n\n\nTraducci√≥n en palabras: Si el largo del s√©palo es menor a 2.8, clasificarlo como ‚ÄúCorto‚Äù. En caso contrario, si es mayor o igual a 2.8 Y menor a 3.3, clasificarlo como ‚ÄúMediano‚Äù; si no es as√≠, clasificarlo como ‚ÄúLargo‚Äù.\nCon la funci√≥n factor(), es posible aisgnarle a un vector-columna la clase de factor:\n\niris$Sepal.width.cat2 &lt;- factor(iris$Sepal.width.cat2)\niris$Sepal.width.cat2\n\n  [1] Largo   Mediano Mediano Mediano Largo   Largo   Largo   Largo   Mediano\n [10] Mediano Largo   Largo   Mediano Mediano Largo   Largo   Largo   Largo  \n [19] Largo   Largo   Largo   Largo   Largo   Largo   Largo   Mediano Largo  \n [28] Largo   Largo   Mediano Mediano Largo   Largo   Largo   Mediano Mediano\n [37] Largo   Largo   Mediano Largo   Largo   Corto   Mediano Largo   Largo  \n [46] Mediano Largo   Mediano Largo   Largo   Mediano Mediano Mediano Corto  \n [55] Mediano Mediano Largo   Corto   Mediano Corto   Corto   Mediano Corto  \n [64] Mediano Mediano Mediano Mediano Corto   Corto   Corto   Mediano Mediano\n [73] Corto   Mediano Mediano Mediano Mediano Mediano Mediano Corto   Corto  \n [82] Corto   Corto   Corto   Mediano Largo   Mediano Corto   Mediano Corto  \n [91] Corto   Mediano Corto   Corto   Corto   Mediano Mediano Mediano Corto  \n[100] Mediano Largo   Corto   Mediano Mediano Mediano Mediano Corto   Mediano\n[109] Corto   Largo   Mediano Corto   Mediano Corto   Mediano Mediano Mediano\n[118] Largo   Corto   Corto   Mediano Mediano Mediano Corto   Largo   Mediano\n[127] Mediano Mediano Mediano Mediano Mediano Largo   Mediano Mediano Corto  \n[136] Mediano Largo   Mediano Mediano Mediano Mediano Mediano Corto   Mediano\n[145] Largo   Mediano Corto   Mediano Largo   Mediano\nLevels: Corto Largo Mediano\n\n\nRecordemos, como vimos en la clase de Vectores, que al indicar un factor es posible tambi√©n indicar el orden de sus niveles. Esto tambi√©n aplica en el contexto de manipulaci√≥n de tablas.\nNo obstante, a la hora de generar vectores (aqu√≠ asociados a una tabla), la funci√≥n cut() es m√°s adecuada. Esta funci√≥n divide el rango de valores de un vector en intervalos espec√≠ficos, y define nombres para cada intervalo. Por ejemplo:\n\niris$Sepal.width.cat4 &lt;- cut(x = iris$Sepal.Width, breaks = 3, labels = c(\"Corto\", \"Mediano\", \"Largo\"))\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species Seed.set\n1          5.1         3.5          1.4         0.2  setosa       NA\n2          4.9         3.0          1.4         0.2  setosa       NA\n3          4.7         3.2          1.3         0.2  setosa       NA\n4          4.6         3.1          1.5         0.2  setosa       NA\n5          5.0         3.6          1.4         0.2  setosa       NA\n6          5.4         3.9          1.7         0.4  setosa       NA\n  Sepal.Petal.ratio Sepal.width.cat Sepal.width.cat2 Sepal.width.cat4\n1          3.642857           Largo            Largo          Mediano\n2          3.500000           Largo          Mediano          Mediano\n3          3.615385           Largo          Mediano          Mediano\n4          3.066667           Largo          Mediano          Mediano\n5          3.571429           Largo            Largo          Mediano\n6          3.176471           Largo            Largo            Largo\n\n\nAqu√≠, creamos una nueva columna, construida a partir de los valores de la columna Sepal.Width. Mediante breaks = 3, indicamos que el rango de valores de Sepal.Width se divida en 3 partes iguales, y definimos los nombres para cada intervalo en el argumento labels. El argumento breaks tambi√©n admite un vector num√©rico con los valores que dividir√°n los intervalos generados.\nLa funci√≥n cut() devuelve un factor con niveles, adecuado en contextos de an√°lisis estad√≠sticos y graficaci√≥n:\n\nclass(iris$Sepal.width.cat4)\n\n[1] \"factor\"",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-2",
    "href": "dia2/4.1_Tablas.html#ejercicio-2",
    "title": "Tablas",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\nGenere una nueva columna para la tabla iris llamada ‚ÄúFlower.color‚Äù. Para las especie Iris setosa y Iris versicolor, asignarle ‚ÄúPurple‚Äù. Para la especie Iris virginica asignarle ‚ÄúBlue‚Äù.\n\n\nUni√≥n de tablas\nLas funciones rbind() y cbind() permiten a√±adir filas (‚Äúr‚Äù de ‚Äúrow‚Äù) y columnas (‚Äúc‚Äù de ‚Äúcolumn‚Äù) a un data.frame, respectivamente.\nA modo de ejemplo, importaremos un data.frame conteniendo las medidas de variables florales (inventadas para el ejemplo) para la especie Iris florentina. Asimismo, cargamos nuevamente la tavla iris con la estructura y datos originales:\n\n# Cargamos nuevamente la tabla con la estructura y datos originales\niris &lt;- read.table(\"data/iris.csv\")\n# Cargamos la nueva tabla\niris_fl &lt;- read.table(\"data/iris_florentina.csv\")\nhead(iris_fl)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n1          6.9         2.5          3.8         1.6 florentina\n2          5.4         3.1          3.5         2.0 florentina\n3          7.8         3.0          5.8         0.5 florentina\n4          6.2         2.0          3.5         0.3 florentina\n5          7.2         3.2          5.2         2.2 florentina\n6          5.7         1.9          5.4         0.6 florentina\n\n\nPodemos ver que tiene la misma cantidad de columnas y los mismos nombres que la tabla original con la que venimos trabajando. Lo l√≥gico ser√≠a unir estas dos tablas mediante rbind():\n\niris_new &lt;- rbind(iris, iris_fl)\n\nLa exploraci√≥n de las √∫ltimas filas de la nueva tabla comprueban que hemos hecho la uni√≥n correctamente:\n\ntail(iris_new)\n\n    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n451          5.1         3.2          4.0         0.6 florentina\n461          6.7         4.0          5.0         0.7 florentina\n471          5.3         3.9          4.2         0.6 florentina\n481          7.1         2.5          4.8         1.9 florentina\n491          4.7         2.1          3.5         1.0 florentina\n501          4.7         2.0          5.0         0.9 florentina\n\n\nAl utilizar rbind(), debemos asegurarnos de que la cantidad de columnas y sus nombres sean id√©nticos. De lo contrario, R devuelve un error.\nDe manera similar, la funci√≥n cbind() une tablas a lo largo de sus columnas, y su sintaxis tiene la forma de cbind(tabla1, tabla2). L√≥gicamente, el n√∫mero de filas de ambas tablas debe ser el mismo, de lo contraria obtendremos una advertencia o un error.\nUsualmente, la informaci√≥n est√° repartida en m√°s de una tabla. ¬øC√≥mo generamos una nueva tabla que re√∫na toda la informaci√≥n junta? Para ello utilizamos la funci√≥n merge() (fusionar/combinar). A modo de ejemplo, cargamos una nueva tabla con los nombres comunes de las especies de Iris con las que venimos trabajando:\n\niris_names &lt;- read.table(\"data/iris_common_names.csv\")\niris_names\n\n     Species           Common.name\n1     setosa Iris de punta erizada\n2 versicolor Iris azul de arlequ√≠n\n3  virginica     Iris azul del sur\n4 florentina           Iris blanca\n\n\nVemos que la tabla tiene dos columnas, una para la especie y otra para el nombre com√∫n. La idea ser√≠a agregar a la tabla generada anteriormente iris_new una nueva columna con los nombres comunes, repetidos para cada fila correspondiente. Hacerlo manualmente no es viable, siendo la funci√≥n merge() la adecuada para esta tarea:\n\niris_new2 &lt;- merge(iris_new, iris_names, by = \"Species\")\nhead(iris_new2)\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width Common.name\n1 florentina          6.9         2.5          3.8         1.6 Iris blanca\n2 florentina          5.4         3.1          3.5         2.0 Iris blanca\n3 florentina          7.8         3.0          5.8         0.5 Iris blanca\n4 florentina          6.2         2.0          3.5         0.3 Iris blanca\n5 florentina          7.2         3.2          5.2         2.2 Iris blanca\n6 florentina          5.7         1.9          5.4         0.6 Iris blanca\n\n\nLos primeros dos argumentos indican las tablas a combinar, y el argumento by la columna com√∫n a ambas tablas (pueden indicarse m√°s columnas con la sintaxis c(\"columna1\", \"columna2\")). La funci√≥n busca coincidencias de campos en la columna (o columnas) en ambas tablas, y rellena correspondientemente.\nLa funci√≥n merge() es una funci√≥n muy √∫til para combinar tablas, pero debe utilizarse con cuidado, pensando qu√© tabla final es la que nos proponemos generar. Por ejemplo, obtendremos resultados distintos si los campos de la columna especificada en by (en el ejemplo, las especies) difieren de alguna manera, o si hay campos faltantes. Esto es particularmente importante para datasets muy grandes en donde no podemos corroborar que lo que se ha fusionado es lo que realmente nos propon√≠amos hacer. Es conveniente explorar las distintas opciones en ?merge.\n\n\nC√°lculo de estad√≠sticas sobre tablas\nLa funci√≥n aggregate() es √∫til para generar tablas con estad√≠sticas de resumen de acuerdo a los niveles de un determinado factor. Por ejemplo, para calcular el valor medio de la longitud del s√©palo para cada especie utilizamos la siguiente sintaxis:\n\niris_mean &lt;- aggregate(Sepal.Width ~ Species, data = iris, FUN = mean)\niris_mean\n\n     Species Sepal.Width\n1     setosa       3.428\n2 versicolor       2.770\n3  virginica       2.974\n\n\nEl primer argumento indica una f√≥rmula con la sintaxis variable ~ factor, el segundo el data.frame de referencia y el tercero la funci√≥n a aplicar. Esta funci√≥n debe existir en el entorno, tanto por defecto (las cuales no aparecen visibles, como mean() o sd()) o programadas por el usuario.\nNo es √∫til que la columna de esta nueva tabla se siga llamando Sepal.Width. Podemos cambiarla asignando un nuevo nombre al vector generado con la funci√≥n colnames():\n\ncolnames(iris_mean) &lt;- c(\"Species\", \"Sepal.Width.mean\")\niris_mean\n\n     Species Sepal.Width.mean\n1     setosa            3.428\n2 versicolor            2.770\n3  virginica            2.974\n\n\nPara pensar: Aqu√≠ deb√≠ aclarar ‚ÄúSpecies‚Äù para la primera columna, que no cambia de nombre. ¬øCu√°l podr√≠a ser la l√≠nea de c√≥digo para cambiar √∫nicamente la segunda columna?\nPara calcular la media de varias variables en una misma l√≠nea de c√≥digo, utilizamos la funci√≥n cbind():\n\niris_mean &lt;- aggregate(cbind(Sepal.Length, Sepal.Width) ~ Species, data = iris, FUN = mean)\niris_mean\n\n     Species Sepal.Length Sepal.Width\n1     setosa        5.006       3.428\n2 versicolor        5.936       2.770\n3  virginica        6.588       2.974\n\n\nEl uso del punto . es √∫til para hacer el c√°lculo sobre todas las columnas del dataset, a excepci√≥n de la definida a la derecha de ~:\n\niris_mean &lt;- aggregate(. ~ Species, data = iris, FUN = mean)\niris_mean\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-3",
    "href": "dia2/4.1_Tablas.html#ejercicio-3",
    "title": "Tablas",
    "section": "Ejercicio 3",
    "text": "Ejercicio 3\nGenerar una tabla que contenga el c√°lculo de la media de ‚ÄúPetal.Length‚Äù para cada especie. Luego, generar otra tabla con la desviaci√≥n est√°ndar de ‚ÄúPetal.Length‚Äù para cada especie. En cada tabla, cambiar los nombres de las nuevas columnas a ‚ÄúPetal.Length.mean‚Äù y ‚ÄúPetal.Length.sd‚Äù. Finalmente, unir ambas tablas con cbind().",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#exportaci√≥n-de-tablas",
    "href": "dia2/4.1_Tablas.html#exportaci√≥n-de-tablas",
    "title": "Tablas",
    "section": "Exportaci√≥n de tablas",
    "text": "Exportaci√≥n de tablas\nLa exportaci√≥n de un data.frame se realiza con write.table:\n\nwrite.table(iris_mean, file = \"iris.mean.csv\", row.names = F)\n\nAn√°logamente a las funciones de importaci√≥n, tambi√©n disponemos de las funciones write.csv() y write.csv2.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#otras-estructuras-de-datos",
    "href": "dia2/4.1_Tablas.html#otras-estructuras-de-datos",
    "title": "Tablas",
    "section": "Otras estructuras de datos",
    "text": "Otras estructuras de datos\n\nMatrices\nLas matrices en R pertenecen a la clase matrix. Es una colecci√≥n de datos agrupados en filas y columnas y, si bien admiten objetos de distinto tipo, en general se utilizan para almacenar n√∫meros. La utilidad principal de una matriz, a diferencia de un data.frame, es que permite operaciones matem√°ticas propias. Por ello, es un objeto fundamental para el an√°lisis estad√≠stico en m√∫ltiples disciplinas.\nPara crear una matriz en R, utilizamos la funci√≥n matrix():\n\nmat &lt;- matrix(data = 1:25, ncol = 5, nrow = 5)\nmat\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\n\nEl primer argumento indica los elementos que contendr√° la matriz. En este caso, se utiliza la sucesi√≥n de n√∫meros enteros desde el 1 al 25. Los argumentos ncol y nrow indican el n√∫mero de columnas y filas correspondientes para generar la matriz. Un detalle importante es la forma en la que los elementos de la matriz se van rellenando. Por defecto, los datos se van agregando por columnas. En cambio, si se indica byrow = TRUE, los datos se agregan por fila:\n\nmat &lt;- matrix(data = 1:25, ncol = 5, nrow = 5, byrow = TRUE)\nmat\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n[4,]   16   17   18   19   20\n[5,]   21   22   23   24   25\n\n\nLa funci√≥n dim() nos indica el n√∫mero de filas y columnas de la matriz:\n\ndim(mat)\n\n[1] 5 5\n\n\nAl igual que para la clase data.frame, las funciones nrow() y ncol() indican el n√∫mero de filas y columnas de una matriz.\nLos corchetes son los operadores indicados para acceder a los elementos de una matriz, indicando los √≠ndices para las filas y las columnas separado por una coma:\n\nmat[2, 3]\n\n[1] 8\n\n\nLas matrices se asocian a numerosas funciones especiales para matrices, pero no es la idea de este curso indagar mucho en este tema. Podemos mencionar las funciones rowSums() y colSums(), que devuelven las sumas de las filas y las columnas respectivamente. An√°logamente, las funciones rowMeans() y colMeans() devuelven los valores medios.\n\n\nListas\nUna gran parte de diversos paquetes de R contienen funciones cuyas salidas son estructuras m√°s complejas que las aprendidas hasta ahora. Un tipo de estas estructuras es la lista; estos son objetos de clase list. Es una colecci√≥n de objetos de cualquier tipo. Por ejemplo:\n\niris_info &lt;- list(data = iris,\n                  mean_stats = iris_mean,\n                  year_of_creation = 2024)\n\nLa informaci√≥n guardada en una lista se accede mediante el operador $, si es que los elementos de la lista a acceder tienen asociado un nombre:\n\niris_info$mean_stats\n\n     Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n1     setosa        5.006       3.428        1.462       0.246\n2 versicolor        5.936       2.770        4.260       1.326\n3  virginica        6.588       2.974        5.552       2.026\n\n\nTambi√©n es posible acceder a la informaci√≥n de un elemento de una lista indicando el √≠ndice del elemento entre corchetes dobles:\n\niris_info[[3]]\n\n[1] 2024\n\n\nLa estructura y parte del contenido de una lista tambi√©n puede desplegarse en el panel de entorno.\nEs posible modificar el contenido de un elemento de la lista, incluso indicando un elemento de otra clase:\n\niris_info$year_of_creation &lt;- \"Dos mil veinticuatro\"\niris_info$year_of_creation\n\n[1] \"Dos mil veinticuatro\"\n\n\nPor ejemplo, la salida de la funci√≥n lm(), que confecciona una regresi√≥n lineal, es una lista:\n\n\n\n\n\n\n\nmod &lt;- lm(Sepal.Length ~ Petal.Length, data = iris)\nis.list(mod)\n\n[1] TRUE\n\n\nAqu√≠, en el primer argumento, indicamos para modelar la variable Sepal.Length en funci√≥n de la variable Petal.Length. El s√≠mbolo ~ (virgulilla) es el indicado para expresar la f√≥rmula. En el argumento data indicamos el data.frame de referencia. Por otro lado, la funci√≥n is.list() devuelve TRUE si el objeto indicado es de clase list.\nLa funci√≥n summary() devuelve informaci√≥n relevante sobre el modelo:\n\nmod_summ &lt;- summary(mod)\nmod_summ\n\n\nCall:\nlm(formula = Sepal.Length ~ Petal.Length, data = iris)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1.24675 -0.29657 -0.01515  0.27676  1.00269 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   4.30660    0.07839   54.94   &lt;2e-16 ***\nPetal.Length  0.40892    0.01889   21.65   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4071 on 148 degrees of freedom\nMultiple R-squared:   0.76, Adjusted R-squared:  0.7583 \nF-statistic: 468.6 on 1 and 148 DF,  p-value: &lt; 2.2e-16\n\n\nQue tambi√©n guarda la informaci√≥n en una lista:\n\nis.list(mod_summ)\n\n[1] TRUE\n\n\nEs posible acceder a los coeficientes del modelo, en forma de tabla, explorando la salida de summary():\n\nmod_summ$coefficients\n\n              Estimate Std. Error  t value      Pr(&gt;|t|)\n(Intercept)  4.3066034 0.07838896 54.93890 2.426713e-100\nPetal.Length 0.4089223 0.01889134 21.64602  1.038667e-47\n\n\n\nClases S4\nOtra salida menos com√∫n de algunos paquetes son las clases S4. En esencia, son muy similares a las listas en el sentido de que pueden almacenar cualquier tipo de objeto. Una de las diferencias radica en que el tipo de elemento a almacenar est√° predefinido, y no puede cambiarse.\nUn ejemplo es la salida de la funci√≥n raster() del paquete raster, la cual genera un objeto de tipo raster, muy utilizado en el contexto de Sistemas de Informaci√≥n Geogr√°fica. Por ahora, basta con saber que la informaci√≥n de estos objetos se acceden con el operador @, mediante la sintaxis objeto@elemento.\n\n\n\n\nEl paquete dplyr\nEl paquete dplyr ofrece numerosas herramientas R para manipular y transformar datos. Es parte del universo tidyverse, dise√±ado para facilitar el trabajo con datos tabulares de manera eficiente y legible. A diferencia del manejo b√°sico de tablas en R, dplyr introduce una sintaxis diferente a trav√©s del operador %&gt;%, que relaciona una expresi√≥n con otra como si fuera una oraci√≥n de texto:\ncargar tabla %&gt;% seleccionar columnas %&gt;% filtrar filas %&gt;% crear nueva columna\nPor ejemplo, dplyr ofrece funciones intuitivas para realizar operaciones comunes, como filtrar filas (filter()), seleccionar columnas (select()), reordenar datos (arrange()), crear nuevas variables (mutate()) y resumir informaci√≥n (summarize()).\nEl presente curso est√° orientado a entender los fundamentos b√°sicos del lenguaje R y no ahondaremos en el uso de este paquete. No obstante, creemos que es √∫til saber de su existencia y explorar sobre su uso en caso de necesidad.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  },
  {
    "objectID": "dia2/4.1_Tablas.html#ejercicio-final",
    "href": "dia2/4.1_Tablas.html#ejercicio-final",
    "title": "Tablas",
    "section": "Ejercicio final",
    "text": "Ejercicio final\n\nCargue la tabla del archivo ‚Äúanalisis_tierra.csv‚Äù, la cual muestra los resultados de un an√°lisis de muestras de tierra, detallando las concentraciones de N, C y Ca. Explore su estructura y contenido utilizando las funciones head(), tail(), str() y dim().\nExplore los nombres de las columnas. Corrija el error en la segunda columna, que deber√≠a llamarse ‚ÄúParcela‚Äù.\nHay valores negativos para la concentraci√≥n de Ca, lo cual no tiene sentido. Cambie estos valores por ceros.\nHay valores NA en la columna que indica la concentraci√≥n de N. Genere una nueva tabla, utilizando el mismo nombre que antes, que no contenga estas observaciones (filas). Puede utilizar la expresi√≥n is.na(), pero explore tambi√©n la ayuda de na.omit().\nCargue la tabla del archivo ‚Äúanalisis_tierra2.csv‚Äù, la cual muestra los resultados realizados por otra t√©cnica (Claudia). Incorpore estos nuevos datos a la tabla anterior. Es necesario corregir algunos errores antes de hacer esto . Entre ellos, los n√∫meros asignados a cada muestra deben cambiarse, para que estos no coincidan con los n√∫meros de muestra de la tabla anterior.\nOrdene la tabla seg√∫n la Parcela (orden alfab√©tico) y por valores crecientes en la cantidad de N, en ese orden!\nExprese a la columna ‚ÄúTecnico‚Äù como factor.\nGenere una tabla resumen con los valores medios de N, C y Ca por Parcela, y otra con los valores de desviaci√≥n est√°ndar de N, C y Ca por T√©cnico. Exporte dichas tablas resumen.",
    "crumbs": [
      "Inicio",
      "Unidad 2",
      "Tablas"
    ]
  }
]