Estructuras de control de flujo
================

## Condicionales y Bucles

Como hemos visto hasta ahora, cuando escribimos código y lo ejecutamos el mismo será interpretando línea a línea, hasta que se ejecuta la última línea y el programa termina. **Las estructuras de control de flujo permiten alterar este comportamiento para adecuarlo a nuestras necesidades**.

En general podemos definir dos grandes tipos de estructuras para el control de flujo. Por un lado, aquellas estructuras que **evaluan condiciones** y ejecutan un código subsiguiente en función de si el resultado de esa evaluación es verdadero o falso, a estas estrucuturas las llamamos *condicionales*. Por otro lado, tenemos estructuras que **repiten iterativamente** una porción de código mientras se cumpla alguna condición dada, a estas estructuras las denominamos *bucles*.

**Nota:** Antes de continuar es recomendable repasar los <ins>operadores</ins> aprendidos en el primer día de clases.

------------------------------------------------------------------------

### If … else

El constructo `if ... else` es una estructura de tipo condicional. En pocas palabras, `if` evaluará una condición dada y si la misma se cumple (ie.: el resultado es **TRUE**), se ejecutará el código correspondiente. Para defenir un bloque de código a ejecutarse si no se cumple la condición previamente establecida, utilizaremos `else`. Si además quisieramos definir múltiples condiciones, en caso de que la primera no se cumpla y que deriven en diferentes ejecuciones, deberemos utilizar `else if`.

``` r
if (TRUE) {
  print("Se ejecutará el código bajo 'if' ya que la condición resulta TRUE")
}
```

    ## [1] "Se ejecutará el código bajo 'if' ya que la condición resulta TRUE"

``` r
if (!TRUE) {
  print("Se ejecutará el código bajo 'if' ya que la condición resulta TRUE")
} else {
  print("Se ejecutará el código bajo 'else' dado que la condición resulta FALSE")
  }
```

    ## [1] "Se ejecutará el código bajo 'else' dado que la condición resulta FALSE"

#### *Múltiples condiciones*

En ocasiones necesitamos establecer múltiples condiciones. Ejecute el codigo siguiente varias veces, pero cambiando cada vez el valor de *a*.

``` r
a <- 25

if (a >= 40) {
  print("a es mayor o igual que 40")
} else if (a >= 30) {
  print("a es mayor o igual que 30")
}  else if (a >= 10) {
  print("a es mayor o igual que 10")
} else {
  print("a es menor a 10")
}
```

    ## [1] "a es mayor o igual que 10"

**Para pensar:** ¿Qué pasa cuando, por ejemplo, a = 35? ¿Cuántas evaluaciones independientes serían TRUE? ¿Qué porción de código se ejecuta y por qué?

#### *And / or*

Es posible agrupar diferentes evaluaciones utilizando los operadores **Y** (`&`) y **O** (`|`). Ejecute el siguiente código varias veces cambiando los valores de *a*, *b* y *c*.

``` r
a <- 35
b <- 12
c <- 65

if (a < 40 & b > 10 | c > 50) {
    print("'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50")
} else {
    print("No se cumple ninguna condición")
}
```

    ## [1] "'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50"

#### <ins>Ejercicio</ins>

Compare el código de la celda precedente con el de aquí abajo. ¿Qué diferencias nota? Ejecútelo y explique el resultado con el obtenido usando el código previo con los mismos valores para *a*, *b* y *c*.

``` r
a <- 52
b <- 8 
c <- 65

if (a < 40 & (b > 10 | c > 50)){
  print("'a' es menor a 40 y 'b' mayor a 10 ó 'c' es mayor a 50")
} else {
  print("No se cumple ninguna condición")
}
```

#### *If anidados*

Recién vimos como combinar varias evaluaciones en una misma expresión, pero frecuentemente lo que necesitaremos es realizar diferentes evaluaciones de forma secuencial y ejecutar código consecuentemente a los resultados obtenidos. Para ello podemos incoporar evaluaciones dentro de una evaluación previa, es decir, anidar las evaluaciones.

``` r
a <- 25

if (a > 10){
  print("a es mayor que 10")
  if (a > 20) {
    print("y también es mayor que 20")
    if (a > 30) {
      print("y también es mayor que 30")
    } else {
      print("pero no mayor que 30")
    }
  }
}
```

    ## [1] "a es mayor que 10"
    ## [1] "y también es mayor que 20"
    ## [1] "pero no mayor que 30"

**Para pensar:** ¿Qué sucede si ***a*** **\<= 10**? ¿Qué podemos aprender de esta situación? ¿Cómo podríamos salvar el inconveniente?

#### <ins>Ejercicio</ins>

Juan y María fueron a hacer compras, contruya con código que indique cuál de ambos gastó más dinero y de cuanto es la diferencia. El mismo código debe servir para evaluar los tres escenarios siguientes:

- Escenario Nº 1

compra_juan = 690 / compra_maria = 730

- Escenario Nº 2

compra_juan = 745 / compra_maria = 745

- Escenario Nº 3

compra_juan = 890 / compra_maria = 730

*Ayuda*: La salida esperada combina texto y variables, por ejemplo “María gasto *x* pesos más que Juan”. Para generar una salida de este tipo, podemos utilizar la funcion `paste` de la siguiente manera:

``` r
variable <- 25
print(paste("La variable vale", variable))
```

    ## [1] "La variable vale 25"

Si no usáramos `paste` obtendríamos un error:

``` r
print("La variable vale", variable)
```

    ## Error in print.default("La variable vale", variable): invalid printing digits 25

------------------------------------------------------------------------

### While …

El constructo `while` es una estructura de tipo bucle. En pocas palabras, evaluará una condición y ejecutará repetitivamente una porción de código mientras que la misma se cumpla (ie.: el resultado sea TRUE).

``` r
i <- 1
while (i < 4) {
  print(paste("Repetición nº:", i))
  i <- i + 1
}
```

    ## [1] "Repetición nº: 1"
    ## [1] "Repetición nº: 2"
    ## [1] "Repetición nº: 3"

**Atención!!!** Si en el bucle precendente omitimos incrementar el contador *i*, nuestro bucle se ejecutará indefinidamente.

#### *While en vectores u otros iterables*

Teniendo en cuenta lo que aprendimos sobre el acceso a elementos de un vector, podemos utilizar un bucle `while` para acceder a los mismos. No obstante, <ins>existen formas más eficientes de hacer esto que veremos posteriormente</ins>.

``` r
carreras <- c('Biología', 'Bioquímica', 'Medicina', 'Nutrición')
i <- 1
while (i <= length(carreras)) {
  print(carreras[i])
  i <- i + 1
}
```

    ## [1] "Biología"
    ## [1] "Bioquímica"
    ## [1] "Medicina"
    ## [1] "Nutrición"

#### *Rompiendo un bucle*

Si fuera necesario, podemos utilizar la declaración `break` para interrumpir la ejecución de un bucle, dada una condición establecida.

``` r
i <- 1
while (i < 12) {
  print(paste("Repetición nº:", i ))
  if (i == 5) {
    break
  }
  i <- i + 1
}
```

    ## [1] "Repetición nº: 1"
    ## [1] "Repetición nº: 2"
    ## [1] "Repetición nº: 3"
    ## [1] "Repetición nº: 4"
    ## [1] "Repetición nº: 5"

#### *Saltando dentro de un bucle*

De forma similar podemos, dada una condición, saltearnos ejecuciones dentro de un bucle. Para ello, utilizaremos la declaración `next`.

``` r
i <- 0
while (i < 9) {
  i <- i + 1
  if (i > 2 & i < 7) {
    next
  }
  else {
    print(paste("Repetición nº:", i ))
  }
}
```

    ## [1] "Repetición nº: 1"
    ## [1] "Repetición nº: 2"
    ## [1] "Repetición nº: 7"
    ## [1] "Repetición nº: 8"
    ## [1] "Repetición nº: 9"

#### <ins>Ejercicio</ins>

Analice el siguiente código **SIN EJECUTARLO** e interprete cuál es la salida esperada explicando que sucede en cada iteración. Luego escriba “a mano” la salida exacta que dará este código.

``` r
compras <- c("pan", "queso", "jamón", "tomate", "lechuga")

i <- 1
while (i <= length(compras)){
  if (i == 1){
    print(paste("En mis lista de compras hay", compras[i]))
  }
  else if (i == 2) {
    print(paste("y también hay", compras[i]))
  } 
  else {
    print(paste("y", compras[i]))
    }
  i <- i + 1
}
```

------------------------------------------------------------------------

### For … in …

El constructo `for` es otra estructura de tipo bucle que permite iterar sobre una colección dada de elementos. En pocas palabras, repetirá la ejecución de un mismo bloque de código tantas veces como elementos existan en dicha secuencia. Por ello, es importante recordar que su sintaxis básica es:

`for` (*item* `in` **colección**) `{código a ejecutar}`

``` r
asistentes <- c("Maria Guadalupe", "Clarisa", "Pablo Alejandro", "Andrea", "Raúl Andres",
                "Evangelina", "Juan Manuel", "María Azul", "Gala", "Lucille", "Lucas")

for (nombre in asistentes) {
    print(nombre)
}
```

    ## [1] "Maria Guadalupe"
    ## [1] "Clarisa"
    ## [1] "Pablo Alejandro"
    ## [1] "Andrea"
    ## [1] "Raúl Andres"
    ## [1] "Evangelina"
    ## [1] "Juan Manuel"
    ## [1] "María Azul"
    ## [1] "Gala"
    ## [1] "Lucille"
    ## [1] "Lucas"

**Para reflexionar:** Compare el código de la celda precedente con el que usamos para listar las carreras reportadas al inscribirse usando un bucle `while`. ¿Que diferencias nota? ¿Cuando usaría uno u otro constructo?

#### *La función `seq()`*

Cuando trabajamos con bucles, es muy frecuente establecer un rango para definir la iteración. Allí entra en juego esta útil función que devuelve una secuencia numérica y cuya sintaxis es: `seq(inicio,fin,paso)`. Por defecto (es decir, si no explicitamos el valor del argumento), el inicio es "1" y el paso "1".

``` r
print("Secuencia de 1 a 3")
```

    ## [1] "Secuencia de 1 a 3"

``` r
for (n in seq(3)){
    print(n)
}
```
    ## [1] 1
    ## [1] 2
    ## [1] 3

``` r
print("Secuencia de 2 a 8, cada 2")
```
    ## [1] "Secuencia de 2 a 8, cada 2"

``` r
for (n in seq(2,8,2)){
    print(n)
}
```

    ## [1] 2
    ## [1] 4
    ## [1] 6
    ## [1] 8

#### *Break, next y condicionales*

Al igual que vimos con `while`, podemos controlar el comportamiento de un bucle `for` de acuerdo a diferentes condiciones.

``` r
fruta <- c("banana", "manzana", "pera")

for (f in fruta){
  print(paste("Cortamos el bucle en su primer iteración, con la fruta", f))
  if (f == "banana"){
    break
  }
}
```

    ## [1] "Cortamos el bucle en su primer iteración, con la fruta banana"

``` r
for (i in seq(1,10)){
  if (i %% 2 != 0){
    next
  } else {
    print(paste("Me salteo todos los impares:", i ))}
}
```

    ## [1] "Me salteo todos los impares: 2"
    ## [1] "Me salteo todos los impares: 4"
    ## [1] "Me salteo todos los impares: 6"
    ## [1] "Me salteo todos los impares: 8"
    ## [1] "Me salteo todos los impares: 10"

**Para pensar:** ¿Cómo funciona el operador `%%`? ¿Como resultaría por ejemplo `11 %% 3`? Existe un operador relacionado que es `%/%`, ¿qué diferencias presenta?

#### *Bucles anidados*

En muchas ocasiones, nos encontraremos con la necesidad de operar iterativamente sobre más de un conjunto de elementos, en esos casos podemos anidar los bucles.

``` r
letras <- c("a", "b", "c")
numeros <- c(1, 2, 3)

for (i in letras) {
  for (j in numeros){
        print(paste(i,j))
  }
}
```

    ## [1] "a 1"
    ## [1] "a 2"
    ## [1] "a 3"
    ## [1] "b 1"
    ## [1] "b 2"
    ## [1] "b 3"
    ## [1] "c 1"
    ## [1] "c 2"
    ## [1] "c 3"

#### <ins>Ejercicio</ins>

``` r
all_num <- c(17, 6, -12, 38, -88, 147, 1, -140, -19, 24, 74, -36)
```

Escriba un programa que separe los números positivos y los negativos del vector proporcionado en diferentes vectores. Imprima dichos vectores identificando su condición y ordenados de menor a mayor.

*Ayuda*: ejecute el siguiente código previamente y vea que aprende con ello.

``` r
ej1 <- c(3,1,2)
print(paste("Ordenados ej1:", sort(ej1)))
```

    ## [1] "Ordenados ej1: 1" "Ordenados ej1: 2" "Ordenados ej1: 3"

``` r
print(ej1)
```

    ## [1] 3 1 2

``` r
ej2 <- c(4,8,6)
cat("Ordenados ej2:", sort(ej2))
```

    ## Ordenados ej2: 4 6 8

<details>
  <summary>Ver la respuesta</summary>
  Antes de ver la respuesta, intente resolverlo!
  <details>
    <summary>Ahora si, ver la respuesta</summary>
    Ya intentó resolverlo por sus medios? Lo logró? Si es así entonces:
    <details>
      <summary>Ver la respuesta</summary>
      
``` r
pos <- c()
neg <- c()
for (n in all_num) {
  if (n > 0) {
    pos <- c(pos,n)
  } else if (n < 0) {
    neg <- c(neg,n)
    }
}
cat("Positivos:", sort(pos), "Negativos:", sort(neg))
```

  </details>
  </details>  
  </details>
