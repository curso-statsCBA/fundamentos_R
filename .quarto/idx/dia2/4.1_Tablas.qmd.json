{"title":"Tablas","markdown":{"yaml":{"title":"Tablas","pagetitle":"Tablas"},"headingText":"Creación de tablas desde cero","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n\nLa tabla será posiblemente el objeto de R más utilizado en el contexto de nuestro trabajo científico. Consiste en una estructura de datos que organiza la información en filas y columnas. Desde un punto de vista programático es útil considerar a las tablas como una *colección de vectores*. Consideradas de esta manera, veremos que la manipulación de las filas y columnas de una tabla es análoga a la manipulación de vectores individuales. En una tabla, *cada columna es un vector*, pudiendo haber vectores de distintos tipos en una misma tabla (por ejemplo, vectores numéricos y de texto).\n\nPara crear una tabla desde cero, en R utilizamos la <u id='table_classes'>clase</u> `data.frame`, y una función con el mismo nombre para generarla:\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"table_classes\", tooltip = '<span style=\"font-size:16px;\">Si bien la clase más utilizada es <code>data.frame</code>, existen otras formas de generar tablas. Por ejemplo, a través de la función <code>data.table()</code> (del paquete <code>data.table</code>), o a través de la función <code>tibble()</code> (del paquete <code>tibble</code>).</span>')\n```\n\n```{r}\ndf <- data.frame(Especie = c(\"Algarrobo\", \"Piquillin\", \"Molle\"),\n                 Individuos = c(15, 17, 9))\n```\n\nAquí, generamos un objeto de tipo `data.frame`, definiendo el nombre de cada columna e igualando cada columna a un contenido en forma de vector. Existen algunas buenas prácticas a la hora de definir los nombres de las columnas, tanto si la generamos en R o con algún software externo (Excel, Calc, Google Sheets, etc.), que nos ahorrarán dolores de cabeza en el futuro:\n\n-   Los nombres de las columnas no pueden comenzar con un número.\n-   Utilizar caracteres alfanuméricos simples. Evitar la ñ u otras letras específicas de otros idiomas.\n-   Evitar símbolos extraños reservados para el uso del lenguaje, tales como: !?¿\\$%&()@*+-\\>\\<{}\n-   Evitar el uso de tildes, comas y puntos y coma.\n-   Evitar el uso de espacios, y reemplazarlos por punto, guión medio o guión bajo.\n\nAl crear o cargar una tabla, veremos la tabla en el panel de entorno. Desplegando la flechita azul podemos obtener información sobre las columnas de la tabla. Además, haciendo click sobre el nombre del objeto, podemos visualizar la tabla entera en otra pestaña.\n\nNormalmente, las tablas se generan fuera del entorno R para ser luego importadas a R. La creación de tablas desde cero adquiere mayor relevancia para tareas mas posteriores del flujo de análisis, como veremos más adelante.\n\nAntes que nada, [descargue el archivo zip](https://raw.githubusercontent.com/pastornicolas/fundamentos_R/refs/heads/main/dia2/data/data.zip) con los datos necesarios para realizar el práctico, y extraiga los archivos dentro de una carpeta llamada \"data\" en el directorio \"dia2\" del proyecto del curso.\n\n------------------------------------------------------------------------\n\n## Importación y exploración de tablas\n\nExisten muchas formas de importar tablas al ambiente de R. Quizás la forma más fácil es hacerlo desde la interfaz gráfica de RStudio: en el panel de entorno, clickeando en el ícono de importación.\n\nPara hacerlo desde la consola, `read.table()` es la función genérica, indicando la dirección y nombre del archivo a importar:\n\n```{r}\niris <- read.table(file = \"data/iris.csv\")\n```\n\nEn realidad, el dataset `iris` viene instalado por defecto con R, pero para ejemplificar lo hacemos visible en el panel de entorno mediante su importación. Esta tabla contiene el valor de distintas variables para 50 flores de 3 especies del género *Iris*.\n\nOtras funciones similares son `read.csv()` y `read.csv2()`, cuyo funcionamiento es idéntico a `read.table()` pero sus argumentos poseen otras especificaciones por defecto.\n\nExisten algunas funciones útiles para obtener información sobre su contenido o estructura. Simplemente llamando a la tabla por su nombre en la consola, R imprime todo el contenido de la tabla. Generalmente no es útil ver una tabla de esta forma, sobre todo si tiene muchas filas y columnas. Podemos visualizar las primeras filas con la función `head()`:\n\n```{r}\nhead(iris)\n```\n\nLa cual imprime las primeras 6 filas de la tabla. Podemos cambiar este número con el segundo argumento de la función (`n`):\n\n```{r}\nhead(iris, n = 10)\n```\n\nLa función `tail()` imprime las últimas filas de la tabla.\n\n```{r}\ntail(iris)\n```\n\nLa función `str()` devuelve información básica sobre las columnas, similar a lo que se detalla en el panel de entorno.\n\n```{r}\nstr(iris)\n```\n\nLa función `dim()` imprime las dimensiones de la tabla (número de filas y de columnas, respectivamente).\n\n```{r}\ndim(iris)\n```\n\nLa funciones `nrow()` y `ncol()` devuelven dichos valores individualmente.\n\nLa función `colnames()` devuelve los nombres de las columnas en un vector de texto:\n\n```{r}\ncolnames(iris)\n```\n\nLa función `rownames()` funciona de manera idéntica, pero para las filas.\n\nAl importar un dataset, una buena práctica es realizar una exploración inicial de la estructura de la tabla, especialmente sus columnas y nombres. La importación incorrecta de datasets es una fuente de error muy frecuente.\n\n------------------------------------------------------------------------\n\n## Manipulación de tablas\n\nUna tarea usual consiste en, una vez cargada una tabla, realizar modificaciones a la misma. Esto incluye, por ejemplo, obtener una nueva tabla de acuerdo a ciertas condiciones, eliminar ciertas filas o agregar nuevas columnas.\n\n### Indexación y filtrado\n\nLos corchetes son muy versátiles para manipular y extraer datos de un `data.frame`. La sintaxis general es `data[filas, columnas]`, siendo posible indicar índices, expresiones lógicas o nombres de columnas para obtener un subconjunto de datos (i.e. un subset).\n\n```{r}\niris_sub <- iris[1:5, ]\n```\n\nAquí, generamos un nuevo dataset con sólo las 5 primeras filas de la tabla `iris`. Notar que al mismo tiempo que se realiza el filtrado, lo asigno a un nuevo objeto. Si la asignación no se realiza, el objeto no queda guardado en el entorno, pero es útil si queremos probar rápidamente alguna línea de código, sin necesidad de generar un nuevo objeto.\n\nAhora, generamos un nuevo dataset que contiene sólo las columnas `\"Species\"` y `\"Sepal.Length\"`.\n\n```{r}\niris_sub2 <- iris[, c(\"Species\", \"Sepal.Length\")]\nhead(iris_sub2)\n```\n\nNotar que la nueva tabla mantiene la identidad pero también el orden de las columnas indicadas en la sintaxis. Por lo tanto, esta sintaxis también puede utilizarse para cambiar el orden de las columnas, pudiendo indicar el nombre (como en el ejemplo) o los índices (para este ejemplo sería `c(5, 1)`).\n\nLa función `order()` permite ordenar una tabla de acuerdo a los valores de una columna o más columnas:\n\n```{r}\niris <- iris[order(iris$Sepal.Length), ]\nhead(iris, 10)\n```\n\nPara seleccionar una columna de una table utilizamos la sintaxis `tabla$columna`.\n\nEn esto contexto, la expresión `order(iris$Sepal.Length)` genera nuevos índices para cada fila, indicando que nueva posición deberían ocupar para que la tabla quede ordenada. Por defecto, `order()` ordena de manera creciente. Indicando `decreasing = TRUE` se ordena la tabla de manera decreciente.\n\nEs posible indicar una ordenación por más de una columna:\n\n```{r}\niris <- iris[order(iris$Species, iris$Sepal.Length, decreasing = TRUE), ]\nhead(iris, 10)\n```\n\nEs posible obtener subconjuntos de datos que cumplan con ciertas condiciones. Las condiciones, en general, serán sobre los datos contenidos en las filas.\n\n```{r}\niris_sub3 <- iris[iris$Sepal.Length > 5, ]\nhead(iris_sub3)\n```\n\nAquí estamos seleccionando aquellas filas para los cuales `Sepal.Length` es mayor a 5. ¿Por qué esta sintáxis tan rara? En realidad, lo que estamos haciendo es indicar una expresión lógica para las filas, especificando el nombre de la tabla y la columna (es un vector!) mediante el operador `$`:\n\n```{r}\niris$Sepal.Length > 5\n```\n\nEs posible, entonces, indicar cualquier expresión lógica referida a una o más columnas de la tabla. El mismo filtrado puede realizarse mediante la función `subset()`, siendo este método un poco menos \"engorroso\":\n\n```{r}\niris_sub3 <- subset(iris, Sepal.Length > 5)\nhead(iris_sub3)\n```\n\nEl primer argumento indica el conjunto de datos a utilizar, y el segundo argumento la expresión a aplicar para filtrar dicho conjunto de datos. Notar que no es necesario aclarar la sintaxis `iris$Sepal.Length`. Esto es hace más fácil la escritura cuando haya que indicar múltiples condiciones lógicas.\n\nEl argumento `select` permite además seleccionar una o más columnas a dejar luego del filtro:\n\n```{r}\niris_sub4 <- subset(iris, Sepal.Length > 5, select = c(\"Species\", \"Sepal.Width\"))\nhead(iris_sub4)\n```\n\n¿Cómo modificamos el contenido de una tabla? Para ello, debemos primero seleccionar qué campos queremos modificar, y luego asignarle el nuevo contenido. Por ejemplo, si quisiéramos cambiar el nombre de una de las especies por un sinónimo:\n\n```{r}\niris$Species[iris$Species == \"setosa\"] <- \"arctica\"\n```\n\nAnalicemos con cuidado esta expresión. La primera parte, `iris$Species`, indica la columna `Species`. Es decir, selecciono dicho el vector-columna. Entre corchetes indico una expresión lógica para seleccionar todos aquellos elementos del vector en donde dicha expresión sea verdadera. En este caso, donde el vector `iris$Species` sea igual (`==`) a `\"setosa\"`. Finalmente, le asignamos el valor `\"arctica\"`. Dado que queremos un único valor para todos los campos, no es necesario asignar un vector con elementos repetidos para `\"arctica\"`.\n\n**Para pensar:** ¿Por qué no hay coma en la sintaxis de filtrado anterior?\n\nPodemos corroborar que se ha modificado la tabla con la función `unique()`, que devuelve los valores únicos para un objeto dado:\n\n```{r}\nunique(iris$Species)\n```\n\n```{r, echo = FALSE}\niris <- read.table(file = \"data/iris.csv\")\n```\n\n#### <ins>Ejercicio 1</ins>\n\nGenere nuevas tablas a partir de la tabla `iris` (utilizar nombres nuevos para cada tabla), para:\n\n-   La especie \"setosa\", y las columnas \"Species\" y \"Petal.Width\".\n-   Las especies \"setosa\" y \"versicolor\". Deberá utilizar el operador `%in%` en vez del `==` (recordá de qué estamos hablando en [Vectores](../dia1/3.2_Vectores.qmd)).\n-   Flores en donde \"Petal.Length\" es mayor o igual a 4.\n-   Flores en donde \"Sepal.Width\" es mayor a 3 o \"Sepal.Length\" \\< 4.\n\n### Creación de nuevas columnas\n\nPara agregar una nueva columna utilizamos la sintaxis `data$nueva_columna`. La columna debe asociarse a un contenido, las filas, mediante el operador de asignación. Lo que hacemos es agregar un nuevo vector-columna a la colección de vectores-columnas que es el `data.frame`:\n\n```{r}\niris$Seed.set <- NA\nhead(iris)\n```\n\nVemos que se ha generado una nueva columna con campos igual a `NA` (no dato). Crear una columna con datos vacíos de esta manera puede llegar a ser útil para luego *ir rellenando* cada fila de acuerdo al contenido de otras columnas. Spoiler: el control de flujo podría ser útil para esta tarea.\n\nLa siguiente línea genera una nueva columna a partir del cociente de otras dos:\n\n```{r}\niris$Sepal.Petal.ratio <- iris$Sepal.Length/iris$Petal.Length\nhead(iris)\n```\n\nLa función `ifelse()` es útil para generar nuevas columnas basadas en la información de columnas ya existentes. Funciona de manera similar a un \"SI()\" de Excel/Calc. El primer argumento establece la condición, el segundo el valor devuelto si la condición es verdadera, y el tercero si es falsa:\n\n```{r}\niris$Sepal.width.cat <- ifelse(iris$Sepal.Width < 3, \"Corto\", \"Largo\")\nhead(iris)\n```\n\nEs posible anidar la función `ifelse()` para obtener más categorías:\n\n```{r}\niris$Sepal.width.cat2 <- ifelse(iris$Sepal.Width < 2.8, \"Corto\",\n                               ifelse(iris$Sepal.Width >= 2.8 & iris$Sepal.Width < 3.3, \"Mediano\", \"Largo\"))\nhead(iris)\n```\n\nTraducción en palabras: Si el largo del sépalo es menor a 2.8, clasificarlo como \"Corto\". En caso contrario, si es mayor o igual a 2.8 Y menor a 3.3, clasificarlo como \"Mediano\"; si no es así, clasificarlo como \"Largo\".\n\nCon la función `factor()`, es posible aisgnarle a un vector-columna la clase de `factor`:\n\n```{r}\niris$Sepal.width.cat2 <- factor(iris$Sepal.width.cat2)\niris$Sepal.width.cat2\n```\n\nRecordemos, como vimos en la clase de [Vectores](../dia1/3.2_Vectores.qmd), que al indicar un factor es posible también indicar el orden de sus niveles. Esto también aplica en el contexto de manipulación de tablas.\n\nNo obstante, a la hora de generar vectores (aquí asociados a una tabla), la función `cut()` es más adecuada. Esta función divide el rango de valores de un vector en intervalos específicos, y define nombres para cada intervalo. Por ejemplo:\n\n```{r}\niris$Sepal.width.cat4 <- cut(x = iris$Sepal.Width, breaks = 3, labels = c(\"Corto\", \"Mediano\", \"Largo\"))\nhead(iris)\n```\n\nAquí, creamos una nueva columna, construida a partir de los valores de la columna `Sepal.Width`. Mediante `breaks = 3`, indicamos que el rango de valores de `Sepal.Width` se divida en 3 partes iguales, y definimos los nombres para cada intervalo en el argumento `labels`. El argumento `breaks` también admite un vector numérico con los valores que dividirán los intervalos generados.\n\nLa función `cut()` devuelve un factor con niveles, adecuado en contextos de análisis estadísticos y graficación:\n\n```{r}\nclass(iris$Sepal.width.cat4)\n```\n\n#### <ins>Ejercicio 2</ins>\n\nGenere una nueva columna para la tabla `iris` llamada \"Flower.color\". Para las especie *Iris setosa* y *Iris versicolor*, asignarle \"Purple\". Para la especie *Iris virginica* asignarle \"Blue\".\n\n------------------------------------------------------------------------\n\n### Unión de tablas\n\nLas funciones `rbind()` y `cbind()` permiten añadir filas (\"r\" de \"row\") y columnas (\"c\" de \"column\") a un `data.frame`, respectivamente.\n\nA modo de ejemplo, importaremos un `data.frame` conteniendo las medidas de variables florales (inventadas para el ejemplo) para la especie *Iris florentina*. Asimismo, cargamos nuevamente la tavla `iris` con la estructura y datos originales:\n\n```{r}\n# Cargamos nuevamente la tabla con la estructura y datos originales\niris <- read.table(\"data/iris.csv\")\n# Cargamos la nueva tabla\niris_fl <- read.table(\"data/iris_florentina.csv\")\nhead(iris_fl)\n```\n\nPodemos ver que tiene la misma cantidad de columnas y los mismos nombres que la tabla original con la que venimos trabajando. Lo lógico sería unir estas dos tablas mediante `rbind()`:\n\n```{r}\niris_new <- rbind(iris, iris_fl)\n```\n\nLa exploración de las últimas filas de la nueva tabla comprueban que hemos hecho la unión correctamente:\n\n```{r}\ntail(iris_new)\n```\n\nAl utilizar `rbind()`, debemos asegurarnos de que la cantidad de columnas y sus nombres sean idénticos. De lo contrario, R devuelve un error.\n\nDe manera similar, la función `cbind()` une tablas a lo largo de sus columnas, y su sintaxis tiene la forma de `cbind(tabla1, tabla2)`. Lógicamente, el número de filas de ambas tablas debe ser el mismo, de lo contraria obtendremos una advertencia o un error.\n\nUsualmente, la información está repartida en más de una tabla. ¿Cómo generamos una nueva tabla que reúna toda la información junta? Para ello utilizamos la función `merge()` (fusionar/combinar). A modo de ejemplo, cargamos una nueva tabla con los nombres comunes de las especies de *Iris* con las que venimos trabajando:\n\n```{r}\niris_names <- read.table(\"data/iris_common_names.csv\")\niris_names\n```\n\nVemos que la tabla tiene dos columnas, una para la especie y otra para el nombre común. La idea sería agregar a la tabla generada anteriormente `iris_new` una nueva columna con los nombres comunes, repetidos para cada fila correspondiente. Hacerlo manualmente no es viable, siendo la función `merge()` la adecuada para esta tarea:\n\n```{r}\niris_new2 <- merge(iris_new, iris_names, by = \"Species\")\nhead(iris_new2)\n```\n\nLos primeros dos argumentos indican las tablas a combinar, y el argumento `by` la columna común a ambas tablas (pueden indicarse más columnas con la sintaxis `c(\"columna1\", \"columna2\")`). La función *busca* coincidencias de campos en la columna (o columnas) en ambas tablas, y *rellena* correspondientemente.\n\nLa función `merge()` es una función muy útil para combinar tablas, pero debe utilizarse con cuidado, pensando qué tabla final es la que nos proponemos generar. Por ejemplo, obtendremos resultados distintos si los campos de la columna especificada en `by` (en el ejemplo, las especies) difieren de alguna manera, o si hay campos faltantes. Esto es particularmente importante para datasets muy grandes en donde no podemos corroborar que lo que se ha fusionado es lo que realmente nos proponíamos hacer. Es conveniente explorar las distintas opciones en `?merge`.\n\n### Cálculo de estadísticas sobre tablas\n\nLa función `aggregate()` es útil para generar tablas con estadísticas de resumen de acuerdo a los niveles de un determinado factor. Por ejemplo, para calcular el valor medio de la longitud del sépalo para cada especie utilizamos la siguiente sintaxis:\n\n```{r}\niris_mean <- aggregate(Sepal.Width ~ Species, data = iris, FUN = mean)\niris_mean\n```\n\nEl primer argumento indica una fórmula con la sintaxis `variable ~ factor`, el segundo el `data.frame` de referencia y el tercero la función a aplicar. Esta función debe existir en el entorno, tanto por defecto (las cuales no aparecen visibles, como `mean()` o `sd()`) o programadas por el usuario.\n\nNo es útil que la columna de esta nueva tabla se siga llamando `Sepal.Width`. Podemos cambiarla asignando un nuevo nombre al vector generado con la función `colnames()`:\n\n```{r}\ncolnames(iris_mean) <- c(\"Species\", \"Sepal.Width.mean\")\niris_mean\n```\n\n**Para pensar:** Aquí debí aclarar \"Species\" para la primera columna, que no cambia de nombre. ¿Cuál podría ser la línea de código para cambiar únicamente la segunda columna?\n\nPara calcular la media de varias variables en una misma línea de código, utilizamos la función `cbind()`:\n\n```{r}\niris_mean <- aggregate(cbind(Sepal.Length, Sepal.Width) ~ Species, data = iris, FUN = mean)\niris_mean\n```\n\nEl uso del punto `.` es útil para hacer el cálculo sobre todas las columnas del dataset, a excepción de la definida a la derecha de `~`:\n\n```{r}\niris_mean <- aggregate(. ~ Species, data = iris, FUN = mean)\niris_mean\n```\n\n#### <ins>Ejercicio 3</ins>\n\nGenerar una tabla que contenga el cálculo de la media de \"Petal.Length\" para cada especie. Luego, generar otra tabla con la desviación estándar de \"Petal.Length\" para cada especie. En cada tabla, cambiar los nombres de las nuevas columnas a \"Petal.Length.mean\" y \"Petal.Length.sd\". Finalmente, unir ambas tablas con `cbind()`.\n\n------------------------------------------------------------------------\n\n## Exportación de tablas\n\nLa exportación de un `data.frame` se realiza con `write.table`:\n\n```{r, eval = FALSE}\nwrite.table(iris_mean, file = \"iris.mean.csv\", row.names = F)\n```\n\nAnálogamente a las funciones de importación, también disponemos de las funciones `write.csv()` y `write.csv2`.\n\n------------------------------------------------------------------------\n\n## Otras estructuras de datos\n\n### Matrices\n\nLas matrices en R pertenecen a la clase `matrix`. Es una colección de datos agrupados en filas y columnas y, si bien admiten objetos de distinto tipo, en general se utilizan para almacenar números. La utilidad principal de una matriz, a diferencia de un `data.frame`, es que permite operaciones matemáticas propias. Por ello, es un objeto fundamental para el análisis estadístico en múltiples disciplinas.\n\nPara crear una matriz en R, utilizamos la función `matrix()`:\n\n```{r}\nmat <- matrix(data = 1:25, ncol = 5, nrow = 5)\nmat\n```\n\nEl primer argumento indica los elementos que contendrá la matriz. En este caso, se utiliza la sucesión de números enteros desde el 1 al 25. Los argumentos `ncol` y `nrow` indican el número de columnas y filas correspondientes para generar la matriz. Un detalle importante es la forma en la que los elementos de la matriz se van *rellenando*. Por defecto, los datos se van agregando por columnas. En cambio, si se indica `byrow = TRUE`, los datos se agregan por fila:\n\n```{r}\nmat <- matrix(data = 1:25, ncol = 5, nrow = 5, byrow = TRUE)\nmat\n```\n\nLa función `dim()` nos indica el número de filas y columnas de la matriz:\n\n```{r}\ndim(mat)\n```\n\nAl igual que para la clase `data.frame`, las funciones `nrow()` y `ncol()` indican el número de filas y columnas de una matriz.\n\nLos corchetes son los operadores indicados para acceder a los elementos de una matriz, indicando los índices para las filas y las columnas separado por una coma:\n\n```{r}\nmat[2, 3]\n```\n\nLas matrices se asocian a numerosas funciones especiales para matrices, pero no es la idea de este curso indagar mucho en este tema. Podemos mencionar las funciones `rowSums()` y `colSums()`, que devuelven las sumas de las filas y las columnas respectivamente. Análogamente, las funciones `rowMeans()` y `colMeans()` devuelven los valores medios.\n\n### Listas\n\nUna gran parte de diversos paquetes de R contienen funciones cuyas salidas son estructuras más complejas que las aprendidas hasta ahora. Un tipo de estas estructuras es la lista; estos son objetos de clase `list`. Es una colección de objetos de cualquier tipo. Por ejemplo:\n\n```{r}\niris_info <- list(data = iris,\n                  mean_stats = iris_mean,\n                  year_of_creation = 2024)\n```\n\nLa información guardada en una lista se accede mediante el operador `$`, si es que los elementos de la lista a acceder tienen asociado un nombre:\n\n```{r}\niris_info$mean_stats\n```\n\nTambién es posible acceder a la información de un elemento de una lista indicando el índice del elemento entre corchetes dobles:\n\n```{r}\niris_info[[3]]\n```\n\nLa estructura y parte del contenido de una lista también puede desplegarse en el panel de entorno.\n\nEs posible modificar el contenido de un elemento de la lista, incluso indicando un elemento de otra clase:\n\n```{r}\niris_info$year_of_creation <- \"Dos mil veinticuatro\"\niris_info$year_of_creation\n```\n\nPor ejemplo, la salida de la función `lm()`, que confecciona una <u id='lm'>regresión lineal</u>, es una lista:\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"lm\", tooltip = '<span style=\"font-size:16px;\">Una regresión líneal relaciona una variable respuesta con una o más variables predictoras. Para el caso de una única variable predictora, al final se obtiene una recta con su ordenada al origen y su pendiente asociada.</span>')\n```\n\n```{r}\nmod <- lm(Sepal.Length ~ Petal.Length, data = iris)\nis.list(mod)\n```\n\nAquí, en el primer argumento, indicamos para modelar la variable `Sepal.Length` en función de la variable `Petal.Length`. El símbolo `~` (virgulilla) es el indicado para expresar la fórmula. En el argumento `data` indicamos el `data.frame` de referencia. Por otro lado, la función `is.list()` devuelve `TRUE` si el objeto indicado es de clase `list`.\n\nLa función `summary()` devuelve información relevante sobre el modelo:\n\n```{r}\nmod_summ <- summary(mod)\nmod_summ\n```\n\nQue también guarda la información en una lista:\n\n```{r}\nis.list(mod_summ)\n```\n\nEs posible acceder a los coeficientes del modelo, en forma de tabla, explorando la salida de `summary()`:\n\n```{r}\nmod_summ$coefficients\n```\n\n#### Clases S4\n\nOtra salida menos común de algunos paquetes son las clases S4. En esencia, son muy similares a las listas en el sentido de que pueden almacenar cualquier tipo de objeto. Una de las diferencias radica en que el tipo de elemento a almacenar está predefinido, y no puede cambiarse.\n\nUn ejemplo es la salida de la función `raster()` del paquete `raster`, la cual genera un objeto de tipo raster, muy utilizado en el contexto de Sistemas de Información Geográfica. Por ahora, basta con saber que la información de estos objetos se acceden con el operador `@`, mediante la sintaxis `objeto@elemento`.\n\n------------------------------------------------------------------------\n\n### El paquete *dplyr*\n\nEl paquete *dplyr* ofrece numerosas herramientas R para manipular y transformar datos. Es parte del universo [tidyverse](https://www.tidyverse.org/){target=\"_blank\"}, diseñado para facilitar el trabajo con datos tabulares de manera eficiente y legible. A diferencia del manejo básico de tablas en R, *dplyr* introduce una sintaxis diferente a través del operador `%>%`, que relaciona una expresión con otra como si fuera una oración de texto:\n\n*cargar tabla %\\>% seleccionar columnas %\\>% filtrar filas %\\>% crear nueva columna*\n\nPor ejemplo, *dplyr* ofrece funciones intuitivas para realizar operaciones comunes, como filtrar filas (`filter()`), seleccionar columnas (`select()`), reordenar datos (`arrange()`), crear nuevas variables (`mutate()`) y resumir información (`summarize()`).\n\nEl presente curso está orientado a entender los fundamentos básicos del lenguaje R y no ahondaremos en el uso de este paquete. No obstante, creemos que es útil saber de su existencia y explorar sobre su uso en caso de necesidad.\n\n------------------------------------------------------------------------\n\n#### <ins>Ejercicio final</ins>\n\n1.  Cargue la tabla del archivo \"analisis_tierra.csv\", la cual muestra los resultados de un análisis de muestras de tierra, detallando las concentraciones de N, C y Ca. Explore su estructura y contenido utilizando las funciones `head()`, `tail()`, `str()` y `dim()`.\n2.  Explore los nombres de las columnas. Corrija el error en la segunda columna, que debería llamarse \"Parcela\".\n3.  Hay valores negativos para la concentración de Ca, lo cual no tiene sentido. Cambie estos valores por ceros.\n4.  Hay valores `NA` en la columna que indica la concentración de N. Genere una nueva tabla, utilizando el mismo nombre que antes, que no contenga estas observaciones (filas). Puede utilizar la expresión `is.na()`, pero explore también la ayuda de `na.omit()`.\n5.  Cargue la tabla del archivo \"analisis_tierra2.csv\", la cual muestra los resultados realizados por otra técnica (Claudia). Incorpore estos nuevos datos a la tabla anterior. Es necesario corregir algunos errores antes de hacer esto <img src=\"pics/emoticon1.png\" width=\"20\" height=\"20\"/>. Entre ellos, los números asignados a cada muestra deben cambiarse, para que estos no coincidan con los números de muestra de la tabla anterior.\n6.  Ordene la tabla según la Parcela (orden alfabético) y por valores crecientes en la cantidad de N, en ese orden!\n7.  Exprese a la columna \"Tecnico\" como factor.\n8.  Genere una tabla resumen con los valores medios de N, C y Ca por Parcela, y otra con los valores de desviación estándar de N, C y Ca por Técnico. Exporte dichas tablas resumen.\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_tablas.png\" target=\"_blank\"><img src=\"pics/meme_practico_tablas.png\" style=\"padding: 5px 0 5px 0;width: 50rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n# Creación de tablas desde cero\n\nLa tabla será posiblemente el objeto de R más utilizado en el contexto de nuestro trabajo científico. Consiste en una estructura de datos que organiza la información en filas y columnas. Desde un punto de vista programático es útil considerar a las tablas como una *colección de vectores*. Consideradas de esta manera, veremos que la manipulación de las filas y columnas de una tabla es análoga a la manipulación de vectores individuales. En una tabla, *cada columna es un vector*, pudiendo haber vectores de distintos tipos en una misma tabla (por ejemplo, vectores numéricos y de texto).\n\nPara crear una tabla desde cero, en R utilizamos la <u id='table_classes'>clase</u> `data.frame`, y una función con el mismo nombre para generarla:\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"table_classes\", tooltip = '<span style=\"font-size:16px;\">Si bien la clase más utilizada es <code>data.frame</code>, existen otras formas de generar tablas. Por ejemplo, a través de la función <code>data.table()</code> (del paquete <code>data.table</code>), o a través de la función <code>tibble()</code> (del paquete <code>tibble</code>).</span>')\n```\n\n```{r}\ndf <- data.frame(Especie = c(\"Algarrobo\", \"Piquillin\", \"Molle\"),\n                 Individuos = c(15, 17, 9))\n```\n\nAquí, generamos un objeto de tipo `data.frame`, definiendo el nombre de cada columna e igualando cada columna a un contenido en forma de vector. Existen algunas buenas prácticas a la hora de definir los nombres de las columnas, tanto si la generamos en R o con algún software externo (Excel, Calc, Google Sheets, etc.), que nos ahorrarán dolores de cabeza en el futuro:\n\n-   Los nombres de las columnas no pueden comenzar con un número.\n-   Utilizar caracteres alfanuméricos simples. Evitar la ñ u otras letras específicas de otros idiomas.\n-   Evitar símbolos extraños reservados para el uso del lenguaje, tales como: !?¿\\$%&()@*+-\\>\\<{}\n-   Evitar el uso de tildes, comas y puntos y coma.\n-   Evitar el uso de espacios, y reemplazarlos por punto, guión medio o guión bajo.\n\nAl crear o cargar una tabla, veremos la tabla en el panel de entorno. Desplegando la flechita azul podemos obtener información sobre las columnas de la tabla. Además, haciendo click sobre el nombre del objeto, podemos visualizar la tabla entera en otra pestaña.\n\nNormalmente, las tablas se generan fuera del entorno R para ser luego importadas a R. La creación de tablas desde cero adquiere mayor relevancia para tareas mas posteriores del flujo de análisis, como veremos más adelante.\n\nAntes que nada, [descargue el archivo zip](https://raw.githubusercontent.com/pastornicolas/fundamentos_R/refs/heads/main/dia2/data/data.zip) con los datos necesarios para realizar el práctico, y extraiga los archivos dentro de una carpeta llamada \"data\" en el directorio \"dia2\" del proyecto del curso.\n\n------------------------------------------------------------------------\n\n## Importación y exploración de tablas\n\nExisten muchas formas de importar tablas al ambiente de R. Quizás la forma más fácil es hacerlo desde la interfaz gráfica de RStudio: en el panel de entorno, clickeando en el ícono de importación.\n\nPara hacerlo desde la consola, `read.table()` es la función genérica, indicando la dirección y nombre del archivo a importar:\n\n```{r}\niris <- read.table(file = \"data/iris.csv\")\n```\n\nEn realidad, el dataset `iris` viene instalado por defecto con R, pero para ejemplificar lo hacemos visible en el panel de entorno mediante su importación. Esta tabla contiene el valor de distintas variables para 50 flores de 3 especies del género *Iris*.\n\nOtras funciones similares son `read.csv()` y `read.csv2()`, cuyo funcionamiento es idéntico a `read.table()` pero sus argumentos poseen otras especificaciones por defecto.\n\nExisten algunas funciones útiles para obtener información sobre su contenido o estructura. Simplemente llamando a la tabla por su nombre en la consola, R imprime todo el contenido de la tabla. Generalmente no es útil ver una tabla de esta forma, sobre todo si tiene muchas filas y columnas. Podemos visualizar las primeras filas con la función `head()`:\n\n```{r}\nhead(iris)\n```\n\nLa cual imprime las primeras 6 filas de la tabla. Podemos cambiar este número con el segundo argumento de la función (`n`):\n\n```{r}\nhead(iris, n = 10)\n```\n\nLa función `tail()` imprime las últimas filas de la tabla.\n\n```{r}\ntail(iris)\n```\n\nLa función `str()` devuelve información básica sobre las columnas, similar a lo que se detalla en el panel de entorno.\n\n```{r}\nstr(iris)\n```\n\nLa función `dim()` imprime las dimensiones de la tabla (número de filas y de columnas, respectivamente).\n\n```{r}\ndim(iris)\n```\n\nLa funciones `nrow()` y `ncol()` devuelven dichos valores individualmente.\n\nLa función `colnames()` devuelve los nombres de las columnas en un vector de texto:\n\n```{r}\ncolnames(iris)\n```\n\nLa función `rownames()` funciona de manera idéntica, pero para las filas.\n\nAl importar un dataset, una buena práctica es realizar una exploración inicial de la estructura de la tabla, especialmente sus columnas y nombres. La importación incorrecta de datasets es una fuente de error muy frecuente.\n\n------------------------------------------------------------------------\n\n## Manipulación de tablas\n\nUna tarea usual consiste en, una vez cargada una tabla, realizar modificaciones a la misma. Esto incluye, por ejemplo, obtener una nueva tabla de acuerdo a ciertas condiciones, eliminar ciertas filas o agregar nuevas columnas.\n\n### Indexación y filtrado\n\nLos corchetes son muy versátiles para manipular y extraer datos de un `data.frame`. La sintaxis general es `data[filas, columnas]`, siendo posible indicar índices, expresiones lógicas o nombres de columnas para obtener un subconjunto de datos (i.e. un subset).\n\n```{r}\niris_sub <- iris[1:5, ]\n```\n\nAquí, generamos un nuevo dataset con sólo las 5 primeras filas de la tabla `iris`. Notar que al mismo tiempo que se realiza el filtrado, lo asigno a un nuevo objeto. Si la asignación no se realiza, el objeto no queda guardado en el entorno, pero es útil si queremos probar rápidamente alguna línea de código, sin necesidad de generar un nuevo objeto.\n\nAhora, generamos un nuevo dataset que contiene sólo las columnas `\"Species\"` y `\"Sepal.Length\"`.\n\n```{r}\niris_sub2 <- iris[, c(\"Species\", \"Sepal.Length\")]\nhead(iris_sub2)\n```\n\nNotar que la nueva tabla mantiene la identidad pero también el orden de las columnas indicadas en la sintaxis. Por lo tanto, esta sintaxis también puede utilizarse para cambiar el orden de las columnas, pudiendo indicar el nombre (como en el ejemplo) o los índices (para este ejemplo sería `c(5, 1)`).\n\nLa función `order()` permite ordenar una tabla de acuerdo a los valores de una columna o más columnas:\n\n```{r}\niris <- iris[order(iris$Sepal.Length), ]\nhead(iris, 10)\n```\n\nPara seleccionar una columna de una table utilizamos la sintaxis `tabla$columna`.\n\nEn esto contexto, la expresión `order(iris$Sepal.Length)` genera nuevos índices para cada fila, indicando que nueva posición deberían ocupar para que la tabla quede ordenada. Por defecto, `order()` ordena de manera creciente. Indicando `decreasing = TRUE` se ordena la tabla de manera decreciente.\n\nEs posible indicar una ordenación por más de una columna:\n\n```{r}\niris <- iris[order(iris$Species, iris$Sepal.Length, decreasing = TRUE), ]\nhead(iris, 10)\n```\n\nEs posible obtener subconjuntos de datos que cumplan con ciertas condiciones. Las condiciones, en general, serán sobre los datos contenidos en las filas.\n\n```{r}\niris_sub3 <- iris[iris$Sepal.Length > 5, ]\nhead(iris_sub3)\n```\n\nAquí estamos seleccionando aquellas filas para los cuales `Sepal.Length` es mayor a 5. ¿Por qué esta sintáxis tan rara? En realidad, lo que estamos haciendo es indicar una expresión lógica para las filas, especificando el nombre de la tabla y la columna (es un vector!) mediante el operador `$`:\n\n```{r}\niris$Sepal.Length > 5\n```\n\nEs posible, entonces, indicar cualquier expresión lógica referida a una o más columnas de la tabla. El mismo filtrado puede realizarse mediante la función `subset()`, siendo este método un poco menos \"engorroso\":\n\n```{r}\niris_sub3 <- subset(iris, Sepal.Length > 5)\nhead(iris_sub3)\n```\n\nEl primer argumento indica el conjunto de datos a utilizar, y el segundo argumento la expresión a aplicar para filtrar dicho conjunto de datos. Notar que no es necesario aclarar la sintaxis `iris$Sepal.Length`. Esto es hace más fácil la escritura cuando haya que indicar múltiples condiciones lógicas.\n\nEl argumento `select` permite además seleccionar una o más columnas a dejar luego del filtro:\n\n```{r}\niris_sub4 <- subset(iris, Sepal.Length > 5, select = c(\"Species\", \"Sepal.Width\"))\nhead(iris_sub4)\n```\n\n¿Cómo modificamos el contenido de una tabla? Para ello, debemos primero seleccionar qué campos queremos modificar, y luego asignarle el nuevo contenido. Por ejemplo, si quisiéramos cambiar el nombre de una de las especies por un sinónimo:\n\n```{r}\niris$Species[iris$Species == \"setosa\"] <- \"arctica\"\n```\n\nAnalicemos con cuidado esta expresión. La primera parte, `iris$Species`, indica la columna `Species`. Es decir, selecciono dicho el vector-columna. Entre corchetes indico una expresión lógica para seleccionar todos aquellos elementos del vector en donde dicha expresión sea verdadera. En este caso, donde el vector `iris$Species` sea igual (`==`) a `\"setosa\"`. Finalmente, le asignamos el valor `\"arctica\"`. Dado que queremos un único valor para todos los campos, no es necesario asignar un vector con elementos repetidos para `\"arctica\"`.\n\n**Para pensar:** ¿Por qué no hay coma en la sintaxis de filtrado anterior?\n\nPodemos corroborar que se ha modificado la tabla con la función `unique()`, que devuelve los valores únicos para un objeto dado:\n\n```{r}\nunique(iris$Species)\n```\n\n```{r, echo = FALSE}\niris <- read.table(file = \"data/iris.csv\")\n```\n\n#### <ins>Ejercicio 1</ins>\n\nGenere nuevas tablas a partir de la tabla `iris` (utilizar nombres nuevos para cada tabla), para:\n\n-   La especie \"setosa\", y las columnas \"Species\" y \"Petal.Width\".\n-   Las especies \"setosa\" y \"versicolor\". Deberá utilizar el operador `%in%` en vez del `==` (recordá de qué estamos hablando en [Vectores](../dia1/3.2_Vectores.qmd)).\n-   Flores en donde \"Petal.Length\" es mayor o igual a 4.\n-   Flores en donde \"Sepal.Width\" es mayor a 3 o \"Sepal.Length\" \\< 4.\n\n### Creación de nuevas columnas\n\nPara agregar una nueva columna utilizamos la sintaxis `data$nueva_columna`. La columna debe asociarse a un contenido, las filas, mediante el operador de asignación. Lo que hacemos es agregar un nuevo vector-columna a la colección de vectores-columnas que es el `data.frame`:\n\n```{r}\niris$Seed.set <- NA\nhead(iris)\n```\n\nVemos que se ha generado una nueva columna con campos igual a `NA` (no dato). Crear una columna con datos vacíos de esta manera puede llegar a ser útil para luego *ir rellenando* cada fila de acuerdo al contenido de otras columnas. Spoiler: el control de flujo podría ser útil para esta tarea.\n\nLa siguiente línea genera una nueva columna a partir del cociente de otras dos:\n\n```{r}\niris$Sepal.Petal.ratio <- iris$Sepal.Length/iris$Petal.Length\nhead(iris)\n```\n\nLa función `ifelse()` es útil para generar nuevas columnas basadas en la información de columnas ya existentes. Funciona de manera similar a un \"SI()\" de Excel/Calc. El primer argumento establece la condición, el segundo el valor devuelto si la condición es verdadera, y el tercero si es falsa:\n\n```{r}\niris$Sepal.width.cat <- ifelse(iris$Sepal.Width < 3, \"Corto\", \"Largo\")\nhead(iris)\n```\n\nEs posible anidar la función `ifelse()` para obtener más categorías:\n\n```{r}\niris$Sepal.width.cat2 <- ifelse(iris$Sepal.Width < 2.8, \"Corto\",\n                               ifelse(iris$Sepal.Width >= 2.8 & iris$Sepal.Width < 3.3, \"Mediano\", \"Largo\"))\nhead(iris)\n```\n\nTraducción en palabras: Si el largo del sépalo es menor a 2.8, clasificarlo como \"Corto\". En caso contrario, si es mayor o igual a 2.8 Y menor a 3.3, clasificarlo como \"Mediano\"; si no es así, clasificarlo como \"Largo\".\n\nCon la función `factor()`, es posible aisgnarle a un vector-columna la clase de `factor`:\n\n```{r}\niris$Sepal.width.cat2 <- factor(iris$Sepal.width.cat2)\niris$Sepal.width.cat2\n```\n\nRecordemos, como vimos en la clase de [Vectores](../dia1/3.2_Vectores.qmd), que al indicar un factor es posible también indicar el orden de sus niveles. Esto también aplica en el contexto de manipulación de tablas.\n\nNo obstante, a la hora de generar vectores (aquí asociados a una tabla), la función `cut()` es más adecuada. Esta función divide el rango de valores de un vector en intervalos específicos, y define nombres para cada intervalo. Por ejemplo:\n\n```{r}\niris$Sepal.width.cat4 <- cut(x = iris$Sepal.Width, breaks = 3, labels = c(\"Corto\", \"Mediano\", \"Largo\"))\nhead(iris)\n```\n\nAquí, creamos una nueva columna, construida a partir de los valores de la columna `Sepal.Width`. Mediante `breaks = 3`, indicamos que el rango de valores de `Sepal.Width` se divida en 3 partes iguales, y definimos los nombres para cada intervalo en el argumento `labels`. El argumento `breaks` también admite un vector numérico con los valores que dividirán los intervalos generados.\n\nLa función `cut()` devuelve un factor con niveles, adecuado en contextos de análisis estadísticos y graficación:\n\n```{r}\nclass(iris$Sepal.width.cat4)\n```\n\n#### <ins>Ejercicio 2</ins>\n\nGenere una nueva columna para la tabla `iris` llamada \"Flower.color\". Para las especie *Iris setosa* y *Iris versicolor*, asignarle \"Purple\". Para la especie *Iris virginica* asignarle \"Blue\".\n\n------------------------------------------------------------------------\n\n### Unión de tablas\n\nLas funciones `rbind()` y `cbind()` permiten añadir filas (\"r\" de \"row\") y columnas (\"c\" de \"column\") a un `data.frame`, respectivamente.\n\nA modo de ejemplo, importaremos un `data.frame` conteniendo las medidas de variables florales (inventadas para el ejemplo) para la especie *Iris florentina*. Asimismo, cargamos nuevamente la tavla `iris` con la estructura y datos originales:\n\n```{r}\n# Cargamos nuevamente la tabla con la estructura y datos originales\niris <- read.table(\"data/iris.csv\")\n# Cargamos la nueva tabla\niris_fl <- read.table(\"data/iris_florentina.csv\")\nhead(iris_fl)\n```\n\nPodemos ver que tiene la misma cantidad de columnas y los mismos nombres que la tabla original con la que venimos trabajando. Lo lógico sería unir estas dos tablas mediante `rbind()`:\n\n```{r}\niris_new <- rbind(iris, iris_fl)\n```\n\nLa exploración de las últimas filas de la nueva tabla comprueban que hemos hecho la unión correctamente:\n\n```{r}\ntail(iris_new)\n```\n\nAl utilizar `rbind()`, debemos asegurarnos de que la cantidad de columnas y sus nombres sean idénticos. De lo contrario, R devuelve un error.\n\nDe manera similar, la función `cbind()` une tablas a lo largo de sus columnas, y su sintaxis tiene la forma de `cbind(tabla1, tabla2)`. Lógicamente, el número de filas de ambas tablas debe ser el mismo, de lo contraria obtendremos una advertencia o un error.\n\nUsualmente, la información está repartida en más de una tabla. ¿Cómo generamos una nueva tabla que reúna toda la información junta? Para ello utilizamos la función `merge()` (fusionar/combinar). A modo de ejemplo, cargamos una nueva tabla con los nombres comunes de las especies de *Iris* con las que venimos trabajando:\n\n```{r}\niris_names <- read.table(\"data/iris_common_names.csv\")\niris_names\n```\n\nVemos que la tabla tiene dos columnas, una para la especie y otra para el nombre común. La idea sería agregar a la tabla generada anteriormente `iris_new` una nueva columna con los nombres comunes, repetidos para cada fila correspondiente. Hacerlo manualmente no es viable, siendo la función `merge()` la adecuada para esta tarea:\n\n```{r}\niris_new2 <- merge(iris_new, iris_names, by = \"Species\")\nhead(iris_new2)\n```\n\nLos primeros dos argumentos indican las tablas a combinar, y el argumento `by` la columna común a ambas tablas (pueden indicarse más columnas con la sintaxis `c(\"columna1\", \"columna2\")`). La función *busca* coincidencias de campos en la columna (o columnas) en ambas tablas, y *rellena* correspondientemente.\n\nLa función `merge()` es una función muy útil para combinar tablas, pero debe utilizarse con cuidado, pensando qué tabla final es la que nos proponemos generar. Por ejemplo, obtendremos resultados distintos si los campos de la columna especificada en `by` (en el ejemplo, las especies) difieren de alguna manera, o si hay campos faltantes. Esto es particularmente importante para datasets muy grandes en donde no podemos corroborar que lo que se ha fusionado es lo que realmente nos proponíamos hacer. Es conveniente explorar las distintas opciones en `?merge`.\n\n### Cálculo de estadísticas sobre tablas\n\nLa función `aggregate()` es útil para generar tablas con estadísticas de resumen de acuerdo a los niveles de un determinado factor. Por ejemplo, para calcular el valor medio de la longitud del sépalo para cada especie utilizamos la siguiente sintaxis:\n\n```{r}\niris_mean <- aggregate(Sepal.Width ~ Species, data = iris, FUN = mean)\niris_mean\n```\n\nEl primer argumento indica una fórmula con la sintaxis `variable ~ factor`, el segundo el `data.frame` de referencia y el tercero la función a aplicar. Esta función debe existir en el entorno, tanto por defecto (las cuales no aparecen visibles, como `mean()` o `sd()`) o programadas por el usuario.\n\nNo es útil que la columna de esta nueva tabla se siga llamando `Sepal.Width`. Podemos cambiarla asignando un nuevo nombre al vector generado con la función `colnames()`:\n\n```{r}\ncolnames(iris_mean) <- c(\"Species\", \"Sepal.Width.mean\")\niris_mean\n```\n\n**Para pensar:** Aquí debí aclarar \"Species\" para la primera columna, que no cambia de nombre. ¿Cuál podría ser la línea de código para cambiar únicamente la segunda columna?\n\nPara calcular la media de varias variables en una misma línea de código, utilizamos la función `cbind()`:\n\n```{r}\niris_mean <- aggregate(cbind(Sepal.Length, Sepal.Width) ~ Species, data = iris, FUN = mean)\niris_mean\n```\n\nEl uso del punto `.` es útil para hacer el cálculo sobre todas las columnas del dataset, a excepción de la definida a la derecha de `~`:\n\n```{r}\niris_mean <- aggregate(. ~ Species, data = iris, FUN = mean)\niris_mean\n```\n\n#### <ins>Ejercicio 3</ins>\n\nGenerar una tabla que contenga el cálculo de la media de \"Petal.Length\" para cada especie. Luego, generar otra tabla con la desviación estándar de \"Petal.Length\" para cada especie. En cada tabla, cambiar los nombres de las nuevas columnas a \"Petal.Length.mean\" y \"Petal.Length.sd\". Finalmente, unir ambas tablas con `cbind()`.\n\n------------------------------------------------------------------------\n\n## Exportación de tablas\n\nLa exportación de un `data.frame` se realiza con `write.table`:\n\n```{r, eval = FALSE}\nwrite.table(iris_mean, file = \"iris.mean.csv\", row.names = F)\n```\n\nAnálogamente a las funciones de importación, también disponemos de las funciones `write.csv()` y `write.csv2`.\n\n------------------------------------------------------------------------\n\n## Otras estructuras de datos\n\n### Matrices\n\nLas matrices en R pertenecen a la clase `matrix`. Es una colección de datos agrupados en filas y columnas y, si bien admiten objetos de distinto tipo, en general se utilizan para almacenar números. La utilidad principal de una matriz, a diferencia de un `data.frame`, es que permite operaciones matemáticas propias. Por ello, es un objeto fundamental para el análisis estadístico en múltiples disciplinas.\n\nPara crear una matriz en R, utilizamos la función `matrix()`:\n\n```{r}\nmat <- matrix(data = 1:25, ncol = 5, nrow = 5)\nmat\n```\n\nEl primer argumento indica los elementos que contendrá la matriz. En este caso, se utiliza la sucesión de números enteros desde el 1 al 25. Los argumentos `ncol` y `nrow` indican el número de columnas y filas correspondientes para generar la matriz. Un detalle importante es la forma en la que los elementos de la matriz se van *rellenando*. Por defecto, los datos se van agregando por columnas. En cambio, si se indica `byrow = TRUE`, los datos se agregan por fila:\n\n```{r}\nmat <- matrix(data = 1:25, ncol = 5, nrow = 5, byrow = TRUE)\nmat\n```\n\nLa función `dim()` nos indica el número de filas y columnas de la matriz:\n\n```{r}\ndim(mat)\n```\n\nAl igual que para la clase `data.frame`, las funciones `nrow()` y `ncol()` indican el número de filas y columnas de una matriz.\n\nLos corchetes son los operadores indicados para acceder a los elementos de una matriz, indicando los índices para las filas y las columnas separado por una coma:\n\n```{r}\nmat[2, 3]\n```\n\nLas matrices se asocian a numerosas funciones especiales para matrices, pero no es la idea de este curso indagar mucho en este tema. Podemos mencionar las funciones `rowSums()` y `colSums()`, que devuelven las sumas de las filas y las columnas respectivamente. Análogamente, las funciones `rowMeans()` y `colMeans()` devuelven los valores medios.\n\n### Listas\n\nUna gran parte de diversos paquetes de R contienen funciones cuyas salidas son estructuras más complejas que las aprendidas hasta ahora. Un tipo de estas estructuras es la lista; estos son objetos de clase `list`. Es una colección de objetos de cualquier tipo. Por ejemplo:\n\n```{r}\niris_info <- list(data = iris,\n                  mean_stats = iris_mean,\n                  year_of_creation = 2024)\n```\n\nLa información guardada en una lista se accede mediante el operador `$`, si es que los elementos de la lista a acceder tienen asociado un nombre:\n\n```{r}\niris_info$mean_stats\n```\n\nTambién es posible acceder a la información de un elemento de una lista indicando el índice del elemento entre corchetes dobles:\n\n```{r}\niris_info[[3]]\n```\n\nLa estructura y parte del contenido de una lista también puede desplegarse en el panel de entorno.\n\nEs posible modificar el contenido de un elemento de la lista, incluso indicando un elemento de otra clase:\n\n```{r}\niris_info$year_of_creation <- \"Dos mil veinticuatro\"\niris_info$year_of_creation\n```\n\nPor ejemplo, la salida de la función `lm()`, que confecciona una <u id='lm'>regresión lineal</u>, es una lista:\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"lm\", tooltip = '<span style=\"font-size:16px;\">Una regresión líneal relaciona una variable respuesta con una o más variables predictoras. Para el caso de una única variable predictora, al final se obtiene una recta con su ordenada al origen y su pendiente asociada.</span>')\n```\n\n```{r}\nmod <- lm(Sepal.Length ~ Petal.Length, data = iris)\nis.list(mod)\n```\n\nAquí, en el primer argumento, indicamos para modelar la variable `Sepal.Length` en función de la variable `Petal.Length`. El símbolo `~` (virgulilla) es el indicado para expresar la fórmula. En el argumento `data` indicamos el `data.frame` de referencia. Por otro lado, la función `is.list()` devuelve `TRUE` si el objeto indicado es de clase `list`.\n\nLa función `summary()` devuelve información relevante sobre el modelo:\n\n```{r}\nmod_summ <- summary(mod)\nmod_summ\n```\n\nQue también guarda la información en una lista:\n\n```{r}\nis.list(mod_summ)\n```\n\nEs posible acceder a los coeficientes del modelo, en forma de tabla, explorando la salida de `summary()`:\n\n```{r}\nmod_summ$coefficients\n```\n\n#### Clases S4\n\nOtra salida menos común de algunos paquetes son las clases S4. En esencia, son muy similares a las listas en el sentido de que pueden almacenar cualquier tipo de objeto. Una de las diferencias radica en que el tipo de elemento a almacenar está predefinido, y no puede cambiarse.\n\nUn ejemplo es la salida de la función `raster()` del paquete `raster`, la cual genera un objeto de tipo raster, muy utilizado en el contexto de Sistemas de Información Geográfica. Por ahora, basta con saber que la información de estos objetos se acceden con el operador `@`, mediante la sintaxis `objeto@elemento`.\n\n------------------------------------------------------------------------\n\n### El paquete *dplyr*\n\nEl paquete *dplyr* ofrece numerosas herramientas R para manipular y transformar datos. Es parte del universo [tidyverse](https://www.tidyverse.org/){target=\"_blank\"}, diseñado para facilitar el trabajo con datos tabulares de manera eficiente y legible. A diferencia del manejo básico de tablas en R, *dplyr* introduce una sintaxis diferente a través del operador `%>%`, que relaciona una expresión con otra como si fuera una oración de texto:\n\n*cargar tabla %\\>% seleccionar columnas %\\>% filtrar filas %\\>% crear nueva columna*\n\nPor ejemplo, *dplyr* ofrece funciones intuitivas para realizar operaciones comunes, como filtrar filas (`filter()`), seleccionar columnas (`select()`), reordenar datos (`arrange()`), crear nuevas variables (`mutate()`) y resumir información (`summarize()`).\n\nEl presente curso está orientado a entender los fundamentos básicos del lenguaje R y no ahondaremos en el uso de este paquete. No obstante, creemos que es útil saber de su existencia y explorar sobre su uso en caso de necesidad.\n\n------------------------------------------------------------------------\n\n#### <ins>Ejercicio final</ins>\n\n1.  Cargue la tabla del archivo \"analisis_tierra.csv\", la cual muestra los resultados de un análisis de muestras de tierra, detallando las concentraciones de N, C y Ca. Explore su estructura y contenido utilizando las funciones `head()`, `tail()`, `str()` y `dim()`.\n2.  Explore los nombres de las columnas. Corrija el error en la segunda columna, que debería llamarse \"Parcela\".\n3.  Hay valores negativos para la concentración de Ca, lo cual no tiene sentido. Cambie estos valores por ceros.\n4.  Hay valores `NA` en la columna que indica la concentración de N. Genere una nueva tabla, utilizando el mismo nombre que antes, que no contenga estas observaciones (filas). Puede utilizar la expresión `is.na()`, pero explore también la ayuda de `na.omit()`.\n5.  Cargue la tabla del archivo \"analisis_tierra2.csv\", la cual muestra los resultados realizados por otra técnica (Claudia). Incorpore estos nuevos datos a la tabla anterior. Es necesario corregir algunos errores antes de hacer esto <img src=\"pics/emoticon1.png\" width=\"20\" height=\"20\"/>. Entre ellos, los números asignados a cada muestra deben cambiarse, para que estos no coincidan con los números de muestra de la tabla anterior.\n6.  Ordene la tabla según la Parcela (orden alfabético) y por valores crecientes en la cantidad de N, en ese orden!\n7.  Exprese a la columna \"Tecnico\" como factor.\n8.  Genere una tabla resumen con los valores medios de N, C y Ca por Parcela, y otra con los valores de desviación estándar de N, C y Ca por Técnico. Exporte dichas tablas resumen.\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_tablas.png\" target=\"_blank\"><img src=\"pics/meme_practico_tablas.png\" style=\"padding: 5px 0 5px 0;width: 50rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"4.1_Tablas.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"En esta página","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copiar","copy-button-tooltip-success":"Copiado!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Volver arriba","search-no-results-text":"Sin resultados","search-matching-documents-text":"coincidencias","search-copy-link-title":"Copiar link para buscar","search-hide-matches-text":"No mostrar coincidencias adicionales","search-more-match-text":"otra coincidencia en este documento","search-more-matches-text":"más coincidencias en este documento","search-clear-button-title":"Limpiar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Buscar","search-label":"Buscar","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Cambiar a tema oscuro","toggle-reader-mode":"Cambiar a modo lectura","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":{"light":"cosmo","dark":["cosmo","../cosmo-dark.scss"]},"smooth-scroll":true,"title":"Tablas","pagetitle":"Tablas"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}