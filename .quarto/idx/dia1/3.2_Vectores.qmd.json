{"title":"Vectores","markdown":{"yaml":{"title":"Vectores","pagetitle":"Vectores"},"headingText":"Creación de vectores","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n\nEn R, un vector es una colección ordenada de objetos de un mismo tipo o *clase*. Aprender sobre la creación y manipulación de vectores es un paso fundamental para comprender la manipulación de objetos más complejos, por ejemplo, las tablas y las matrices. Esto se debe a que estos objetos son justamente una colección de vectores.\n\nLa forma más simple de crear un vector es mediante la función genérica `c()`, que simplemente combina los elementos indicados entre comas:\n\n```{r}\nvec <- c(1, 2, 3)\nvec\n```\n\nEs posible asignarles un nombre a cada elemento, lo cual puede ser útil en algunos contextos:\n\n```{r}\nvec <- c(a = 1, b = 2, c = 3)\nvec\n```\n\nSi quisiéramos averiguar qué clase de elementos contiene el vector, utilizamos la función `class()`:\n\n```{r}\nclass(vec)\n```\n\nEn general, podemos utilizar la función `str()` para conocer la estructura (**str**ucture) de cualquier objeto de R, incluyendo vectores:\n\n```{r}\nstr(vec)\n```\n\nUn vector puede componerse de cinco clases principales de elementos:\n\n|  |  |\n|-----------------------|------------------------------------------------|\n| numeric | Contienen números reales (decimales). Por ejemplo: `c(1.2, 1.5, 1.7)`. |\n| integer | Contienen números enteros. Debemos indicarse con la letra `L` luego del número. Por ejemplo: `c(1L, -5L, 16L, 17L)`. |\n| logical | Contienen valores booleanos o lógicos. Por ejemplo: `c(TRUE, FALSE, NA)` o `c(T, F, T)`. |\n| character | Contienen texto, el cual debe explicitarse con comillas simples o dobles. Por ejemplo: `c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")`. |\n| NULL | Representa un vector vacío. Se genera al crear el vector: `vec <- NULL`. |\n\nRecordemos que al crear un vector, este puede componerse de un solo tipo de elementos. Por ello, debemos tener cuidado a la hora de generar nuestros vectores, y asegurarnos de que estamos generando un vector con elementos de la clase deseada. El uso de vectores con elementos de una clase incorrecta es un error muy común en distintos contextos del flujo de trabajo. Por ejemplo:\n\n```{r}\nvec <- c(1985, \"Algarrobo\", \"Quebracho\")\nclass(vec)\n```\n\nObservamos que el vector generado es de clase `character`. A la hora de forzar una clase para los elementos de un vector, R asigna prioridad a ciertas clases sobre otras. Si bien es posible correr líneas de código como la anterior, en general no sería una buena práctica hacerlo. Mejor ser explícito!\n\n### El vector como factor\n\nOtra clase importante para los elementos de un vector es `factor`. Sirve para definir un factor categórico, compuesto por niveles (los elementos *distintos y únicos* del vector), los cuales siguen un orden específico:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies <- factor(especies)\nespecies\n```\n\nEs posible cambiar el orden de los niveles, definiendo al factor con el argumento `levels`:\n\n```{r}\nespecies <- factor(especies, levels = c(\"Quebracho\", \"Espinillo\", \"Algarrobo\"))\nespecies\n```\n\n### Funciones útiles para la creación de vectores\n\nDurante nuestro trabajo, puede ser útil la creación de vectores que sigan una lógica determinada. Si queremos generar una secuencia de números enteros con incremento de a una unidad, el operador de secuencia `:` es el indicado, siguiendo la lógica \"desde:hasta\":\n\n```{r}\nsuc <- 5:30\nsuc\n```\n\nPara generar vectores con una lógica más compleja, las funciones `seq()` y `rep()` son adecuadas. La función `seq()` genera un sucesión de números (i.e. un vector de clase `numeric` o `integer`):\n\n```{r}\nseq(from = 1, to = 10, by = 2)\n```\n\nLos argumentos `from` y `to` determinan respectivamente los valores mínimos y máximos de la secuencia, mientras que el argumento `by` determina el incremento de la secuencia. Otra forma de generar el mismo vector del ejemplo sería:\n\n```{r}\nseq(from = 1, by = 2, length.out = 5)\n```\n\nEl argumento `length.out` determina el número máximo de elementos que contendrá el vector.\n\nAl correr la función con un único número, obtenemos una sucesión de números enteros, comenzando desde el 1:\n\n```{r}\nseq(10)\n```\n\nLa función `rep()` genera un nuevo vector a partir de la repetición de los elementos de un vector dado:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nvec_sp <- rep(x = especies, times = 2)\nvec_sp\n```\n\nEl argumento `x` recibe un vector dado, mientras que el argumento `times` indica la cantidad de veces que debe repetirse el vector dado. Otro argumento relevante de la función `rep()` es el argumento `each`:\n\n```{r}\nvec_sp <- rep(x = especies, each = 3)\nvec_sp\n```\n\nAquí, `each = 3` indica que cada elemento del vector en `x` debe repetirse 3 veces.\n\n### Otras funciones útiles\n\nAdemás de las expuestas, existen numerosas funciones nativas de R para generar vectores. Entre ellas, podemos mencionar a `sample()`, la cual genera un vector con un subconjunto aleatorio de elementos a partir un vector dado; `runif()` y `rnorm()`, los cuales generan vectores de elementos provenientes de una distribución uniforme o normal, respectivamente. Por otro lado, las funciones `letters()` y `LETTERS()` generan vectores de letras en minúscula o mayúscula.\n\n#### <ins>Ejercicio 1</ins>\n\nDado el vector `rep(x = 3:1, each = 5)`, explore qué hacen las siguientes funciones: `length()`, `sort()`, `rev()` y `unique()`.\n\n## Vectores y expresiones lógicas\n\nAhora que aprendimos cómo generar un vector, veremos cómo se evalúan las expresiones lógicas en este contexto. Por ejemplo:\n\n```{r}\n3 == 1:10\n```\n\nAquí, evaluamos si cada elemento del vector `1:10` es igual al número 3, indicando `TRUE` en dicho caso. En cambio, utilizando `!=` obtenemos como resultado lo opuesto:\n\n```{r}\n3 != 1:10\n```\n\nObviamente, los operadores relaciones también son válidos:\n\n```{r}\n3 >= 1:10\n```\n\nEn el contexto de vectores, es muy útil el operador lógico `%in%`. Este operador devuelve `TRUE` para cada elemento a la izquierda, sólo si dicho elemento es encontrado en el vector indicado a la derecha del operador. Caso contrario, devuelve `FALSE`. Por ejemplo:\n\n```{r}\n3 %in% 1:10\n```\n\nTambién es posible indicar más de un elemento a la izquierda del operador:\n\n```{r}\nc(1, 2, 3) %in% 1:10\n```\n\nPor otro lado, las funciones `all()` y `any()` son muy utilizadas a la hora de evaluar vectores lógicos. Anteriormente, vimos que estas funciones sirven para evaluar varias condiciones al mismo tiempo, separadas por una coma. No obstante, también es posible indicarle directamente un vector lógico. En el contexto de vectores, la función `all()` devuelve `TRUE` si todos los elementos del vector lógico son `TRUE`, caso contrario devuelve `FALSE`. Por ejemplo\n\n```{r}\ncond <- 11 > 1:10\nall(cond)\n```\n\nEn cambio, con solo haber un sólo elemento igual a `FALSE`, la función `all()` devuelve `FALSE`:\n\n```{r}\ncond <- 10 > 1:10\nall(cond)\n```\n\nLa función `any()`, devuelve `TRUE` si al menos un elemento del vector lógico es `TRUE`:\n\n```{r}\ncond <- 10 <= 1:10\nany(cond)\n```\n\nCaso contrario, si todos los elementos son iguales a `FALSE`, `any()` devuelve `FALSE`:\n\n```{r}\ncond <- 15 < 1:10\nany(cond)\n```\n\nFinalmente, es útil aclarar que en el contexto de operaciones aritméticas, `TRUE` equivale a `1` y `FALSE` equivale a `0`. Por ejemplo, sea la siguiente condición:\n\n```{r}\ncond <- 5 >= 1:10\ncond\n```\n\nSi sumamos los elementos del vector lógico, obtenemos lo siguiente:\n\n```{r}\nsum(cond)\n```\n\n¿De qué sirve conocer esto? Quizás no le veamos utilidad ahora mismo, pero puede llegar a ser útil en el contexto de un trabajo más avanzado (por ejemplo, en el contexto de manipulación de tablas).\n\n## Manipulación de vectores\n\nUn apartado fundamental para aprender a programar en R es la manipulación de vectores. En pocas palabras, nos referimos a generar un nuevo vector a partir de uno creado previamente, de manera tal que sirva para realizar una tarea específica. Este tipo de tareas será de gran utilidad a la hora de trabajar con tablas.\n\nDado un vector, interesa averiguar su contenido, lo cual lo podemos hacer simplemente imprimiendo el vector en la consola, o rescatando uno o más elementos a través de sus índices:\n\n```{r}\nvec <- seq(from = -5, to = 5, by = 0.25)\nvec[15]\nvec[c(1, 5, 10)]\nvec[13:18]\n```\n\nLos corchetes `[]` indican que se seleccionará un subconjunto de elementos del vector. En la segunda línea del ejemplo, seleccionamos el elemento de índice 15. En la tercera línea de código, seleccionamos los elementos de índice 1, 5 y 10. En la cuarta línea de código, en cambio, seleccionamos los elementos 13 al 18 (i.e. índices).\n\nEs posible excluir elementos con el símbolo `-`:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies_sub <- especies[-2]\nespecies_sub\n```\n\nAdemás de la posibilidad de indicar índices, es posible utilizar un vector lógico. Dicho vector puede generarse definiendo condiciones que los elementos deben cumplir.\n\n```{r}\ncond1 <- vec > -2 & vec < 2\ncond1\nvec_sub <- vec[cond1]\n```\n\nAquí, el objeto \"cond1\" es un vector lógico, indicando `TRUE` o `FALSE` para cada elemento del vector \"vec\", según la condición expuesta: que el número sea mayor a -2 (`vec > -2`) y (`&`) menor a 2 (`vec < 2`). Notar que hay que ser explícito a la hora de definir la condición. Es útil indicar la condición directamente, sin necesidad de crear un objeto nuevo:\n\n```{r}\nvec_sub <- vec[vec > -2 & vec < 2]\nvec_sub\n```\n\nLa función `subset()` permite hacer la misma operación de filtrado, indicando el vector a filtrar, y la condición:\n\n```{r}\nvec_sub <- subset(vec, vec > -2 & vec < 2)\nvec_sub\n```\n\nLa función `which()` devuelve los índices de los elementos de un vector que cumplen con una condición dada:\n\n```{r}\nwhich(vec > -2 & vec < 2)\n```\n\n**Para pensar:** Sin correr la expresión, ¿qué pasa si la condición que definimos es `!(vec > -2 & vec < 2)`?\n\nUna vez seleccionado el subconjunto de elementos de un vector, es posible asignarle un valor diferente:\n\n```{r}\nvec[vec <= 0] <- 0\n```\n\nAquí, seleccionamos los valores menores o iguales a 0, y les asignamos el valor 0. Notar que en este caso, al ser un único valor de reemplazo, no es necesario repetir el 0 tantas veces como valores a reemplazar.\n\nA veces, resulta útil reemplazar los valores `NA` (no dato) por algún otro valor útil, para lo cual podemos utilizar la función `is.na()`.\n\n```{r}\nvec <- c(5, 8, 16, NA, 3)\nvec[is.na(vec)] <- 0\nvec\n```\n\nEn el contexto de valores `NA`, es útil la función `na.omit()`, que remuevo todos los elementos que sean `NA`:\n\n```{r}\nvec <- c(5, 8, 16, NA, 3, 8, NA)\nvec2 <- na.omit(vec)\nvec2\n```\n\nA la hora de efectuar subconjuntos de vectores, es importante diferenciar el uso del operador `==` del `%in%`, que ya introdujimos anteriormente. Al utilizar el operador `==` nos preguntamos si cada elemento del vector indicado a la izquierda del operador es igual al elemento (o a los elementos) indicado a la derecha; y utilizamos la expresión lógica resultante para hacer el subset del vector:\n\n```{r}\nespecies <- rep(c(\"Algarrobo\", \"Molle\", \"Quebracho\", \"Piquillin\"), each = 5)\nespecies[especies == \"Quebracho\"]\n```\n\n¿Cómo procedemos si, por ejemplo, quisiéramos seleccionar más de una especie? El operador `==` ya no es útil por sí solo. Una opción es la siguiente:\n\n```{r}\nespecies[especies == \"Molle\" | especies == \"Piquillin\"]\n```\n\nOtra forma de hacerlo es utilizar el operador `%in%`. Recordemos que este operador indica `TRUE` o `FALSE` si cada elemento del vector a la izquierda *está contenido* en el vector indicado a la derecha:\n\n```{r}\nespecies[especies %in% c(\"Molle\", \"Piquillin\")]\n```\n\nComo veremos más adelante, el operador `%in%` es muy útil en el contexto de manipulación de tablas.\n\nEs posible añadir elementos a un vector con la función `c()`:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies <- c(especies, \"Yuchan\", \"Tusca\")\nespecies\n```\n\n**Para explorar:** La función `append()` es una forma de general de hacer esto. Explore `?append`.\n\n## Funciones básicas para vectores numéricos\n\nAnteriormente, hemos visto cómo trabajan las funciones `round()`, `ceiling()`, `floor()` and `trunc()` con números sueltos. Sin embargo, estas funciones, al igual que muchas otras funciones nativas de R, son *funciones vectorizadas*. Esto significa que pueden trabajar sobre un vector, y arrojar un resultado para cada uno de los elementos del vector.\n\nPor ejemplo:\n\n```{r}\nvec <- c(1.233, 1.924, 0.46)\nround(vec, digits = 1)\n```\n\nR también provee de numerosas funciones nativas para obtener medidas de resumen. Podemos mencionar a `mean()` para calcular el promedio, `median()` para calcular la mediana y `sd()` para calcular el desvío estándar.\n\n#### <ins>Ejercicio final</ins>\n\n1.  Utilice las funciones `rep()` y `seq()` para generar los siguientes vectores:\n\n-   Una sucesión de números pares de 15 elementos.\n-   Una sucesión de números decimales, con un incremento de 0.15.\n-   Un vector tipo `character`, que indique 4 categorías discretas, repetidas de a 3 cada una.\n-   Un vector que repita 5 veces el siguiente vector: `c(F, T, F, T)`.\n\n2.  Dado el vector `seq(from = 0, to = 1, by = 0.01)`, y utilizando los aprendido sobre manipulación de vectores y expresiones lógicas, genere nuevos vectores de acuerdo a los siguientes criterios:\n\n-   Que contenga los elementos de índices 10 a 20.\n-   Que excluya los elementos 30 a 50. Ayuda: utilice paréntesis.\n-   Que los elementos sean mayores a 0.5.\n-   Que los elementos sean menores o iguales a 0.3 *o* mayores a 0.7.\n-   Que los elementos cumplan con la condición opuesta a la inmediatamente anterior.\n\n3.  Genere un vector de 500 números provenientes de una distribución normal, de media 15 y desvío estándar 4. Para ello, utilice la función `rnorm()` (explore la ayuda mediante `?rnorm`). Seguidamente, verifique los valores de media, mediana y desvío estándar de la muestra. Calcule los cuantiles tradicionales mediante `quantile()`. Calculo el percentil 5% y el 95%.\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_vectores.png\" target=\"_blank\"><img src=\"pics/meme_practico_vectores.png\" style=\"padding: 5px 0 5px 0;width: 50rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## Creación de vectores\n\nEn R, un vector es una colección ordenada de objetos de un mismo tipo o *clase*. Aprender sobre la creación y manipulación de vectores es un paso fundamental para comprender la manipulación de objetos más complejos, por ejemplo, las tablas y las matrices. Esto se debe a que estos objetos son justamente una colección de vectores.\n\nLa forma más simple de crear un vector es mediante la función genérica `c()`, que simplemente combina los elementos indicados entre comas:\n\n```{r}\nvec <- c(1, 2, 3)\nvec\n```\n\nEs posible asignarles un nombre a cada elemento, lo cual puede ser útil en algunos contextos:\n\n```{r}\nvec <- c(a = 1, b = 2, c = 3)\nvec\n```\n\nSi quisiéramos averiguar qué clase de elementos contiene el vector, utilizamos la función `class()`:\n\n```{r}\nclass(vec)\n```\n\nEn general, podemos utilizar la función `str()` para conocer la estructura (**str**ucture) de cualquier objeto de R, incluyendo vectores:\n\n```{r}\nstr(vec)\n```\n\nUn vector puede componerse de cinco clases principales de elementos:\n\n|  |  |\n|-----------------------|------------------------------------------------|\n| numeric | Contienen números reales (decimales). Por ejemplo: `c(1.2, 1.5, 1.7)`. |\n| integer | Contienen números enteros. Debemos indicarse con la letra `L` luego del número. Por ejemplo: `c(1L, -5L, 16L, 17L)`. |\n| logical | Contienen valores booleanos o lógicos. Por ejemplo: `c(TRUE, FALSE, NA)` o `c(T, F, T)`. |\n| character | Contienen texto, el cual debe explicitarse con comillas simples o dobles. Por ejemplo: `c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")`. |\n| NULL | Representa un vector vacío. Se genera al crear el vector: `vec <- NULL`. |\n\nRecordemos que al crear un vector, este puede componerse de un solo tipo de elementos. Por ello, debemos tener cuidado a la hora de generar nuestros vectores, y asegurarnos de que estamos generando un vector con elementos de la clase deseada. El uso de vectores con elementos de una clase incorrecta es un error muy común en distintos contextos del flujo de trabajo. Por ejemplo:\n\n```{r}\nvec <- c(1985, \"Algarrobo\", \"Quebracho\")\nclass(vec)\n```\n\nObservamos que el vector generado es de clase `character`. A la hora de forzar una clase para los elementos de un vector, R asigna prioridad a ciertas clases sobre otras. Si bien es posible correr líneas de código como la anterior, en general no sería una buena práctica hacerlo. Mejor ser explícito!\n\n### El vector como factor\n\nOtra clase importante para los elementos de un vector es `factor`. Sirve para definir un factor categórico, compuesto por niveles (los elementos *distintos y únicos* del vector), los cuales siguen un orden específico:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies <- factor(especies)\nespecies\n```\n\nEs posible cambiar el orden de los niveles, definiendo al factor con el argumento `levels`:\n\n```{r}\nespecies <- factor(especies, levels = c(\"Quebracho\", \"Espinillo\", \"Algarrobo\"))\nespecies\n```\n\n### Funciones útiles para la creación de vectores\n\nDurante nuestro trabajo, puede ser útil la creación de vectores que sigan una lógica determinada. Si queremos generar una secuencia de números enteros con incremento de a una unidad, el operador de secuencia `:` es el indicado, siguiendo la lógica \"desde:hasta\":\n\n```{r}\nsuc <- 5:30\nsuc\n```\n\nPara generar vectores con una lógica más compleja, las funciones `seq()` y `rep()` son adecuadas. La función `seq()` genera un sucesión de números (i.e. un vector de clase `numeric` o `integer`):\n\n```{r}\nseq(from = 1, to = 10, by = 2)\n```\n\nLos argumentos `from` y `to` determinan respectivamente los valores mínimos y máximos de la secuencia, mientras que el argumento `by` determina el incremento de la secuencia. Otra forma de generar el mismo vector del ejemplo sería:\n\n```{r}\nseq(from = 1, by = 2, length.out = 5)\n```\n\nEl argumento `length.out` determina el número máximo de elementos que contendrá el vector.\n\nAl correr la función con un único número, obtenemos una sucesión de números enteros, comenzando desde el 1:\n\n```{r}\nseq(10)\n```\n\nLa función `rep()` genera un nuevo vector a partir de la repetición de los elementos de un vector dado:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nvec_sp <- rep(x = especies, times = 2)\nvec_sp\n```\n\nEl argumento `x` recibe un vector dado, mientras que el argumento `times` indica la cantidad de veces que debe repetirse el vector dado. Otro argumento relevante de la función `rep()` es el argumento `each`:\n\n```{r}\nvec_sp <- rep(x = especies, each = 3)\nvec_sp\n```\n\nAquí, `each = 3` indica que cada elemento del vector en `x` debe repetirse 3 veces.\n\n### Otras funciones útiles\n\nAdemás de las expuestas, existen numerosas funciones nativas de R para generar vectores. Entre ellas, podemos mencionar a `sample()`, la cual genera un vector con un subconjunto aleatorio de elementos a partir un vector dado; `runif()` y `rnorm()`, los cuales generan vectores de elementos provenientes de una distribución uniforme o normal, respectivamente. Por otro lado, las funciones `letters()` y `LETTERS()` generan vectores de letras en minúscula o mayúscula.\n\n#### <ins>Ejercicio 1</ins>\n\nDado el vector `rep(x = 3:1, each = 5)`, explore qué hacen las siguientes funciones: `length()`, `sort()`, `rev()` y `unique()`.\n\n## Vectores y expresiones lógicas\n\nAhora que aprendimos cómo generar un vector, veremos cómo se evalúan las expresiones lógicas en este contexto. Por ejemplo:\n\n```{r}\n3 == 1:10\n```\n\nAquí, evaluamos si cada elemento del vector `1:10` es igual al número 3, indicando `TRUE` en dicho caso. En cambio, utilizando `!=` obtenemos como resultado lo opuesto:\n\n```{r}\n3 != 1:10\n```\n\nObviamente, los operadores relaciones también son válidos:\n\n```{r}\n3 >= 1:10\n```\n\nEn el contexto de vectores, es muy útil el operador lógico `%in%`. Este operador devuelve `TRUE` para cada elemento a la izquierda, sólo si dicho elemento es encontrado en el vector indicado a la derecha del operador. Caso contrario, devuelve `FALSE`. Por ejemplo:\n\n```{r}\n3 %in% 1:10\n```\n\nTambién es posible indicar más de un elemento a la izquierda del operador:\n\n```{r}\nc(1, 2, 3) %in% 1:10\n```\n\nPor otro lado, las funciones `all()` y `any()` son muy utilizadas a la hora de evaluar vectores lógicos. Anteriormente, vimos que estas funciones sirven para evaluar varias condiciones al mismo tiempo, separadas por una coma. No obstante, también es posible indicarle directamente un vector lógico. En el contexto de vectores, la función `all()` devuelve `TRUE` si todos los elementos del vector lógico son `TRUE`, caso contrario devuelve `FALSE`. Por ejemplo\n\n```{r}\ncond <- 11 > 1:10\nall(cond)\n```\n\nEn cambio, con solo haber un sólo elemento igual a `FALSE`, la función `all()` devuelve `FALSE`:\n\n```{r}\ncond <- 10 > 1:10\nall(cond)\n```\n\nLa función `any()`, devuelve `TRUE` si al menos un elemento del vector lógico es `TRUE`:\n\n```{r}\ncond <- 10 <= 1:10\nany(cond)\n```\n\nCaso contrario, si todos los elementos son iguales a `FALSE`, `any()` devuelve `FALSE`:\n\n```{r}\ncond <- 15 < 1:10\nany(cond)\n```\n\nFinalmente, es útil aclarar que en el contexto de operaciones aritméticas, `TRUE` equivale a `1` y `FALSE` equivale a `0`. Por ejemplo, sea la siguiente condición:\n\n```{r}\ncond <- 5 >= 1:10\ncond\n```\n\nSi sumamos los elementos del vector lógico, obtenemos lo siguiente:\n\n```{r}\nsum(cond)\n```\n\n¿De qué sirve conocer esto? Quizás no le veamos utilidad ahora mismo, pero puede llegar a ser útil en el contexto de un trabajo más avanzado (por ejemplo, en el contexto de manipulación de tablas).\n\n## Manipulación de vectores\n\nUn apartado fundamental para aprender a programar en R es la manipulación de vectores. En pocas palabras, nos referimos a generar un nuevo vector a partir de uno creado previamente, de manera tal que sirva para realizar una tarea específica. Este tipo de tareas será de gran utilidad a la hora de trabajar con tablas.\n\nDado un vector, interesa averiguar su contenido, lo cual lo podemos hacer simplemente imprimiendo el vector en la consola, o rescatando uno o más elementos a través de sus índices:\n\n```{r}\nvec <- seq(from = -5, to = 5, by = 0.25)\nvec[15]\nvec[c(1, 5, 10)]\nvec[13:18]\n```\n\nLos corchetes `[]` indican que se seleccionará un subconjunto de elementos del vector. En la segunda línea del ejemplo, seleccionamos el elemento de índice 15. En la tercera línea de código, seleccionamos los elementos de índice 1, 5 y 10. En la cuarta línea de código, en cambio, seleccionamos los elementos 13 al 18 (i.e. índices).\n\nEs posible excluir elementos con el símbolo `-`:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies_sub <- especies[-2]\nespecies_sub\n```\n\nAdemás de la posibilidad de indicar índices, es posible utilizar un vector lógico. Dicho vector puede generarse definiendo condiciones que los elementos deben cumplir.\n\n```{r}\ncond1 <- vec > -2 & vec < 2\ncond1\nvec_sub <- vec[cond1]\n```\n\nAquí, el objeto \"cond1\" es un vector lógico, indicando `TRUE` o `FALSE` para cada elemento del vector \"vec\", según la condición expuesta: que el número sea mayor a -2 (`vec > -2`) y (`&`) menor a 2 (`vec < 2`). Notar que hay que ser explícito a la hora de definir la condición. Es útil indicar la condición directamente, sin necesidad de crear un objeto nuevo:\n\n```{r}\nvec_sub <- vec[vec > -2 & vec < 2]\nvec_sub\n```\n\nLa función `subset()` permite hacer la misma operación de filtrado, indicando el vector a filtrar, y la condición:\n\n```{r}\nvec_sub <- subset(vec, vec > -2 & vec < 2)\nvec_sub\n```\n\nLa función `which()` devuelve los índices de los elementos de un vector que cumplen con una condición dada:\n\n```{r}\nwhich(vec > -2 & vec < 2)\n```\n\n**Para pensar:** Sin correr la expresión, ¿qué pasa si la condición que definimos es `!(vec > -2 & vec < 2)`?\n\nUna vez seleccionado el subconjunto de elementos de un vector, es posible asignarle un valor diferente:\n\n```{r}\nvec[vec <= 0] <- 0\n```\n\nAquí, seleccionamos los valores menores o iguales a 0, y les asignamos el valor 0. Notar que en este caso, al ser un único valor de reemplazo, no es necesario repetir el 0 tantas veces como valores a reemplazar.\n\nA veces, resulta útil reemplazar los valores `NA` (no dato) por algún otro valor útil, para lo cual podemos utilizar la función `is.na()`.\n\n```{r}\nvec <- c(5, 8, 16, NA, 3)\nvec[is.na(vec)] <- 0\nvec\n```\n\nEn el contexto de valores `NA`, es útil la función `na.omit()`, que remuevo todos los elementos que sean `NA`:\n\n```{r}\nvec <- c(5, 8, 16, NA, 3, 8, NA)\nvec2 <- na.omit(vec)\nvec2\n```\n\nA la hora de efectuar subconjuntos de vectores, es importante diferenciar el uso del operador `==` del `%in%`, que ya introdujimos anteriormente. Al utilizar el operador `==` nos preguntamos si cada elemento del vector indicado a la izquierda del operador es igual al elemento (o a los elementos) indicado a la derecha; y utilizamos la expresión lógica resultante para hacer el subset del vector:\n\n```{r}\nespecies <- rep(c(\"Algarrobo\", \"Molle\", \"Quebracho\", \"Piquillin\"), each = 5)\nespecies[especies == \"Quebracho\"]\n```\n\n¿Cómo procedemos si, por ejemplo, quisiéramos seleccionar más de una especie? El operador `==` ya no es útil por sí solo. Una opción es la siguiente:\n\n```{r}\nespecies[especies == \"Molle\" | especies == \"Piquillin\"]\n```\n\nOtra forma de hacerlo es utilizar el operador `%in%`. Recordemos que este operador indica `TRUE` o `FALSE` si cada elemento del vector a la izquierda *está contenido* en el vector indicado a la derecha:\n\n```{r}\nespecies[especies %in% c(\"Molle\", \"Piquillin\")]\n```\n\nComo veremos más adelante, el operador `%in%` es muy útil en el contexto de manipulación de tablas.\n\nEs posible añadir elementos a un vector con la función `c()`:\n\n```{r}\nespecies <- c(\"Algarrobo\", \"Quebracho\", \"Espinillo\")\nespecies <- c(especies, \"Yuchan\", \"Tusca\")\nespecies\n```\n\n**Para explorar:** La función `append()` es una forma de general de hacer esto. Explore `?append`.\n\n## Funciones básicas para vectores numéricos\n\nAnteriormente, hemos visto cómo trabajan las funciones `round()`, `ceiling()`, `floor()` and `trunc()` con números sueltos. Sin embargo, estas funciones, al igual que muchas otras funciones nativas de R, son *funciones vectorizadas*. Esto significa que pueden trabajar sobre un vector, y arrojar un resultado para cada uno de los elementos del vector.\n\nPor ejemplo:\n\n```{r}\nvec <- c(1.233, 1.924, 0.46)\nround(vec, digits = 1)\n```\n\nR también provee de numerosas funciones nativas para obtener medidas de resumen. Podemos mencionar a `mean()` para calcular el promedio, `median()` para calcular la mediana y `sd()` para calcular el desvío estándar.\n\n#### <ins>Ejercicio final</ins>\n\n1.  Utilice las funciones `rep()` y `seq()` para generar los siguientes vectores:\n\n-   Una sucesión de números pares de 15 elementos.\n-   Una sucesión de números decimales, con un incremento de 0.15.\n-   Un vector tipo `character`, que indique 4 categorías discretas, repetidas de a 3 cada una.\n-   Un vector que repita 5 veces el siguiente vector: `c(F, T, F, T)`.\n\n2.  Dado el vector `seq(from = 0, to = 1, by = 0.01)`, y utilizando los aprendido sobre manipulación de vectores y expresiones lógicas, genere nuevos vectores de acuerdo a los siguientes criterios:\n\n-   Que contenga los elementos de índices 10 a 20.\n-   Que excluya los elementos 30 a 50. Ayuda: utilice paréntesis.\n-   Que los elementos sean mayores a 0.5.\n-   Que los elementos sean menores o iguales a 0.3 *o* mayores a 0.7.\n-   Que los elementos cumplan con la condición opuesta a la inmediatamente anterior.\n\n3.  Genere un vector de 500 números provenientes de una distribución normal, de media 15 y desvío estándar 4. Para ello, utilice la función `rnorm()` (explore la ayuda mediante `?rnorm`). Seguidamente, verifique los valores de media, mediana y desvío estándar de la muestra. Calcule los cuantiles tradicionales mediante `quantile()`. Calculo el percentil 5% y el 95%.\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_vectores.png\" target=\"_blank\"><img src=\"pics/meme_practico_vectores.png\" style=\"padding: 5px 0 5px 0;width: 50rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"3.2_Vectores.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"En esta página","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copiar","copy-button-tooltip-success":"Copiado!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Volver arriba","search-no-results-text":"Sin resultados","search-matching-documents-text":"coincidencias","search-copy-link-title":"Copiar link para buscar","search-hide-matches-text":"No mostrar coincidencias adicionales","search-more-match-text":"otra coincidencia en este documento","search-more-matches-text":"más coincidencias en este documento","search-clear-button-title":"Limpiar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Buscar","search-label":"Buscar","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Cambiar a tema oscuro","toggle-reader-mode":"Cambiar a modo lectura","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":{"light":"cosmo","dark":["cosmo","../cosmo-dark.scss"]},"smooth-scroll":true,"title":"Vectores","pagetitle":"Vectores"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}