{"title":"Introducción a gráficos con *ggplot2*","markdown":{"yaml":{"title":"Introducción a gráficos con *ggplot2*","pagetitle":"Gráficos con ggplot2"},"headingText":"Otra lógica de programación","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n\nEl paquete *ggplot2* ofrece una nutrida biblioteca de funciones para la creación de gráficos de diversos tipos en R. La diversidad de gráficos y formas de personalización es enorme -es un curso en sí mismo- y aquí simplemente desarrollaremos los fundamentos básicos para su comprensión. Existen varias páginas web útiles para aprender sobre el desarrollo de gráficos con *ggplot2*, incluyendo a [The R Graph Gallery](https://r-graph-gallery.com/ggplot2-package.html){target=\"_blank\"} y [R Charts](https://r-charts.com/colors/){target=\"_blank\"}. En esta [página](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf){target=\"_blank\"} se muestra una tabla de colores junto con su nombre a utilizar dentro del entorno R.\n\nA diferencia de otros paquetes de graficación, incluyendo a las funciones nativas de R que ya hemos visto, la creación de gráficos con *ggplot2* sigue una lógica diferente. Se trabaja mediante la apilación de \"capas gráficas\" a través de un lenguaje propio del paquete. Si tradujéramos el código en palabras, sería algo así: \n\n*creo espacio de graficación &#8594;*<br>\n&nbsp;&nbsp;*añado capa gráfica nº1 (e.g. puntos) &#8594;*<br>\n&nbsp;&nbsp;*añado capa gráfica nº2 (e.g. líneas) &#8594;*<br>\n&nbsp;&nbsp;*configuro eje x &#8594;*<br>\n&nbsp;&nbsp;*configuro eje y &#8594;*<br>\n&nbsp;&nbsp;*configuro parámetros generales del gráfico*\n\nMejor que explicarlo, es mostrarlo!\n\nAntes que nada, es necesario cargar el paquete al entorno de R:\n\n```{r}\nlibrary(ggplot2)\n```\n\n### Funciones de tipo `geom`\n\nPara crear un nuevo gráfico, por ejemplo un simple gráfico de puntos, lo hacemos con el siguiente bloque de código:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n```\n\nLa primera línea llama a la función `ggplot()`. Esta función será el inicio de todos nuestros gráficos con *ggplot2*. Allí, indicamos el conjunto de datos que se utilizará para obtener los datos de graficación, típicamente un `data.frame`, en el argumento llamado `data`. El argumento `mapping` debe definirse a través de la función <u id='aes'>`aes()`</u>, dentro de la cual definimos las variables a graficar y su asociación a las columnas del `data.frame` indicado. Aquí indicamos que la variable `x` será \"Sepal.Length\" y la variable `y` \"Petal.Length\". Ambas son columnas del dataset `iris` indicado en el argumento `data`.\n\nSeguidamente a la primera línea observamos un `+`, y esta es la gran diferencia de la lógica de *ggplot2* respecto de otros paquetes. El operador `+` indica que seguido a él se añadirá una nueva *capa* al gráfico. Aquí, en la segunda línea (y está en la segunda línea por simple prolijidad, pero podría ir seguido en la primera línea), la función `geom_point()` indica que se añadirá un gráfico de nube de puntos (o scatterplot). En general, todas las funciones que comienzan con`geom_` refieren a tipos de gráficos particulares, entre ellas:\n\n-   `geom_point()`: puntos.\n-   `geom_line()`: líneas.\n-   `geom_bar()` y `geom_col()`: barras.\n-   `geom_boxplot()`: cajas (boxplots),\n\n**Para probar**: Escriba en la consola `geom_`, y espera a observar las sugerencias de funciones disponibles para la generación de distintos tipos de gráficos en *ggplot2*.\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"aes\", tooltip = '<span style=\"font-size:16px;\">El término viene del inglés \"aesthetic mappings\", lo que más o menos se traduce como \"mapeo gráfico de las variables\".</span>')\n```\n\nEl grado de personalización de los gráficos con *ggplot2* es inmenso. Por ejemplo, podemos cambiar el color, tamaño, forma y transparencia:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7)\n```\n\nSi comparamos los argumentos utilizados en *ggplot2* con los de los gráficos base de R, `size` es equivalente a `cex`, `col` vale para ambos enfoques, `fill` es equivalente a `bg` y `shape` es equivalente a `pch`.\n\nEl operador `+` permite agregar nuevas capas de información y personalización:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7) +\n  geom_hline(yintercept = mean(iris$Petal.Length), lty = \"dashed\") +\n  ggtitle(\"Scatterplot de ejemplo\")\n```\n\nLa función `geom_hline()` agrega una línea horizontal: el argumento `yintercept` indica el valor para `y` por donde pasará la línea, aquí indicado por el valor promedio de la variable `y`; el argumento `lty` permite elegir un estilo para la línea. La función `ggtitle()` añade un título.\n\n### Funciones de tipo `scale`\n\nLas funciones del tipo `scale_` son muy importantes, ya que permiten personalizar aspectos relacionados a las variables indicadas dentro de la función `aes()`. Aquí, con `scale_x_continuous()` indicamos un nombre para el eje x en el argumento `name`, los límites numéricos del eje con el argumento `limits` (vector de dos elementos, con valor mínimo y máximo) y los cortes del eje con el argumento `breaks` (vector numérico indicando dónde se ubicaran los cortes).\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\", limits = c(5, 7), breaks = seq(5, 7, 0.5)) +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n```\n\nNotar la advertencia generada. ¿Qué significa?\n\nAhora bien, el gráfico que venimos haciendo incluye a las variables florales de las tres especies de *Iris* provistas dentro del conjunto de datos. ¿Cómo hacemos para diferenciarlas en el gráfico? Debemos indicar una nueva variable dentro de `aes()`, asociada a un parámetro gráfico apropiado. En este contexto, lo mejor sería que los puntos tengan diferentes colores por especie:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n```\n\nNotar el agregado de la variable `color` asignada a la columna \"Species\" de nuestra tabla, así también como la no definición de un color fijo dentro de la función `geom_point()` (porque la idea es que haya un color distinto para cada especie). Aquí, bien podríamos haber definido otro parámetro gráfico a modificar según las distintas especies, tales como la forma (`shape`) o el tamaño (`size`). Volviendo a nuestro código anterior, ¿cómo definimos colores específicos para cada nivel? La función `scale_color_manual()` es la indicada:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n```\n\nLos colores se encuentran definidos en el argumento `values`. Los argumentos `name` y `labels` permiten modificar el nombre asignado para la leyenda, y las etiquetas para cada especie.\n\nPor otro lado, la función `geom_smooth()` añade líneas o curvas de tendencia para los datos. Aquí, el argumento `method = \"lm\"` indica que la línea a aproximar en la nube de puntos se calculará mediante una regresión lineal (\"linear model\"):\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n```\n\n### Boxplot\n\nVeamos ahora un gráfico de cajas, con la función `geom_boxplot()`:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot()\n```\n\nDentro de `aes()` definimos para `x` la variable discreta \"Species\" y para `y` la variable continua \"Petal.Length\". La incorporación del argumento `fill` indica colores distintos para cada especie.\n\n**Para jugar:** Cambie `fill` por `col` y observe los resultados.\n\nPara configurar aspectos del eje x de un boxplot, `scale_x_continuos()` no servirá, porque la variable definida para `x` no es continua (son especies). La función adecuada es `scale_x_discrete()`:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n```\n\n**Para observar:** Vea también los otros cambios incorporados al gráfico y asocie esos cambios con cada línea de código.\n\nLa función `geom_jitter()` permite agregar una nube de puntos, las observaciones, pero dispuestas de manera *aleatoria* a lo largo de uno o ambos ejes:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3, outliers = FALSE) +\n  geom_jitter(shape = 21, height = 0, width = 0.3, alpha = 0.4) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n```\n\nAl indicar `height = 0`, los puntos mantendrán la ubicación original para la variable `y`. En cambio, `width = 0.3` reubica *aleatoriamente* cada punto a lo largo del eje `x`. El valor 0.3 simplemente indica el nivel de *ruido*, en este caso horizontal, que tendrá cada punto.\n\n#### <ins>Ejercicio 1</ins>\n\nGenere un gráfico idéntico al último expuesto, pero con un orden distinto para los niveles del eje x. El orden debe ser, de izquierda a derecha, *I. virginica*, *I. versicolor* e *I. setosa*. Para ello, debe redefinir la variable \"Species\" de la tabla como un factor con niveles en el orden indicado. Si no se acuerda como hacerlo, vuelva a la clase de [Vectores](../dia1/3.2_Vectores.qmd).\n\n### Funciones de tipo `theme`\n\nLas funciones que inician con `theme` permiten la personalización general del gráfico. Por un lado, contamos con funciones como `theme_light()`, las cuales vienen asociadas con configuraciones gráficas preestablecidas. Por otro lado, la función `theme()` permite un grado de personalización del gráfico muy alta. Por ejemplo:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = NULL, \n                     labels = c(expression(italic(\"I. setosa\")), \n                                expression(italic(\"I. versicolor\")), \n                                expression(italic(\"I. virginica\"))), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  annotate(\"text\", x = 4, y = 6.5, label = \"p < 0.05\", hjust = 0) +\n  theme_light() +\n  theme(aspect.ratio = 9/16, legend.position = \"bottom\")\n```\n\nUn primer aspecto a considerar es el orden de las nuevas capas añadidas. Notar que primero se agregó `theme_light()`, luego `theme()`. Esto es importante porque, de haberlo hecho al revés, las personalizaciones hechas en `theme()` hubieran sido reemplazadas por la configuración preestablecida de `theme_light()`.\n\nDentro de `theme()`, es posible indicar una gran cantidad de argumentos (ver `?theme`). Entre ellos, el argumento `aspect.ratio` es muy útil, ya que permite establecer la relación de aspecto de la figura. Asimismo, con `legend.position = \"bottom\"` se indica que la leyenda se ubique en la parte baja de la figura.\n\nVale la pena mencionar la nueva capa añadida mediante `annotate()`, la cual sirve para añadir información al gráfico de manera directa (sin necesidad de referencias a un dataset). En el ejemplo, se utilizó para agregar texto, pero también sirve para agregar líneas o segmentos, entre otros.\n\n**Para observar:** Además de lo ya explicado, ¿qué otras cosas cambiaron en el último gráfico respecto del anterior? ¿Qué líneas de código son las responsables de ello?\n\n**Para jugar:** Cambie `theme_light()` por otras funciones del tipo con otras configuraciones preestablecida y observe los distintos resultados.\n\n### Ejemplo de caso típico: gráficos de barras con error\n\nUn gráfico muy popular es el gráfico de barras con error asociado. Usualmente, la barra indica un valor promedio y la barra de error el error estándar o la desviación estándar. ¿Cómo haríamos este gráfico en *ggplot2*? Primero, es necesario generar un `data.frame` con los valores promedio y de error asociados (en este ejemplo, la desviación estándar). Lo haremos para cada especie del género *Iris*:\n\n```{r}\niris_agg1 <- aggregate(Petal.Width ~ Species, data = iris, mean)\ncolnames(iris_agg1)[2] <- \"Petal.Width.mean\"\niris_agg2 <- aggregate(Petal.Width ~ Species, data = iris, sd)\ncolnames(iris_agg2)[2] <- \"Petal.Width.sd\"\niris_agg_3 <- merge(iris_agg1, iris_agg2, by = \"Species\")\niris_agg_3\n```\n\nLuego, la función adecuada para generar la barra es `geom_col()`, mientras que para la barra de error utilizamos `geom_errorbar`:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris_agg_3, aes(x = Species)) +\n  geom_col(aes(y = Petal.Width.mean)) +\n  geom_errorbar(aes(ymin = Petal.Width.mean - Petal.Width.sd, \n                    ymax = Petal.Width.mean + Petal.Width.sd), \n                width = 0.3)\n```\n\nEste ejemplo también sirve para mostrar cómo podemos distribuir variables indicadas en `aes()`, no sólamente en el inicio del gráfico con la función `ggplot()`, sino también en particular sobre las nuevas capas gráficas añadidas. En este ejemplo, la variable `x` es la misma para todas las capas (la barra y la barra de error), por lo que se la indica en la función principal, y dicha variable vale para todos las capas subsiguientes del gráfico. Luego, para `geom_col()`, indicamos la variable `y` asociada al promedio calculado. Finalmente, definimos máximos y mínimos de la barra de error dentro de `aes()` de `geom_errorbar()`, con los argumentos específicos `ymin` y `ymax`.\n\n## Asignación de gráficos a objetos\n\nLos gráficos de *ggplot2* pueden asignarse a objetos. La ventaja de ello es que el nuevo objeto creado queda guardado en el entorno, y el gráfico puede personalizarse en el futuro haciendo referencia al objeto creado.\n\n```{r}\nplot1 <- ggplot(iris, aes(x = Petal.Width))\n```\n\nAquí, al objeto `plot1` le es asignado a un gráfico que aún no posee *capas gráficas*, pero sí posee una tabla asociada y una variable `x` asociada a una columna de esa tabla. Podemos hacer uso del nuevo objeto y el operador `+` para añadir nuevas capas y personalizaciones al gráfico:\n\n```{r}\nplot1 <- plot1 + \n  geom_histogram() +\n  theme_bw()\n```\n\nEl gráfico puede ser mostrado en el panel simplemente llamando al objeto:\n\n```{r fig.align='center', fig.width=5, fig.height=4,message=FALSE}\nplot1\n```\n\nEn *ggplot2*, los histogramas son generados mediante la función `geom_histogram()`.\n\nUna de las ventajas de asignar gráficos a objetos es que, una vez creado el objeto, es posible trabajar en otras tareas asociadas para obtener alguna información relevante, que será luego utilizada para continuar personalizando el gráfico.\n\nUna situación común del flujo de trabajo de nuestras investigaciones consiste en generar un panel de gráficos de manera automática, sin recurrir a software externos a R. Por ejemplo, además del objeto `plot1`, creemos otros tres gráficos similares pero con otras variables:\n\n```{r}\nplot2 <- ggplot(iris, aes(x = Petal.Length)) +\n  geom_histogram() +\n  theme_bw()\n\nplot3 <- ggplot(iris, aes(x = Sepal.Width)) +\n  geom_histogram() +\n  theme_bw()\n\nplot4 <- ggplot(iris, aes(x = Sepal.Length)) +\n  geom_histogram() +\n  theme_bw()\n```\n\nPara crear un panel con *ggplot2*, la función `par()` utilizada para gráficos nativos de R no nos servirá. Existen otras funciones asociadas que permiten hacerlo, entre ellas, la función `ggarrange()` del paquete `egg`:\n\n```{r fig.align='center', fig.width=4, fig.height=4,message=FALSE,warning=FALSE}\nlibrary(egg)\nggarrange(plot1, plot2, plot3, plot4, ncol = 2, nrow = 2)\n```\n\nSimplemente se indican los objetos asociados a los gráficos, junto con la cantidad de columnas y filas, como si fuera una *matriz* con espacios vacíos a ser rellenados por cada gráfico (aquí, una matriz de 2x2).\n\nLa función `ggarrange()` del paquete `egg` es una de muchas formas de generar paneles con gráficos de *ggplot2*. También podemos mencionar a la función `plot_grid()` del paquete `cowplot` y a `grid.arrange()` del paquete `gridExtra`.\n\n## Exportación de gráficos\n\nExisten varias formas de exportar los gráficos de *ggplot2*. Una de ellas es a través de la interfaz gráfica de RStudio, en el panel de gráficos. Otra opción es encerrar el bloque de código de la siguiente manera, y correr todo el bloque a la vez, bloque de código que también es válido para gráficos en `R base`:\n\n```{r results=FALSE,eval=FALSE,message=FALSE}\npng(filename = \"dia4/scatterplot.png\", width = 1200, height = 1000, res = 300)\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\ndev.off()\n```\n\nComo podemos observar, entre otros argumentos, es posible indicar el ancho, largo y la resolución (en <u id='ppi'>ppi</u>). Otras alternativas a `png()` son `jpeg()` y `tiff()`.\n\nOtra alternativa es utilizar la función `ggsave()`, por ejemplo:\n\n```{r eval=FALSE}\nggsave(filename = \"dia4/scatterplot.png\", dpi = 600, units = \"px\")\n```\n\nAl no especificar qué gráfico exportar, se exporta el último gráfico devuelto en el panel de gráficos. De lo contrario, es posible indicar explícitamente qué gráfico exportar:\n\n```{r eval=FALSE}\nplot5 <- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  theme(aspect.ratio = 3/4)\n\nggsave(filename = \"scatterplot.png\", plot = plot5, dpi = 600, units = \"px\")\n```\n\n#### <ins>Ejercicios</ins>\n\nEl dataset `Indometh` contiene los datos de concentración en sangre de una droga en función del tiempo para 6 sujetos (para mayor información sobre el dataset, explore la ayuda con `?Indometh`). Antes que nada, explore el dataset, su estructura y tipo de dato.\n\n1.  Genere un gráfico de líneas que relacione la concentración de la droga en sangre en función del tiempo, pero diferencie las tendencias entre sujetos con colores diferentes de líneas. Incremente el grosor de cada línea lo que considere suficiente. Indique el título \"(a)\" para el gráfico. Coloque nombres, en español, a los ejes y a la leyenda. Inserte una línea vertical discontinua pasando por el valor `x = 1`. Establezca la relación de aspecto en 9/16.\n\nLos niveles de la columna \"Subject\" están desordenados. ¿Por qué? Arreglar eso!\n\n2.  Genere un gráfico relacionando las mismas variables que el anterior, pero haciendo un *zoom* a una región particular del gráfico. Para ello, el código será casi idéntico al gráfico anterior, pero además deberá utilizar la función `coord_fixed()`, en donde deberá indicar la región del gráfico de interés (explore ?coord_fixed sobre cómo hacer esto). La región donde hará *zoom* será la de mayor variación de cambio entre la concentración de la droga en sangre y el tiempo. Indique el título \"(b)\" para el gráfico.\n\n3.  Genere un panel con los gráficos anteriores, a la izquierda el gráfico del punto 1 y a la derecha el del punto 2. El panel, al estar compuesto por gráficos individuales, posiblemente contenga información redundante: el nombre para el eje vertical y la leyenda (está repetida). No es necesario repetir la información. Arreglar eso!\n\n4.  Exporte el panel gráfico con una resolución de 300 ppi dentro de la carpeta \"dia4\" del proyecto del curso. Para ello, explore `?png`.\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"ppi\", tooltip = '<span style=\"font-size:16px;\">\"points per inch\" o \"puntos por pulgada\" en español. Análogo a \"dpi\" (\"dots per inch\").</span>')\n```\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_ggplot2.png\" target=\"_blank\"><img src=\"pics/meme_practico_ggplot2.png\" style=\"padding: 5px 0 5px 0;width: 50rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n## Otra lógica de programación\n\nEl paquete *ggplot2* ofrece una nutrida biblioteca de funciones para la creación de gráficos de diversos tipos en R. La diversidad de gráficos y formas de personalización es enorme -es un curso en sí mismo- y aquí simplemente desarrollaremos los fundamentos básicos para su comprensión. Existen varias páginas web útiles para aprender sobre el desarrollo de gráficos con *ggplot2*, incluyendo a [The R Graph Gallery](https://r-graph-gallery.com/ggplot2-package.html){target=\"_blank\"} y [R Charts](https://r-charts.com/colors/){target=\"_blank\"}. En esta [página](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf){target=\"_blank\"} se muestra una tabla de colores junto con su nombre a utilizar dentro del entorno R.\n\nA diferencia de otros paquetes de graficación, incluyendo a las funciones nativas de R que ya hemos visto, la creación de gráficos con *ggplot2* sigue una lógica diferente. Se trabaja mediante la apilación de \"capas gráficas\" a través de un lenguaje propio del paquete. Si tradujéramos el código en palabras, sería algo así: \n\n*creo espacio de graficación &#8594;*<br>\n&nbsp;&nbsp;*añado capa gráfica nº1 (e.g. puntos) &#8594;*<br>\n&nbsp;&nbsp;*añado capa gráfica nº2 (e.g. líneas) &#8594;*<br>\n&nbsp;&nbsp;*configuro eje x &#8594;*<br>\n&nbsp;&nbsp;*configuro eje y &#8594;*<br>\n&nbsp;&nbsp;*configuro parámetros generales del gráfico*\n\nMejor que explicarlo, es mostrarlo!\n\nAntes que nada, es necesario cargar el paquete al entorno de R:\n\n```{r}\nlibrary(ggplot2)\n```\n\n### Funciones de tipo `geom`\n\nPara crear un nuevo gráfico, por ejemplo un simple gráfico de puntos, lo hacemos con el siguiente bloque de código:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n```\n\nLa primera línea llama a la función `ggplot()`. Esta función será el inicio de todos nuestros gráficos con *ggplot2*. Allí, indicamos el conjunto de datos que se utilizará para obtener los datos de graficación, típicamente un `data.frame`, en el argumento llamado `data`. El argumento `mapping` debe definirse a través de la función <u id='aes'>`aes()`</u>, dentro de la cual definimos las variables a graficar y su asociación a las columnas del `data.frame` indicado. Aquí indicamos que la variable `x` será \"Sepal.Length\" y la variable `y` \"Petal.Length\". Ambas son columnas del dataset `iris` indicado en el argumento `data`.\n\nSeguidamente a la primera línea observamos un `+`, y esta es la gran diferencia de la lógica de *ggplot2* respecto de otros paquetes. El operador `+` indica que seguido a él se añadirá una nueva *capa* al gráfico. Aquí, en la segunda línea (y está en la segunda línea por simple prolijidad, pero podría ir seguido en la primera línea), la función `geom_point()` indica que se añadirá un gráfico de nube de puntos (o scatterplot). En general, todas las funciones que comienzan con`geom_` refieren a tipos de gráficos particulares, entre ellas:\n\n-   `geom_point()`: puntos.\n-   `geom_line()`: líneas.\n-   `geom_bar()` y `geom_col()`: barras.\n-   `geom_boxplot()`: cajas (boxplots),\n\n**Para probar**: Escriba en la consola `geom_`, y espera a observar las sugerencias de funciones disponibles para la generación de distintos tipos de gráficos en *ggplot2*.\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"aes\", tooltip = '<span style=\"font-size:16px;\">El término viene del inglés \"aesthetic mappings\", lo que más o menos se traduce como \"mapeo gráfico de las variables\".</span>')\n```\n\nEl grado de personalización de los gráficos con *ggplot2* es inmenso. Por ejemplo, podemos cambiar el color, tamaño, forma y transparencia:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7)\n```\n\nSi comparamos los argumentos utilizados en *ggplot2* con los de los gráficos base de R, `size` es equivalente a `cex`, `col` vale para ambos enfoques, `fill` es equivalente a `bg` y `shape` es equivalente a `pch`.\n\nEl operador `+` permite agregar nuevas capas de información y personalización:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, shape = 18, alpha = 0.7) +\n  geom_hline(yintercept = mean(iris$Petal.Length), lty = \"dashed\") +\n  ggtitle(\"Scatterplot de ejemplo\")\n```\n\nLa función `geom_hline()` agrega una línea horizontal: el argumento `yintercept` indica el valor para `y` por donde pasará la línea, aquí indicado por el valor promedio de la variable `y`; el argumento `lty` permite elegir un estilo para la línea. La función `ggtitle()` añade un título.\n\n### Funciones de tipo `scale`\n\nLas funciones del tipo `scale_` son muy importantes, ya que permiten personalizar aspectos relacionados a las variables indicadas dentro de la función `aes()`. Aquí, con `scale_x_continuous()` indicamos un nombre para el eje x en el argumento `name`, los límites numéricos del eje con el argumento `limits` (vector de dos elementos, con valor mínimo y máximo) y los cortes del eje con el argumento `breaks` (vector numérico indicando dónde se ubicaran los cortes).\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point(color = \"forestgreen\", size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\", limits = c(5, 7), breaks = seq(5, 7, 0.5)) +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n```\n\nNotar la advertencia generada. ¿Qué significa?\n\nAhora bien, el gráfico que venimos haciendo incluye a las variables florales de las tres especies de *Iris* provistas dentro del conjunto de datos. ¿Cómo hacemos para diferenciarlas en el gráfico? Debemos indicar una nueva variable dentro de `aes()`, asociada a un parámetro gráfico apropiado. En este contexto, lo mejor sería que los puntos tengan diferentes colores por especie:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\")\n```\n\nNotar el agregado de la variable `color` asignada a la columna \"Species\" de nuestra tabla, así también como la no definición de un color fijo dentro de la función `geom_point()` (porque la idea es que haya un color distinto para cada especie). Aquí, bien podríamos haber definido otro parámetro gráfico a modificar según las distintas especies, tales como la forma (`shape`) o el tamaño (`size`). Volviendo a nuestro código anterior, ¿cómo definimos colores específicos para cada nivel? La función `scale_color_manual()` es la indicada:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n```\n\nLos colores se encuentran definidos en el argumento `values`. Los argumentos `name` y `labels` permiten modificar el nombre asignado para la leyenda, y las etiquetas para cada especie.\n\nPor otro lado, la función `geom_smooth()` añade líneas o curvas de tendencia para los datos. Aquí, el argumento `method = \"lm\"` indica que la línea a aproximar en la nube de puntos se calculará mediante una regresión lineal (\"linear model\"):\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\n```\n\n### Boxplot\n\nVeamos ahora un gráfico de cajas, con la función `geom_boxplot()`:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot()\n```\n\nDentro de `aes()` definimos para `x` la variable discreta \"Species\" y para `y` la variable continua \"Petal.Length\". La incorporación del argumento `fill` indica colores distintos para cada especie.\n\n**Para jugar:** Cambie `fill` por `col` y observe los resultados.\n\nPara configurar aspectos del eje x de un boxplot, `scale_x_continuos()` no servirá, porque la variable definida para `x` no es continua (son especies). La función adecuada es `scale_x_discrete()`:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n```\n\n**Para observar:** Vea también los otros cambios incorporados al gráfico y asocie esos cambios con cada línea de código.\n\nLa función `geom_jitter()` permite agregar una nube de puntos, las observaciones, pero dispuestas de manera *aleatoria* a lo largo de uno o ambos ejes:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris, mapping = aes(x = Species, y = Petal.Length, fill = Species)) +\n  geom_boxplot(width = 0.3, staplewidth = 0.3, outliers = FALSE) +\n  geom_jitter(shape = 21, height = 0, width = 0.3, alpha = 0.4) +\n  scale_x_discrete(name = \"Especie\", labels = c(expression(italic(\"I. setosa\")), \n                                                expression(italic(\"I. versicolor\")), \n                                                expression(italic(\"I. virginica\")))) +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  theme_classic() +\n  theme(legend.position = \"none\", aspect.ratio = 1)\n```\n\nAl indicar `height = 0`, los puntos mantendrán la ubicación original para la variable `y`. En cambio, `width = 0.3` reubica *aleatoriamente* cada punto a lo largo del eje `x`. El valor 0.3 simplemente indica el nivel de *ruido*, en este caso horizontal, que tendrá cada punto.\n\n#### <ins>Ejercicio 1</ins>\n\nGenere un gráfico idéntico al último expuesto, pero con un orden distinto para los niveles del eje x. El orden debe ser, de izquierda a derecha, *I. virginica*, *I. versicolor* e *I. setosa*. Para ello, debe redefinir la variable \"Species\" de la tabla como un factor con niveles en el orden indicado. Si no se acuerda como hacerlo, vuelva a la clase de [Vectores](../dia1/3.2_Vectores.qmd).\n\n### Funciones de tipo `theme`\n\nLas funciones que inician con `theme` permiten la personalización general del gráfico. Por un lado, contamos con funciones como `theme_light()`, las cuales vienen asociadas con configuraciones gráficas preestablecidas. Por otro lado, la función `theme()` permite un grado de personalización del gráfico muy alta. Por ejemplo:\n\n```{r fig.align='center', fig.width=5, fig.height=4}\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = NULL, \n                     labels = c(expression(italic(\"I. setosa\")), \n                                expression(italic(\"I. versicolor\")), \n                                expression(italic(\"I. virginica\"))), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  annotate(\"text\", x = 4, y = 6.5, label = \"p < 0.05\", hjust = 0) +\n  theme_light() +\n  theme(aspect.ratio = 9/16, legend.position = \"bottom\")\n```\n\nUn primer aspecto a considerar es el orden de las nuevas capas añadidas. Notar que primero se agregó `theme_light()`, luego `theme()`. Esto es importante porque, de haberlo hecho al revés, las personalizaciones hechas en `theme()` hubieran sido reemplazadas por la configuración preestablecida de `theme_light()`.\n\nDentro de `theme()`, es posible indicar una gran cantidad de argumentos (ver `?theme`). Entre ellos, el argumento `aspect.ratio` es muy útil, ya que permite establecer la relación de aspecto de la figura. Asimismo, con `legend.position = \"bottom\"` se indica que la leyenda se ubique en la parte baja de la figura.\n\nVale la pena mencionar la nueva capa añadida mediante `annotate()`, la cual sirve para añadir información al gráfico de manera directa (sin necesidad de referencias a un dataset). En el ejemplo, se utilizó para agregar texto, pero también sirve para agregar líneas o segmentos, entre otros.\n\n**Para observar:** Además de lo ya explicado, ¿qué otras cosas cambiaron en el último gráfico respecto del anterior? ¿Qué líneas de código son las responsables de ello?\n\n**Para jugar:** Cambie `theme_light()` por otras funciones del tipo con otras configuraciones preestablecida y observe los distintos resultados.\n\n### Ejemplo de caso típico: gráficos de barras con error\n\nUn gráfico muy popular es el gráfico de barras con error asociado. Usualmente, la barra indica un valor promedio y la barra de error el error estándar o la desviación estándar. ¿Cómo haríamos este gráfico en *ggplot2*? Primero, es necesario generar un `data.frame` con los valores promedio y de error asociados (en este ejemplo, la desviación estándar). Lo haremos para cada especie del género *Iris*:\n\n```{r}\niris_agg1 <- aggregate(Petal.Width ~ Species, data = iris, mean)\ncolnames(iris_agg1)[2] <- \"Petal.Width.mean\"\niris_agg2 <- aggregate(Petal.Width ~ Species, data = iris, sd)\ncolnames(iris_agg2)[2] <- \"Petal.Width.sd\"\niris_agg_3 <- merge(iris_agg1, iris_agg2, by = \"Species\")\niris_agg_3\n```\n\nLuego, la función adecuada para generar la barra es `geom_col()`, mientras que para la barra de error utilizamos `geom_errorbar`:\n\n```{r fig.align='center', fig.width=4, fig.height=4}\nggplot(data = iris_agg_3, aes(x = Species)) +\n  geom_col(aes(y = Petal.Width.mean)) +\n  geom_errorbar(aes(ymin = Petal.Width.mean - Petal.Width.sd, \n                    ymax = Petal.Width.mean + Petal.Width.sd), \n                width = 0.3)\n```\n\nEste ejemplo también sirve para mostrar cómo podemos distribuir variables indicadas en `aes()`, no sólamente en el inicio del gráfico con la función `ggplot()`, sino también en particular sobre las nuevas capas gráficas añadidas. En este ejemplo, la variable `x` es la misma para todas las capas (la barra y la barra de error), por lo que se la indica en la función principal, y dicha variable vale para todos las capas subsiguientes del gráfico. Luego, para `geom_col()`, indicamos la variable `y` asociada al promedio calculado. Finalmente, definimos máximos y mínimos de la barra de error dentro de `aes()` de `geom_errorbar()`, con los argumentos específicos `ymin` y `ymax`.\n\n## Asignación de gráficos a objetos\n\nLos gráficos de *ggplot2* pueden asignarse a objetos. La ventaja de ello es que el nuevo objeto creado queda guardado en el entorno, y el gráfico puede personalizarse en el futuro haciendo referencia al objeto creado.\n\n```{r}\nplot1 <- ggplot(iris, aes(x = Petal.Width))\n```\n\nAquí, al objeto `plot1` le es asignado a un gráfico que aún no posee *capas gráficas*, pero sí posee una tabla asociada y una variable `x` asociada a una columna de esa tabla. Podemos hacer uso del nuevo objeto y el operador `+` para añadir nuevas capas y personalizaciones al gráfico:\n\n```{r}\nplot1 <- plot1 + \n  geom_histogram() +\n  theme_bw()\n```\n\nEl gráfico puede ser mostrado en el panel simplemente llamando al objeto:\n\n```{r fig.align='center', fig.width=5, fig.height=4,message=FALSE}\nplot1\n```\n\nEn *ggplot2*, los histogramas son generados mediante la función `geom_histogram()`.\n\nUna de las ventajas de asignar gráficos a objetos es que, una vez creado el objeto, es posible trabajar en otras tareas asociadas para obtener alguna información relevante, que será luego utilizada para continuar personalizando el gráfico.\n\nUna situación común del flujo de trabajo de nuestras investigaciones consiste en generar un panel de gráficos de manera automática, sin recurrir a software externos a R. Por ejemplo, además del objeto `plot1`, creemos otros tres gráficos similares pero con otras variables:\n\n```{r}\nplot2 <- ggplot(iris, aes(x = Petal.Length)) +\n  geom_histogram() +\n  theme_bw()\n\nplot3 <- ggplot(iris, aes(x = Sepal.Width)) +\n  geom_histogram() +\n  theme_bw()\n\nplot4 <- ggplot(iris, aes(x = Sepal.Length)) +\n  geom_histogram() +\n  theme_bw()\n```\n\nPara crear un panel con *ggplot2*, la función `par()` utilizada para gráficos nativos de R no nos servirá. Existen otras funciones asociadas que permiten hacerlo, entre ellas, la función `ggarrange()` del paquete `egg`:\n\n```{r fig.align='center', fig.width=4, fig.height=4,message=FALSE,warning=FALSE}\nlibrary(egg)\nggarrange(plot1, plot2, plot3, plot4, ncol = 2, nrow = 2)\n```\n\nSimplemente se indican los objetos asociados a los gráficos, junto con la cantidad de columnas y filas, como si fuera una *matriz* con espacios vacíos a ser rellenados por cada gráfico (aquí, una matriz de 2x2).\n\nLa función `ggarrange()` del paquete `egg` es una de muchas formas de generar paneles con gráficos de *ggplot2*. También podemos mencionar a la función `plot_grid()` del paquete `cowplot` y a `grid.arrange()` del paquete `gridExtra`.\n\n## Exportación de gráficos\n\nExisten varias formas de exportar los gráficos de *ggplot2*. Una de ellas es a través de la interfaz gráfica de RStudio, en el panel de gráficos. Otra opción es encerrar el bloque de código de la siguiente manera, y correr todo el bloque a la vez, bloque de código que también es válido para gráficos en `R base`:\n\n```{r results=FALSE,eval=FALSE,message=FALSE}\npng(filename = \"dia4/scatterplot.png\", width = 1200, height = 1000, res = 300)\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\"))\ndev.off()\n```\n\nComo podemos observar, entre otros argumentos, es posible indicar el ancho, largo y la resolución (en <u id='ppi'>ppi</u>). Otras alternativas a `png()` son `jpeg()` y `tiff()`.\n\nOtra alternativa es utilizar la función `ggsave()`, por ejemplo:\n\n```{r eval=FALSE}\nggsave(filename = \"dia4/scatterplot.png\", dpi = 600, units = \"px\")\n```\n\nAl no especificar qué gráfico exportar, se exporta el último gráfico devuelto en el panel de gráficos. De lo contrario, es posible indicar explícitamente qué gráfico exportar:\n\n```{r eval=FALSE}\nplot5 <- ggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)) +\n  geom_point(size = 3, alpha = 0.5) +\n  geom_smooth(method = \"lm\") +\n  ggtitle(\"Scatterplot de ejemplo\") +\n  scale_x_continuous(name = \"Longitud del sépalo\") +\n  scale_y_continuous(name = \"Longitud del pétalo\") +\n  scale_color_manual(name = \"Especie\", \n                     labels = c(\"I. setosa\", \"I. versicolor\", \"I. virginica\"), \n                     values = c(\"forestgreen\", \"firebrick\", \"blue3\")) +\n  theme(aspect.ratio = 3/4)\n\nggsave(filename = \"scatterplot.png\", plot = plot5, dpi = 600, units = \"px\")\n```\n\n#### <ins>Ejercicios</ins>\n\nEl dataset `Indometh` contiene los datos de concentración en sangre de una droga en función del tiempo para 6 sujetos (para mayor información sobre el dataset, explore la ayuda con `?Indometh`). Antes que nada, explore el dataset, su estructura y tipo de dato.\n\n1.  Genere un gráfico de líneas que relacione la concentración de la droga en sangre en función del tiempo, pero diferencie las tendencias entre sujetos con colores diferentes de líneas. Incremente el grosor de cada línea lo que considere suficiente. Indique el título \"(a)\" para el gráfico. Coloque nombres, en español, a los ejes y a la leyenda. Inserte una línea vertical discontinua pasando por el valor `x = 1`. Establezca la relación de aspecto en 9/16.\n\nLos niveles de la columna \"Subject\" están desordenados. ¿Por qué? Arreglar eso!\n\n2.  Genere un gráfico relacionando las mismas variables que el anterior, pero haciendo un *zoom* a una región particular del gráfico. Para ello, el código será casi idéntico al gráfico anterior, pero además deberá utilizar la función `coord_fixed()`, en donde deberá indicar la región del gráfico de interés (explore ?coord_fixed sobre cómo hacer esto). La región donde hará *zoom* será la de mayor variación de cambio entre la concentración de la droga en sangre y el tiempo. Indique el título \"(b)\" para el gráfico.\n\n3.  Genere un panel con los gráficos anteriores, a la izquierda el gráfico del punto 1 y a la derecha el del punto 2. El panel, al estar compuesto por gráficos individuales, posiblemente contenga información redundante: el nombre para el eje vertical y la leyenda (está repetida). No es necesario repetir la información. Arreglar eso!\n\n4.  Exporte el panel gráfico con una resolución de 300 ppi dentro de la carpeta \"dia4\" del proyecto del curso. Para ello, explore `?png`.\n\n```{r, echo=FALSE}\ntippy::tippy_this(elementId = \"ppi\", tooltip = '<span style=\"font-size:16px;\">\"points per inch\" o \"puntos por pulgada\" en español. Análogo a \"dpi\" (\"dots per inch\").</span>')\n```\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_ggplot2.png\" target=\"_blank\"><img src=\"pics/meme_practico_ggplot2.png\" style=\"padding: 5px 0 5px 0;width: 50rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../styles.css"],"toc":true,"output-file":"6.2_ggplot2.html"},"language":{"toc-title-document":"Tabla de contenidos","toc-title-website":"En esta página","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copiar","copy-button-tooltip-success":"Copiado!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Volver arriba","search-no-results-text":"Sin resultados","search-matching-documents-text":"coincidencias","search-copy-link-title":"Copiar link para buscar","search-hide-matches-text":"No mostrar coincidencias adicionales","search-more-match-text":"otra coincidencia en este documento","search-more-matches-text":"más coincidencias en este documento","search-clear-button-title":"Limpiar","search-text-placeholder":"","search-detached-cancel-button-title":"Cancelar","search-submit-button-title":"Buscar","search-label":"Buscar","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Cambiar a tema oscuro","toggle-reader-mode":"Cambiar a modo lectura","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":{"light":"cosmo","dark":["cosmo","../cosmo-dark.scss"]},"smooth-scroll":true,"title":"Introducción a gráficos con *ggplot2*","pagetitle":"Gráficos con ggplot2"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}