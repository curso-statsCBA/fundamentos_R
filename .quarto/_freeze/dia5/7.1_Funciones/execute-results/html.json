{
  "hash": "19fd55845cf6af82cce92284fc02d078",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Funciones\"\npagetitle: \"Funciones\"\n---\n\n\n\n\n\n\n## ¿Cómo creo una función?\n\nLas funciones en R son las herramientas que nos permiten realizar una gran diversidad de análisis. Para ello, R provee de una numerosa y potente biblioteca de ellas, las cuales vienen instalada por defecto. Además, como hemos desarrollado al principio del curso, existe una abanico mega-diverso de paquetes de R desarrollados por los propios usuarios, especialmente desarrollados para la realización de tareas específicas.\n\nNo obstante, es usual que en un flujo de trabajo de intermedio a avanzado necesitemos desarrollar nuestras propias funciones. La razón para ello radica en la ejecución de una tarea muy específica como parte de nuestros análisis, pero que al mismo tiempo debe realizarse múltiples veces para que amerite su desarrollo en forma de función.\n\nLas funciones en R se asignan a objetos, cuyo nombre será el nombre de la función, con la expresión `function()`. Dentro de los paréntesis debemos indicar los argumentos de la función. Estos serán los objetos con los que la función trabajará de alguna manera, y devolverá alguna salida determinada. La sintaxis general es la siguiente:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_funcion <- function(argumento1, argumento2, argumento3){\n  # Inserte aqui el codigo que trabajara con los objetos definidos en los argumentos,\n  # junto con la salida que se propone para la nueva funcion\n}\n```\n:::\n\n\n\n\nPor ejemplo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblabla <- function(nombre = \"- inserte aquí su nombre -\"){\n  print(paste(\"Mi nombre es\", nombre, \"y me encanta el curso de Fundamentos básicos del lenguaje R.\"))\n}\n```\n:::\n\n\n\n\nAl correr el bloque de código anterior, simplemente estamos *creando* la función, y no *corriendo* el código programado. Esta se carga como un objeto propio en el entorno, quedando disponible para su uso futuro.\n\nEn este ejemplo, el argumento `nombre` se encuentra asignado a una línea de texto. De esta manera, la función entiende que el valor indicado es el **valor por defecto**, para los casos los que el usuario no define un valor particular para dicho argumento. La definición de valores por defecto no es obligatoria, pero puede ser útil en muchos casos. Si corremos dicha función suelta, sin definir nada en específico, podemos observar el resultado:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblabla()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mi nombre es - inserte aquí su nombre - y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n```\n\n\n:::\n:::\n\n\n\n\nEn cambio, podemos asignarle un valor al argumento `nombre`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblabla(nombre = \"Lionel Scaloni\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mi nombre es Lionel Scaloni y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n```\n\n\n:::\n:::\n\n\n\n\n### Unas palabritas sobre *entornos*\n\nUna cuestión a considerar en el contexto de creación de funciones es el uso que las mismas hacen de los *entornos*. Podemos definir a un entorno como al *espacio* en donde se guardan nuestros objetos. Cuando creamos un objeto, sea una tabla, un vector, una función o cualquier otro, estos se guardan en el *entorno global*, y de hecho aparecen visibles en el panel correspondiente de la interfaz de RStudio. Cuando creamos una función, se crea un *sub-entorno* contenido dentro de la función. ¿Por qué es esto relevante? Porque los entornos son los lugares en donde se guardan los objetos de los que haremos uso para nuestras funciones, y una función buscará *primero* en el entorno de la función, *luego* en el entorno que se encuentra un nivel por encima de este.\n\nVeámoslo con un ejemplo. La siguiente función toma un número y le suma 5:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff <- function(x){\n  y <- x + 5\n  y\n}\n```\n:::\n\n\n\n\nPor ejemplo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff(x = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n\n\nEsta función guarda el resultado en un objeto llamado `y`. Sin embargo, podemos ver que este objeto no se guarda en el entorno global, lo cual se evidencia cuando intentamos leer dicho objeto:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: objeto 'y' no encontrado\n```\n\n\n:::\n:::\n\n\n\n\nLa razón es que `y` se creó en el entorno de la función `fff()`, se guarda allí dentro, se utiliza para la ejecución de la función, y finalmente se descarta.\n\nVeamos ahora la siguiente variante de la función:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff <- function(){\n  y <- x + 5\n  y\n}\n```\n:::\n\n\n\n\nLa diferencia es que esta función no tiene argumentos. Veamos lo que sucede al correrla:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in fff(): objeto 'x' no encontrado\n```\n\n\n:::\n:::\n\n\n\n\nEl error se debe a que `x` no está definido. Pero miremos lo que pasa si definimos a `x` *por fuera* de la función:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 9\nfff()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n\n\n¿Que pasó? La función *buscó* al objeto `x` dentro del entorno de la función, no lo encontró, pero luego buscó en el entorno un nivel por encima, que es el entorno global. Encontró un objeto con dicho nombre, y lo utilizó para su ejecución.\n\n**Para testear:** ¿Qué sucedería si `x` está definido *por fuera* de la función pero también *dentro* de la misma?\n\n## Uso de `return()`\n\nDesarrollemos una función un poco más compleja. Por ejemplo, imaginemos una función que calcula el valor promedio de un conjunto de números (tarea que, ya sabemos, ejecuta `mean()`). Una forma de hacerlo es la siguiente:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x){\n  # Sumo todos los valores del vector x con un ciclo for\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i]\n  }\n  \n  # Divido la suma por la cantidad de elementos\n  promedio <- sum/length(x)\n  \n  return(promedio)\n}\n```\n:::\n\n\n\n\nNotar que el contenido de la función es casi idéntico a como programaríamos por fuera del contexto de una función. La única diferencia es que la función permite realizar la tarea propuesta **para cualquier caso**, y no para solo uno en particular. Aquí, podemos definir cualquier vector numérico que quisiéramos, y calcular el promedio a partir del vector indicado.\n\nOtra diferencia que vemos aquí respecto de la función del ejemplo anterior (`blabla()`) es el uso de la función `return()`. Esta expresión indica el valor a devolver por la función, y su llamado termina la ejecución de la función en esa línea. Es decir, toda línea de código por debajo de un `return()` no se ejecutará. ¿De qué serviría esto? Por ejemplo, la función podría ejecutar un bloque de código si se cumple una condición, y otro bloque si no se cumple, justificando la presencia de más de un `return()`.\n\nLa siguiente línea calcula el valor promedio para el vector `1:30`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(1:30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.5\n```\n\n\n:::\n:::\n\n\n\n\nNotar que no es necesario aclarar explícitamente el nombre del argumento `x`, basta con que sea el primero.\n\nUna versión un poquito más compleja que la anterior posee un segundo argumento que le otorga un peso a cada elemento de la muestra. Por lo tanto, estaremos calculando un promedio ponderado. Se espera un vector numérico de longitud igual a `x`, indicando el peso otorgado a cada elemento. Por defecto, definimos un vector numérico de unos, otorgando así el mismo peso a cada elemento:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x, pesos = rep(1, length(x))){\n  # Sumo todos los valores del vector x\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i] * pesos[i]\n  }\n  \n  promedio <- sum/length(x)\n  return(promedio)\n}\n```\n:::\n\n\n\n\nPor ejemplo, para el mismo conjunto de números anterior:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npesos_aleatorios <- sample(c(0.5, 0.75, 1), length(1:30), replace = TRUE)\nvalor_promedio(x = 1:30, pesos = pesos_aleatorios)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11.10833\n```\n\n\n:::\n:::\n\n\n\n\n## Uso de `stop()` y `warning()`\n\nAdemás de `return()`, las funciones `stop()` y `warning()` serán de utilidad cuando creemos nuestras propias funciones. Por ejemplo, imaginemos que el usuario indica para el argumento `x` un vector de tipo `character()`. Obviamente, el promedio no puede calcularse, y obtenemos un error. Este error, sin embargo, no es muy informativo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(x = LETTERS[1:10])\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[i] * pesos[i]: argumento no-numérico para operador binario\n```\n\n\n:::\n:::\n\n\n\n\nPodemos agregar una condición que evalúe si el vector es numérico, caso contrario utilizamos `stop()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser numérico.\")\n  }\n  \n  # Sumo todos los valores del vector x\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i] * pesos[i]\n  }\n  \n  promedio <- sum/length(x)\n  return(promedio)\n}\n```\n:::\n\n\n\n\nCon el uso de `stop()` la ejecución de la función se termina, y se imprime un mensaje informativo en la consola:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(x = LETTERS[1:10])\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in valor_promedio(x = LETTERS[1:10]): El vector indicado en 'x' debe ser numérico.\n```\n\n\n:::\n:::\n\n\n\n\nLa función `warning()` imprime una advertencia, pero continúa con la ejecución. Por ejemplo, imaginemos que el usuario indica un vector de pesos de diferente longitud a la longitud del vector indicado en `x`. Una opción para contemplar este escenario sería la siguiente:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser numérico.\")\n  }\n  \n  # Evalua si la longitud del vector en 'pesos' es igual a la de 'x'\n  if(length(x) != length(pesos)){\n    warning(\"El argumento 'pesos' debe ser un vector numérico de la misma longitud que el vector en 'x'. Se tomó el valor por defecto.\")\n    pesos <- rep(1, length(x))\n  }\n  \n  # Sumo todos los valores del vector x\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i] * pesos[i]\n  }\n  \n  promedio <- sum/length(x)\n  return(promedio)\n}\n```\n:::\n\n\n\n\nNotar que se evalúa la condición planteada para el argumento `pesos`. Si no se cumple que la longitud del vector indicado es igual a la longitud del vector en `x`, la función imprime una advertencia. Además, para que la función siga ejecutándose correctamente, definimos `pesos <- rep(1, length(x))`, es decir, el valor por defecto. Este último paso es fundamental, de lo contrario la salida de la función sería impredecible.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in valor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75)): El argumento\n'pesos' debe ser un vector numérico de la misma longitud que el vector en 'x'.\nSe tomó el valor por defecto.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.5\n```\n\n\n:::\n:::\n\n\n\n\nVemos que el promedio es calculado correctamente (con `pesos = rep(1, length(x))`), pero además se imprime una advertencia.\n\nEl uso de las funciones `stop()` y `warning()` en el contexto de funciones no es fundamental, pero adquieren relevancia para funciones que usarán otras personas. Uno nunca sabe con absoluta seguridad el tipo de entrada que un usuario externo usaría en una de nuestras funciones, y uno debe prevenir distintos escenarios. Sin embargo, si a las funciones las usaremos sólo nosotros, contemplar estos escenarios no será vital, por lo que no sería absolutamente necesario el uso de `stop()` o `warning()`.\n\n------------------------------------------------------------------------\n\n## Funciones del tipo *apply*\n\nLas funciones de la familia *apply* se utilizan para aplicar una función determinada a una lista o a un vector. Es útil para realizar un mismo cálculo a un conjunto de elementos dado, evitando utilizar, por ejemplo, un ciclo `for`.\n\nPor ejemplo, imaginemos una lista de 3 elementos, cada elemento un vector numérico:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlista_numeros <- list(sample(1:1000, size = 50),\n                      sample(1:1000, size = 50),\n                      sample(1:1000, size = 50))\nlista_numeros\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 708  62 723 393 285 212 944 489  38 576 106 265 200 898 878 104 338 485 941\n[20] 658 416  61 768 366 131 765 871 473 113  25  59 803 641 888 135 442 512 315\n[39]  89 372 932 102 284 546 340 897 627 682 578 604\n\n[[2]]\n [1] 938 383 884 139 549 702 870 305 151 236 221 993 266 239   6 605 319 829 573\n[20] 786 517 634 165 519 342 323 853 102 684 643 138 348 466 584 930 353 941 371\n[39] 253 677  14 729 290 110 751 116 631 133 231  89\n\n[[3]]\n [1] 933 873 869 555 579  37 817 587 691 318 118 838 241 169 760 900 899 495 664\n[20] 876 513  51 147 151 995 577 865 970 290 506 330  30 912  81 801 897 570 416\n[39] 413 305 389 757 563 635 945 123 308 923 154 629\n```\n\n\n:::\n:::\n\n\n\n\nLa función `sapply()` aplica una función dada a un objeto de tipo `list()`, y devuelve un vector. En este ejemplo, utilizaremos la función recientemente creada (`valor_promedio()`), para calcular el promedio de cada conjunto de números de la lista (indicados en el primer argumento):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npromedios <- sapply(lista_numeros, FUN = valor_promedio)\npromedios\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 462.80 458.62 549.30\n```\n\n\n:::\n:::\n\n\n\n\nNotar que para el argumento `FUN` indicamos el nombre de la función sin los paréntesis, la cual debe existir en el entorno (cargada por el usuario o por defecto en R).\n\nSi quisiéramos indicar otros argumentos para la función `valor_promedio()`, estos pueden definirse luego del argumento `FUN`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npesos_aleatorios <- sample(c(0.5, 0.75, 1), size = 50, replace = TRUE)\npromedios <- sapply(lista_numeros, FUN = valor_promedio, pesos = pesos_aleatorios)\npromedios\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 350.735 357.310 443.125\n```\n\n\n:::\n:::\n\n\n\n\n**Para pensar:** tal cual como está programada, la función `valor_promedio()` no es útil para ser utilizada con la función `sapply()`, especialmente en cuanto al argumento `pesos`. ¿Por qué?\n\nExisten otras variantes a la función `sapply()`, como por ejemplo `lapply()`, que funciona de manera idéntica pero devuelve una lista en vez de un vector.\n\n## Ejercicios\n\n1.  Cree una función que calcule el área de un triángulo a partir de su base y altura. Contemple el escenario en el que el usuario indique valores no numéricos para los argumentos.\n2.  Cree una función que calcule el error estándar de un conjunto de números. El error estándar se calcula realizando el cociente entre el desvío estándar de la muestra y la raíz cuadrada de la cantidad de números evaluados.\n3.  A partir de la función que calcula el error estándar, utilice la función `sapply()` para calcular el error estándar del conjunto de números `seq(1, 50, 20)`, `c(501, 920, 759, 233)` y `-14:28`.\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_funciones.png\" target=\"_blank\"><img src=\"pics/meme_practico_funciones.png\" style=\"padding: 5px 0 5px 0;width: 40rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}