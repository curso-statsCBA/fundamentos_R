{
  "hash": "19fd55845cf6af82cce92284fc02d078",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Funciones\"\npagetitle: \"Funciones\"\n---\n\n\n\n\n\n\n## ¿Cómo creo una función?\n\nLas funciones en R son las herramientas que nos permiten realizar una gran diversidad de análisis. Para ello, R provee de una numerosa y potente biblioteca de ellas, las cuales vienen instalada por defecto. Además, como hemos desarrollado al principio del curso, existe una abanico mega-diverso de paquetes de R desarrollados por los propios usuarios, especialmente desarrollados para la realización de tareas específicas.\n\nNo obstante, es usual que en un flujo de trabajo de intermedio a avanzado necesitemos desarrollar nuestras propias funciones. La razón para ello radica en la ejecución de una tarea muy específica como parte de nuestros análisis, pero que al mismo tiempo debe realizarse múltiples veces para que amerite su desarrollo en forma de función.\n\nLas funciones en R se asignan a objetos, cuyo nombre será el nombre de la función, con la expresión `function()`. Dentro de los paréntesis debemos indicar los argumentos de la función. Estos serán los objetos con los que la función trabajará de alguna manera, y devolverá alguna salida determinada. La sintaxis general es la siguiente:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmi_funcion <- function(argumento1, argumento2, argumento3){\n  # Inserte aqui el codigo que trabajara con los objetos definidos en los argumentos,\n  # junto con la salida que se propone para la nueva funcion\n}\n```\n:::\n\n\n\n\nPor ejemplo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblabla <- function(nombre = \"- inserte aquí su nombre -\"){\n  print(paste(\"Mi nombre es\", nombre, \"y me encanta el curso de Fundamentos básicos del lenguaje R.\"))\n}\n```\n:::\n\n\n\n\nAl correr el bloque de código anterior, simplemente estamos *creando* la función, y no *corriendo* el código programado. Esta se carga como un objeto propio en el entorno, quedando disponible para su uso futuro.\n\nEn este ejemplo, el argumento `nombre` se encuentra asignado a una línea de texto. De esta manera, la función entiende que el valor indicado es el **valor por defecto**, para los casos los que el usuario no define un valor particular para dicho argumento. La definición de valores por defecto no es obligatoria, pero puede ser útil en muchos casos. Si corremos dicha función suelta, sin definir nada en específico, podemos observar el resultado:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblabla()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mi nombre es - inserte aquí su nombre - y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n```\n\n\n:::\n:::\n\n\n\n\nEn cambio, podemos asignarle un valor al argumento `nombre`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblabla(nombre = \"Lionel Scaloni\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mi nombre es Lionel Scaloni y me encanta el curso de Fundamentos básicos del lenguaje R.\"\n```\n\n\n:::\n:::\n\n\n\n\n### Unas palabritas sobre *entornos*\n\nUna cuestión a considerar en el contexto de creación de funciones es el uso que las mismas hacen de los *entornos*. Podemos definir a un entorno como al *espacio* en donde se guardan nuestros objetos. Cuando creamos un objeto, sea una tabla, un vector, una función o cualquier otro, estos se guardan en el *entorno global*, y de hecho aparecen visibles en el panel correspondiente de la interfaz de RStudio. Cuando creamos una función, se crea un *sub-entorno* contenido dentro de la función. ¿Por qué es esto relevante? Porque los entornos son los lugares en donde se guardan los objetos de los que haremos uso para nuestras funciones, y una función buscará *primero* en el entorno de la función, *luego* en el entorno que se encuentra un nivel por encima de este.\n\nVeámoslo con un ejemplo. La siguiente función toma un número y le suma 5:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff <- function(x){\n  y <- x + 5\n  y\n}\n```\n:::\n\n\n\n\nPor ejemplo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff(x = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n\n\nEsta función guarda el resultado en un objeto llamado `y`. Sin embargo, podemos ver que este objeto no se guarda en el entorno global, lo cual se evidencia cuando intentamos leer dicho objeto:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: objeto 'y' no encontrado\n```\n\n\n:::\n:::\n\n\n\n\nLa razón es que `y` se creó en el entorno de la función `fff()`, se guarda allí dentro, se utiliza para la ejecución de la función, y finalmente se descarta.\n\nVeamos ahora la siguiente variante de la función:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff <- function(){\n  y <- x + 5\n  y\n}\n```\n:::\n\n\n\n\nLa diferencia es que esta función no tiene argumentos. Veamos lo que sucede al correrla:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfff()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in fff(): objeto 'x' no encontrado\n```\n\n\n:::\n:::\n\n\n\n\nEl error se debe a que `x` no está definido. Pero miremos lo que pasa si definimos a `x` *por fuera* de la función:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 9\nfff()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n\n\n¿Que pasó? La función *buscó* al objeto `x` dentro del entorno de la función, no lo encontró, pero luego buscó en el entorno un nivel por encima, que es el entorno global. Encontró un objeto con dicho nombre, y lo utilizó para su ejecución.\n\n**Para testear:** ¿Qué sucedería si `x` está definido *por fuera* de la función pero también *dentro* de la misma?\n\n## Uso de `return()`\n\nDesarrollemos una función un poco más compleja. Por ejemplo, imaginemos una función que calcula el valor promedio de un conjunto de números (tarea que, ya sabemos, ejecuta `mean()`). Una forma de hacerlo es la siguiente:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x){\n  # Sumo todos los valores del vector x con un ciclo for\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i]\n  }\n  \n  # Divido la suma por la cantidad de elementos\n  promedio <- sum/length(x)\n  \n  return(promedio)\n}\n```\n:::\n\n\n\n\nNotar que el contenido de la función es casi idéntico a como programaríamos por fuera del contexto de una función. La única diferencia es que la función permite realizar la tarea propuesta **para cualquier caso**, y no para solo uno en particular. Aquí, podemos definir cualquier vector numérico que quisiéramos, y calcular el promedio a partir del vector indicado.\n\nOtra diferencia que vemos aquí respecto de la función del ejemplo anterior (`blabla()`) es el uso de la función `return()`. Esta expresión indica el valor a devolver por la función, y su llamado termina la ejecución de la función en esa línea. Es decir, toda línea de código por debajo de un `return()` no se ejecutará. ¿De qué serviría esto? Por ejemplo, la función podría ejecutar un bloque de código si se cumple una condición, y otro bloque si no se cumple, justificando la presencia de más de un `return()`.\n\nLa siguiente línea calcula el valor promedio para el vector `1:30`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(1:30)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.5\n```\n\n\n:::\n:::\n\n\n\n\nNotar que no es necesario aclarar explícitamente el nombre del argumento `x`, basta con que sea el primero.\n\nUna versión un poquito más compleja que la anterior posee un segundo argumento que le otorga un peso a cada elemento de la muestra. Por lo tanto, estaremos calculando un promedio ponderado. Se espera un vector numérico de longitud igual a `x`, indicando el peso otorgado a cada elemento. Por defecto, definimos un vector numérico de unos, otorgando así el mismo peso a cada elemento:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x, pesos = rep(1, length(x))){\n  # Sumo todos los valores del vector x\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i] * pesos[i]\n  }\n  \n  promedio <- sum/length(x)\n  return(promedio)\n}\n```\n:::\n\n\n\n\nPor ejemplo, para el mismo conjunto de números anterior:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npesos_aleatorios <- sample(c(0.5, 0.75, 1), length(1:30), replace = TRUE)\nvalor_promedio(x = 1:30, pesos = pesos_aleatorios)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 11.375\n```\n\n\n:::\n:::\n\n\n\n\n## Uso de `stop()` y `warning()`\n\nAdemás de `return()`, las funciones `stop()` y `warning()` serán de utilidad cuando creemos nuestras propias funciones. Por ejemplo, imaginemos que el usuario indica para el argumento `x` un vector de tipo `character()`. Obviamente, el promedio no puede calcularse, y obtenemos un error. Este error, sin embargo, no es muy informativo:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(x = LETTERS[1:10])\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x[i] * pesos[i]: argumento no-numérico para operador binario\n```\n\n\n:::\n:::\n\n\n\n\nPodemos agregar una condición que evalúe si el vector es numérico, caso contrario utilizamos `stop()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser numérico.\")\n  }\n  \n  # Sumo todos los valores del vector x\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i] * pesos[i]\n  }\n  \n  promedio <- sum/length(x)\n  return(promedio)\n}\n```\n:::\n\n\n\n\nCon el uso de `stop()` la ejecución de la función se termina, y se imprime un mensaje informativo en la consola:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(x = LETTERS[1:10])\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in valor_promedio(x = LETTERS[1:10]): El vector indicado en 'x' debe ser numérico.\n```\n\n\n:::\n:::\n\n\n\n\nLa función `warning()` imprime una advertencia, pero continúa con la ejecución. Por ejemplo, imaginemos que el usuario indica un vector de pesos de diferente longitud a la longitud del vector indicado en `x`. Una opción para contemplar este escenario sería la siguiente:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio <- function(x, pesos = rep(1, length(x))){\n  # Evalua si el vector en x son numeros\n  if(!is.numeric(x)){\n    stop(\"El vector indicado en 'x' debe ser numérico.\")\n  }\n  \n  # Evalua si la longitud del vector en 'pesos' es igual a la de 'x'\n  if(length(x) != length(pesos)){\n    warning(\"El argumento 'pesos' debe ser un vector numérico de la misma longitud que el vector en 'x'. Se tomó el valor por defecto.\")\n    pesos <- rep(1, length(x))\n  }\n  \n  # Sumo todos los valores del vector x\n  sum <- 0\n  for (i in 1:length(x)){\n    sum <- sum + x[i] * pesos[i]\n  }\n  \n  promedio <- sum/length(x)\n  return(promedio)\n}\n```\n:::\n\n\n\n\nNotar que se evalúa la condición planteada para el argumento `pesos`. Si no se cumple que la longitud del vector indicado es igual a la longitud del vector en `x`, la función imprime una advertencia. Además, para que la función siga ejecutándose correctamente, definimos `pesos <- rep(1, length(x))`, es decir, el valor por defecto. Este último paso es fundamental, de lo contrario la salida de la función sería impredecible.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in valor_promedio(x = 1:30, pesos = c(0.5, 1, 0.75)): El argumento\n'pesos' debe ser un vector numérico de la misma longitud que el vector en 'x'.\nSe tomó el valor por defecto.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15.5\n```\n\n\n:::\n:::\n\n\n\n\nVemos que el promedio es calculado correctamente (con `pesos = rep(1, length(x))`), pero además se imprime una advertencia.\n\nEl uso de las funciones `stop()` y `warning()` en el contexto de funciones no es fundamental, pero adquieren relevancia para funciones que usarán otras personas. Uno nunca sabe con absoluta seguridad el tipo de entrada que un usuario externo usaría en una de nuestras funciones, y uno debe prevenir distintos escenarios. Sin embargo, si a las funciones las usaremos sólo nosotros, contemplar estos escenarios no será vital, por lo que no sería absolutamente necesario el uso de `stop()` o `warning()`.\n\n------------------------------------------------------------------------\n\n## Funciones del tipo *apply*\n\nLas funciones de la familia *apply* se utilizan para aplicar una función determinada a una lista o a un vector. Es útil para realizar un mismo cálculo a un conjunto de elementos dado, evitando utilizar, por ejemplo, un ciclo `for`.\n\nPor ejemplo, imaginemos una lista de 3 elementos, cada elemento un vector numérico:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlista_numeros <- list(sample(1:1000, size = 50),\n                      sample(1:1000, size = 50),\n                      sample(1:1000, size = 50))\nlista_numeros\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 218 462 931 133 731 509 206 969 101 558 747 351  52  85 196 987 525 504 327\n[20] 963  64 814 578 560 262 228 408 336 736 436 770 651   1 259 884 505 676 517\n[39] 858 199 127 844 383 106 620 966  68 671 567   7\n\n[[2]]\n [1] 486 776 645 397 129 615 962 392 456 625 551 142  85 541 593 863 661 665 880\n[20] 111 152 503 283 401  89 996 147 767 173 135 110 859 298  54  98 643 995 256\n[39] 425 573 801 198 873 105 343 345 651 499 877 382\n\n[[3]]\n [1] 606 766 182 315 327 777 484 351 875  71 206  37 519 442 468 649 899 596 474\n[20] 747  55 692 900 467 536 341 530 101 533 539 413 207 131 239  47 708 369  56\n[39] 518 375  76 975 265 214 776 417 373 786 804 248\n```\n\n\n:::\n:::\n\n\n\n\nLa función `sapply()` aplica una función dada a un objeto de tipo `list()`, y devuelve un vector. En este ejemplo, utilizaremos la función recientemente creada (`valor_promedio()`), para calcular el promedio de cada conjunto de números de la lista (indicados en el primer argumento):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npromedios <- sapply(lista_numeros, FUN = valor_promedio)\npromedios\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 473.12 472.12 449.64\n```\n\n\n:::\n:::\n\n\n\n\nNotar que para el argumento `FUN` indicamos el nombre de la función sin los paréntesis, la cual debe existir en el entorno (cargada por el usuario o por defecto en R).\n\nSi quisiéramos indicar otros argumentos para la función `valor_promedio()`, estos pueden definirse luego del argumento `FUN`:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npesos_aleatorios <- sample(c(0.5, 0.75, 1), size = 50, replace = TRUE)\npromedios <- sapply(lista_numeros, FUN = valor_promedio, pesos = pesos_aleatorios)\npromedios\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 344.960 341.270 313.805\n```\n\n\n:::\n:::\n\n\n\n\n**Para pensar:** tal cual como está programada, la función `valor_promedio()` no es útil para ser utilizada con la función `sapply()`, especialmente en cuanto al argumento `pesos`. ¿Por qué?\n\nExisten otras variantes a la función `sapply()`, como por ejemplo `lapply()`, que funciona de manera idéntica pero devuelve una lista en vez de un vector.\n\n## Ejercicios\n\n1.  Cree una función que calcule el área de un triángulo a partir de su base y altura. Contemple el escenario en el que el usuario indique valores no numéricos para los argumentos.\n2.  Cree una función que calcule el error estándar de un conjunto de números. El error estándar se calcula realizando el cociente entre el desvío estándar de la muestra y la raíz cuadrada de la cantidad de números evaluados.\n3.  A partir de la función que calcula el error estándar, utilice la función `sapply()` para calcular el error estándar del conjunto de números `seq(1, 50, 20)`, `c(501, 920, 759, 233)` y `-14:28`.\n\n<br>\n\n<p align=\"center\">\n\n<a href=\"pics/meme_practico_funciones.png\" target=\"_blank\"><img src=\"pics/meme_practico_funciones.png\" style=\"padding: 5px 0 5px 0;width: 40rem;max-width:100%;height:auto;vertical-align:middle;border-style: none;\"/></a>\n\n</p>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}